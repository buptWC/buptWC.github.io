<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Leetcode 943 Find the Shortest Superstring</title>
      <link href="/2018/11/19/Leetcode-943-Find-the-Shortest-Superstring/"/>
      <url>/2018/11/19/Leetcode-943-Find-the-Shortest-Superstring/</url>
      <content type="html"><![CDATA[<p>给定一个字符串数组A，找出一个字符串S使得A中的每个字符串都是S的一个子串，并且使S的长度最短。</p><p>默认A中不存在某一个字符串是另一个字符串的子串。</p><a id="more"></a><blockquote><p>Example 1:<br>Input: [“alex”,”loves”,”leetcode”]<br>Output: “alexlovesleetcode”<br>Explanation: All permutations of “alex”,”loves”,”leetcode” would also be accepted.</p></blockquote><blockquote><p>Example 2:<br>Input: [“catg”,”ctaagt”,”gcta”,”ttca”,”atgcatc”]<br>Output: “gctaagttcatgcatc”</p></blockquote><p>Note:</p><ol><li>1 &lt;= A.length &lt;= 12</li><li>1 &lt;= A[i].length &lt;= 20</li></ol><p><b>思路分析：</b><br>这道题实际上是一个图的问题。<br>对于<code>A = [&quot;catg&quot;,&quot;ctaagt&quot;,&quot;gcta&quot;,&quot;ttca&quot;,&quot;atgcatc&quot;]</code><br>不妨认为每一个字符串对应一个结点。边的权值则对应着两个结点之间重复部分的长度。<br>（0对应’catg’, 1对应’ctaagt,以此类推）<br><img src="/images/leetcode_943.png" alt=""><br>其中，<code>G[2][1] = 3</code>表示1结点若放在2结点后面可以省下3个字符长度。<br>最终，省得越多，最后的字符串长度就越短。</p><p>那么这道题就转换成了，在一个图中，从某个点出发将所有点恰好遍历一遍，使得最后路过的路径长度最长。（注意，虽然1,3之间没有连线但仍然可以从结点1走到结点3。）</p><p>首先我们将图构造出来<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getDistance</span><span class="params">(s1, s2)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s1)):</span><br><span class="line">            <span class="keyword">if</span> s2.startswith(s1[i:]):</span><br><span class="line">                <span class="keyword">return</span> len(s1) - i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">n = len(A)</span><br><span class="line">G = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n):</span><br><span class="line">        G[i][j] = getDistance(A[i], A[j])</span><br><span class="line">        G[j][i] = getDistance(A[j], A[i])</span><br></pre></td></tr></table></figure></p><p>我们这里采用bfs的方法去遍历整个图，但如果不做任何处理，将所有情况全部考虑的话，共有<code>12x11x10x...x1 = 12!</code>种情况，时间复杂度过大。<br>稍微想一想，这其中有很多重复计算，例如对于这两个状态：</p><ol><li>2-&gt;1-&gt;3-&gt;…</li><li>1-&gt;2-&gt;3-&gt;…<br>同样是遍历了1,2,3这三个结点，并且当前都处在3结点上，我们是并不用将这两种情况都计算的。<br>假设对于<code>1-&gt;2-&gt;3</code>我们计算出来已经走过的长度为<code>L1</code>，对于<code>2-&gt;1-&gt;3</code>我们计算出来已经走过的长度为<code>L2</code>，如果有<code>L2 &lt; L1</code>，那么无论后面怎么走，第二种情况都不可能比第一种情况更优。所以我们可以舍弃掉第二种情况。</li></ol><p>基于这个思想，我们使用一个空间<code>d[mask][node]</code>来记录当前状态下已经走的路程。其中：<br><code>mask</code>表示当前已经遍历过的结点，<code>10011</code>表示已经遍历了<code>0,1,4</code>三个结点。（1 &lt;&lt; i）<br><code>node</code>表示当前所处结点。</p><p>在bfs中，这里采用了这样的结构<code>(node, mask, path, repeat_len)</code>。其中：<br><code>node</code>表示当前结点<br><code>mask</code>表示当前遍历过的结点<br><code>path</code>表示遍历结点的顺序(长度不超过12，所以不用担心空间过大)<br><code>repeat_len</code>表示目前重复部分的长度。</p><p>当<code>mask == 11111</code>时，表示已经遍历过所有结点，我们取此时<code>repeat_len</code>最大的path，然后通过path构造最后的字符串</p><p>例如<code>path = [2,1,3,0,4]</code>，那么构造函数如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pathtoStr</span><span class="params">(A, G, path)</span>:</span></span><br><span class="line">    res = A[path[<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(path)):</span><br><span class="line">        indice = G[path[i<span class="number">-1</span>]][path[i]]</span><br><span class="line">        res += A[path[i]][indice:]</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><p>全部代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestSuperstring</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getDistance</span><span class="params">(s1, s2)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s1)):</span><br><span class="line">                <span class="keyword">if</span> s2.startswith(s1[i:]):</span><br><span class="line">                    <span class="keyword">return</span> len(s1) - i</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">pathtoStr</span><span class="params">(A, G, path)</span>:</span></span><br><span class="line">            res = A[path[<span class="number">0</span>]]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(path)):</span><br><span class="line">                res += A[path[i]][G[path[i<span class="number">-1</span>]][path[i]]:]</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        n = len(A)</span><br><span class="line">        G = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, n):</span><br><span class="line">                G[i][j] = getDistance(A[i], A[j])</span><br><span class="line">                G[j][i] = getDistance(A[j], A[i])</span><br><span class="line"></span><br><span class="line">        d = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(<span class="number">1</span>&lt;&lt;n)]</span><br><span class="line">        Q = collections.deque([(i, <span class="number">1</span>&lt;&lt;i, [i], <span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n)])</span><br><span class="line">        l = <span class="number">-1</span> <span class="comment"># 记录最大的repeat_len</span></span><br><span class="line">        P = [] <span class="comment"># 记录对应的path</span></span><br><span class="line">        <span class="keyword">while</span> Q:</span><br><span class="line">            node, mask, path, dis = Q.popleft()</span><br><span class="line">            <span class="keyword">if</span> dis &lt; d[mask][node]: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> mask == (<span class="number">1</span>&lt;&lt;n) - <span class="number">1</span> <span class="keyword">and</span> dis &gt; l:</span><br><span class="line">                P,l = path,dis</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">                nex_mask = mask | (<span class="number">1</span>&lt;&lt;i)</span><br><span class="line">                <span class="comment"># case1: 不能走回头路，因为每个结点只能遍历一次</span></span><br><span class="line">                <span class="comment"># case2: 如果走当前这条路能够获得更大的重复长度，才继续考虑</span></span><br><span class="line">                <span class="keyword">if</span> nex_mask != mask <span class="keyword">and</span> d[mask][node] + G[node][i] &gt;= d[nex_mask][i]:</span><br><span class="line">                    d[nex_mask][i] = d[mask][node] + G[node][i]</span><br><span class="line">                    Q.append((i, nex_mask, path+[i], d[nex_mask][i]))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pathtoStr(A,G,P)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dp </tag>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 24 Swap Nodes in Pairs</title>
      <link href="/2018/11/13/Leetcode-24-Swap-Nodes-in-Pairs/"/>
      <url>/2018/11/13/Leetcode-24-Swap-Nodes-in-Pairs/</url>
      <content type="html"><![CDATA[<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>示例:<br>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.<br><a id="more"></a></p><p>说明:<br>你的算法只能使用常数的额外空间。<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p><b>思路分析：</b><br>题目要求我们使用常数的额外空间，意思是不让我们用递归。迭代就稍微麻烦一点，但思路一样，我们先看递归怎么写，然后推出迭代怎么写。</p><p><img src="/images/leetcode_24.png" alt=""></p><p><b>递归：</b><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next: <span class="keyword">return</span> head</span><br><span class="line">        cur = head.next</span><br><span class="line">        pre = head</span><br><span class="line">        nex = cur.next</span><br><span class="line">        cur.next,pre.next = pre, self.swapPairs(nex)</span><br><span class="line">        <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure></p><p>那么迭代就很好想了，我们只需要将pre.next就指向nex.next，然后把pre,cur换成nex,nex.next即可。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 20ms, beats 100%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next: <span class="keyword">return</span> head</span><br><span class="line">        ret = ListNode(<span class="number">0</span>)</span><br><span class="line">        ret.next = head.next <span class="comment"># 指向最后的头结点</span></span><br><span class="line"></span><br><span class="line">        pre, cur = head, head.next</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            nex = cur.next</span><br><span class="line">            cur.next = pre</span><br><span class="line">            <span class="keyword">if</span> nex <span class="keyword">and</span> nex.next:</span><br><span class="line">                pre.next = nex.next</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 处理一下边界情况</span></span><br><span class="line">                pre.next = nex</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            pre, cur = nex, nex.next</span><br><span class="line">        <span class="keyword">return</span> ret.next</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> implementation </tag>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 23 Merge k Sorted Lists</title>
      <link href="/2018/11/13/Leetcode-23-Merge-k-Sorted-Lists/"/>
      <url>/2018/11/13/Leetcode-23-Merge-k-Sorted-Lists/</url>
      <content type="html"><![CDATA[<p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p><blockquote><p>示例:<br>输入: [1-&gt;4-&gt;5,1-&gt;3-&gt;4,2-&gt;6]<br>输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p></blockquote><a id="more"></a><p><b>思路分析：</b><br>要将k个链表合并成一个有序链表，直接一点思考那就是每次都看k个链表的头部节点谁最小，就把最小的节点加入结果中。<br>当然，把最小的点加入后，指针需向后移动，将下一个节点和剩下k-1个节点继续比较。</p><p>这样每次都要从k个元素中找最小的值，最小堆正好完美契合我们的需求。<br>用(node.val, node)作为堆中的元素，这样就可以按照node.val进行排序了，堆顶元素保证是值最小的节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 108ms, beats 42.63%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists)</span>:</span></span><br><span class="line">        heap = []</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> l: <span class="keyword">continue</span></span><br><span class="line">            heapq.heappush(heap, (l.val, l))</span><br><span class="line"></span><br><span class="line">        L = ret = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> heap:</span><br><span class="line">            val, p = heapq.heappop(heap)</span><br><span class="line">            L.next = p</span><br><span class="line">            L = L.next</span><br><span class="line">            <span class="keyword">if</span> p.next: heapq.heappush(heap, (p.next.val, p.next))</span><br><span class="line">        <span class="keyword">return</span> ret.next</span><br></pre></td></tr></table></figure><p>既然题目让我们分析一下复杂度，那我们就来看一下，对于每个结点，都只进行了一次进堆和出堆操作。所以时间复杂度为<code>O(num)</code>，num表示k个链表中所有节点的数量.</p>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 22 Generate Parentheses</title>
      <link href="/2018/11/13/Leetcode-22-Generate-Parentheses/"/>
      <url>/2018/11/13/Leetcode-22-Generate-Parentheses/</url>
      <content type="html"><![CDATA[<p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p><p>例如，给出 n = 3，生成结果为：<br>[<br>  “((()))”,<br>  “(()())”,<br>  “(())()”,<br>  “()(())”,<br>  “()()()”<br>]<br><a id="more"></a></p><p><b>题意分析：</b><br>要我们找出所有合法的包括n对括号的字符串！</p><p><b>思路分析：</b><br>当碰到这道题的时候，应该如何去思考呢？就拿n=3当例子，显然，我们不能凭空构造，我们将n=3结果分解一下，发现有以下几种情况:</p><ol><li>‘(‘ + ss + ‘)’</li><li>‘()’ + ss</li><li>ss + ‘()’</li></ol><p>其中ss是拥有两队括号的合法字符串，突然发现好像找到规律了。<br>我们定义f(3)表示n=3时题目的答案，那么有：<br>f(3) = <code>&#39;(&#39; + ss + &#39;)&#39;</code> , <code>&#39;()&#39; + ss</code>, <code>ss + &#39;()&#39;</code> for ss in f(2)</p><p>但是如果就直接单纯的以为答案就是按照上面三种情况依次累加的话就错了（我就犯了这个错误）<br>例如对于n=4，有’(())(())’，这种情况是无法通过之前说的三种模式构造出来的。我们可以看出<code>&#39;(())(())&#39;</code>是可以分解成两个 <code>n=2的情况</code>，很容易想到:<br><code>f(4) = f(1) 组合 f(3) + f(2) 组合 f(2)</code></p><p>注意到会存在重复计算，所以使用一下记忆化的思想。并且单独考虑 <code>&#39;(&#39; + ss + &#39;)&#39;</code>这种情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 36ms, beats 16.54%</span></span><br><span class="line">cache = &#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> [<span class="string">'()'</span>]</span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">in</span> cache: <span class="keyword">return</span> cache[n]</span><br><span class="line">        s = set()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> s1 <span class="keyword">in</span> self.generateParenthesis(i):</span><br><span class="line">                <span class="keyword">for</span> s2 <span class="keyword">in</span> self.generateParenthesis(n-i):</span><br><span class="line">                    <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">                        s.add(<span class="string">'('</span> + s2 + <span class="string">')'</span>)</span><br><span class="line">                    s.add(s1+s2)</span><br><span class="line">        cache[n] = list(s)</span><br><span class="line">        <span class="keyword">return</span> cache[n]</span><br></pre></td></tr></table></figure><p>以上属于我的肤浅想法，实际有大神真就凭空把所有的结果构造出来了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(p, left, right, parens=[])</span>:</span></span><br><span class="line">            <span class="keyword">if</span> left:         generate(p + <span class="string">'('</span>, left<span class="number">-1</span>, right)</span><br><span class="line">            <span class="keyword">if</span> right &gt; left: generate(p + <span class="string">')'</span>, left, right<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> right:    parens += p,</span><br><span class="line">            <span class="keyword">return</span> parens</span><br><span class="line">        <span class="keyword">return</span> generate(<span class="string">''</span>, n, n)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 21 Merge Two Sorted Lists</title>
      <link href="/2018/11/13/Leetcode-21-Merge-Two-Sorted-Lists/"/>
      <url>/2018/11/13/Leetcode-21-Merge-Two-Sorted-Lists/</url>
      <content type="html"><![CDATA[<p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例：<br>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br><a id="more"></a></p><p><b>题意分析：</b><br>将两个有序链表合并成一个有序链表，并且题目规定不能单纯新开节点然后赋值，一定要使用给定链表中的节点。</p><p><b>思路分析：</b><br>这里给出两种做法，一种迭代，一种递归。</p><p><b>迭代：</b><br>用两个指针分别指向两个链表的首部，然后依次比较，将值较小的那个节点加入到结果中。<br>为了处理两个链表不等长的问题，我默认当链表为空的时候它的值是无穷大！(这样可以使代码更加整洁，因为可以用一个逻辑完成所有的判断)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="comment"># 迭代 28ms,beats 93.46%</span></span><br><span class="line">        inf = float(<span class="string">'inf'</span>)</span><br><span class="line">        ret = head = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2:</span><br><span class="line">            val1 = l1.val <span class="keyword">if</span> l1 <span class="keyword">else</span> inf</span><br><span class="line">            val2 = l2.val <span class="keyword">if</span> l2 <span class="keyword">else</span> inf</span><br><span class="line">            <span class="keyword">if</span> val1 &lt;= val2:</span><br><span class="line">                head.next = l1</span><br><span class="line">                head,l1 = head.next,l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                head.next = l2</span><br><span class="line">                head,l2 = head.next,l2.next</span><br><span class="line">        <span class="keyword">return</span> ret.next</span><br></pre></td></tr></table></figure></p><p><b>递归：</b><br>递归的思路用文字描述可能比较麻烦，还是直接看代码吧<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="comment"># 递归 42ms,beats 14.27%</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1: <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l2: <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">            l1.next = self.mergeTwoLists(l1.next, l2)</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l2.next = self.mergeTwoLists(l1, l2.next)</span><br><span class="line">            <span class="keyword">return</span> l2</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> implementation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 20 Valid Parentheses</title>
      <link href="/2018/11/13/Leetcode-20-Valid-Parentheses/"/>
      <url>/2018/11/13/Leetcode-20-Valid-Parentheses/</url>
      <content type="html"><![CDATA[<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。<br>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</li></ol><blockquote><p>示例 1:<br>输入: “()”<br>输出: true</p></blockquote><a id="more"></a><blockquote><p>示例 2:<br>输入: “()[]{}”<br>输出: true</p></blockquote><blockquote><p>示例 3:<br>输入: “(]”<br>输出: false</p></blockquote><blockquote><p>示例 4:<br>输入: “([)]”<br>输出: false</p></blockquote><blockquote><p>示例 5:<br>输入: “{[]}”<br>输出: true</p></blockquote><p><b>题意分析：</b><br>判断一个括号字符串是否合法，在这道题中需要满足：</p><ol><li>每个左括号都需要有一个对应的右括号与其对应</li><li>在一对合法括号里面的括号，也需要是合法的（见示例4,5）</li></ol><p><b>思路分析：</b><br>leetcode之后还会有很多这种判断括号合法的问题，这种题目通常都是使用<code>栈</code>来解决的。<br>基本思路为：<br><code>左括号来了就进栈，右括号来了就看栈顶元素是否匹配，匹配就出栈，继续分析下一个括号，最后观察栈是否为空（确保没有多余的左括号！）</code></p><p>而这道题需要做一点小小的改动，那就是右括号来的时候，我们需要判断站定的元素是否为对应括号的左括号（因为这里有三种括号类型），用一个字典存了每个右括号对应的左括号，这样就可以少写一点if条件了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 24ms, beats 79.66%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        stack = []</span><br><span class="line">        d = &#123;<span class="string">')'</span>:<span class="string">'('</span>, <span class="string">']'</span>:<span class="string">'['</span>, <span class="string">'&#125;'</span>:<span class="string">'&#123;'</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> ss <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> ss <span class="keyword">in</span> <span class="string">'([&#123;'</span>:</span><br><span class="line">                stack.append(ss)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack <span class="keyword">or</span> stack[<span class="number">-1</span>] != d[ss]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                stack.pop()</span><br><span class="line">        <span class="keyword">return</span> len(stack) == <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 19 Remove Nth Node From End of List</title>
      <link href="/2018/11/13/Leetcode-19-Remove-Nth-Node-From-End-of-List/"/>
      <url>/2018/11/13/Leetcode-19-Remove-Nth-Node-From-End-of-List/</url>
      <content type="html"><![CDATA[<p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。<br>示例：<br>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.<br><a id="more"></a></p><p>说明：<br>  给定的 n 保证是有效的。<br>进阶：<br>  你能尝试使用一趟扫描实现吗？</p><p><b>题意分析：</b><br>在原链表中删除倒数第N个节点，让我们只能遍历一遍，如何确定倒数第N个节点的位置是关键！！</p><p><b>思路分析：</b><br>这是非常常见的一个思想，对于刚接触算法的人来说可能有点不太容易想到。<br>那就是使用两个指针，使这两个指针间隔为N，当<code>一个指针指向链表中的最后一个结点</code>时，<code>另一个指针自然就指向了倒数第N个节点</code>。</p><p>这里顺带介绍一下链表问题的其他几种常见操作。<br><b>找链表的中间位置：</b><br>双指针<code>slow,fast</code>，<code>slow</code>每次移动一位，<code>fast</code>每次移动两位，<code>fast</code>到链表结尾时<code>slow</code>自然就在中间。<br><b>判断链表是否有环：</b><br>双指针<code>slow,fast</code>，<code>slow</code>每次移动一位，<code>fast</code>每次移动两位，当<code>slow</code>和<code>fast</code>相遇则说明链表有环，反之则没有环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 24ms, beats 98.88%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head, n)</span>:</span></span><br><span class="line">        pre, cur = head, head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n): cur = cur.next</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">return</span> head.next</span><br><span class="line">        <span class="keyword">while</span> cur.next:</span><br><span class="line">            pre = pre.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        pre.next = pre.next.next</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> two pointers </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 940 Distinct Subsequences II</title>
      <link href="/2018/11/11/Leetcode-940-Distinct-Subsequences-II/"/>
      <url>/2018/11/11/Leetcode-940-Distinct-Subsequences-II/</url>
      <content type="html"><![CDATA[<p>给定一个字符串 S，计算 S 的不同非空子序列的个数。<br>因为结果可能很大，所以返回答案模 10^9 + 7.</p><a id="more"></a><blockquote><p>示例 1：<br>输入：”abc”<br>输出：7<br>解释：7 个不同的子序列分别是 “a”, “b”, “c”, “ab”, “ac”, “bc”, 以及 “abc”。<br>示例 2：<br>输入：”aba”<br>输出：6<br>解释：6 个不同的子序列分别是 “a”, “b”, “ab”, “ba”, “aa” 以及 “aba”。<br>示例 3：<br>输入：”aaa”<br>输出：3<br>解释：3 个不同的子序列分别是 “a”, “aa” 以及 “aaa”。</p></blockquote><p>提示：</p><ol><li>S 只包含小写字母。</li><li>1 &lt;= S.length &lt;= 2000</li></ol><p><b>题意分析：</b><br>又到了说这句话的时候。<code>看到mod 1e9+7</code>就要想到dp，这在我写的题解里面经常提到。</p><p><b>思路分析：</b><br>在我们知道要用dp的情况，如何去定义dp呢，首先看数据范围，看我们能定义几维的dp<br>len(s) &lt;= 2000，看样子可以定义2维的，但是按照套路来定义<code>dp[i][j]</code>表示s[i:j+1]中不同子序列的个数，好像是行不通的，因为推不出递推关系式。</p><p>这个时候可以换个思路，我定义<code>dp[i][c]</code>表示以字符c结尾的长度为<code>i</code>的子序列的个数<br>那么我们来分析一下递推式：<br><code>dp[3][&#39;a&#39;]</code>表示长度为3的以’a’结尾的子序列的个数。<br>那么它是不是等于所有长度为2的以’abcd…xyz’结尾的序列之和。<br>所以有， <code>dp[n][c] = sum(dp[n-1][k] for k in &#39;abcd...xyz&#39;)</code></p><p>我们所求的结果应该怎么用dp来表示呢？<br>既然求所有的不同子序列的个数，那么应该是包括：<br>以’a’结尾的长度为(1,2,3,..,n)的子序列的个数<br>以’b’结尾的长度为(1,2,3,..,n)的子序列的个数<br>…<br>以’z’结尾的长度为(1,2,3,..,n)的子序列的个数<br>也就是所有<code>dp[i][j]</code>的和</p><p>最后考虑初始化条件，显然<code>长度为1的以c结尾</code>的子序列个数必为1。<br>也就是<code>dp[1][c] = 1 for c in S</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TLE 85/109 passed， O(n^2) time, O(26n) space</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distinctSubseqII</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        n = len(S)</span><br><span class="line">        mod = <span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span></span><br><span class="line">        dp = [[<span class="number">0</span>]*<span class="number">26</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> range(i+<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">                dp[l][ord(S[i])-ord(<span class="string">'a'</span>)] = sum(dp[l<span class="number">-1</span>]) % mod</span><br><span class="line">            dp[<span class="number">1</span>][ord(S[i])-ord(<span class="string">'a'</span>)] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(dp)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">                res += dp[i][j]</span><br><span class="line">                res %= mod</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>但是很可惜，如果用空间这样迭代，会cost大量时间，并且最后计算res又要将整个dp重新迭代一遍<br>当len(s) = 2000时，平方就到了4000000，然后还迭代这么多次，最后超时了。</p><p>当然，len(s)&lt;2000可以用2维dp这个理论是没错的，这里就涉及到leetcode中判题的方法了<br>像codeforces这种，都是每一个例子单独算，然后取所有例子中运行时间最大的时间作为你这道题的最终运行时间。<br>而leetcode是把所有的test case一起运，总时间作为你的运行时间。即使上面这个方法过单个2000长度的case很轻松，但是case一多，就会超时，我们得想办法优化一下。(可惜，如果不优化成1维，按照我这个思路，我调了很久都没调出来ac的代码，但是discuss里面好像有人是n^2的代码通过的)</p><p>我们注意到每一维的计算只与上一维的结果有关，可以用到<code>滚动数组</code>，这样就可以优化成一维的了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 180ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distinctSubseqII</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        dp = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        mod = <span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span></span><br><span class="line">        <span class="keyword">for</span> ss <span class="keyword">in</span> S:</span><br><span class="line">            dp[ord(ss)-ord(<span class="string">'a'</span>)] = sum(dp) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> sum(dp) % mod</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 939 Minimum Area Rectangle</title>
      <link href="/2018/11/11/Leetcode-939-Minimum-Area-Rectangle/"/>
      <url>/2018/11/11/Leetcode-939-Minimum-Area-Rectangle/</url>
      <content type="html"><![CDATA[<p>给定在 xy 平面上的一组点，确定由这些点组成的矩形的最小面积，其中矩形的边平行于 x 轴和 y 轴。<br>如果没有任何矩形，就返回 0。</p><a id="more"></a> <blockquote><p>示例 1：<br>输入：[[1,1],[1,3],[3,1],[3,3],[2,2]]<br>输出：4<br>示例 2：<br>输入：[[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]]<br>输出：2</p></blockquote><p>提示：</p><ol><li>1 &lt;= points.length &lt;= 500</li><li>0 &lt;= points[i][0] &lt;= 40000</li><li>0 &lt;= points[i][1] &lt;= 40000</li><li>所有的点都是不同的。</li></ol><p><b>题意分析：</b><br>在所有点中找出四个点，使其能够构成一个平行于坐标轴的矩形，求可能构成的矩形的最小面积。</p><p><b>思路分析：</b><br>我们先用两个字典将所有的点按照横坐标和纵坐标记录下来<br>我们用<code>dx[i]</code>表示在<code>x= i</code>这条线上的所有点的纵坐标，用<code>dy[i]</code>表示在<code>y=i</code>这条线上所有点的纵坐标，那么对于示例1:，有：<br><code>dx = {1: [1,3], 2:[2], 3:[1,3]}</code><br><code>dy = {1: [1,3], 2:[2], 3:[1,3]}</code></p><p>我们如何去寻找矩形的四个点呢？</p><ol><li>在dx中选定一个x</li><li>在dx[x]中选定两个不同的y，分别为y1,y2</li><li>在dy[y1]中找到一个x1，且 <code>x1 != x</code></li><li>最后判断 <code>x1,y2</code> 是否存在于points当中。</li><li>若存在，计算面积</li><li>若不存在，go to step 1</li></ol><p><img src="/images/leetcode_939.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2000ms</span></span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minAreaRect</span><span class="params">(points)</span>:</span></span><br><span class="line">    s = set(map(tuple, points))</span><br><span class="line">    dx = collections.defaultdict(list)</span><br><span class="line">    dy = collections.defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> x,y <span class="keyword">in</span> points:</span><br><span class="line">        dx[x].append(y)</span><br><span class="line">        dy[y].append(x)</span><br><span class="line"></span><br><span class="line">    res = float(<span class="string">'inf'</span>)</span><br><span class="line">    <span class="comment"># 1. 确定x</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> sorted(dx.keys()):</span><br><span class="line">        <span class="comment"># 2.确定y1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(dx[x])):</span><br><span class="line">            y1 = dx[x][i]</span><br><span class="line">            <span class="comment"># 确定y2</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(dx[x])):</span><br><span class="line">                y2 = dx[x][j]</span><br><span class="line">                <span class="comment"># 3. 寻找x1</span></span><br><span class="line">                <span class="keyword">for</span> x1 <span class="keyword">in</span> dy[y2]:</span><br><span class="line">                    <span class="keyword">if</span> x1 == x: <span class="keyword">continue</span></span><br><span class="line">                    <span class="comment"># 4. 判断(x1,y1)是否在points当中</span></span><br><span class="line">                    <span class="keyword">if</span> (x1, y1) <span class="keyword">in</span> s:</span><br><span class="line">                        res = min(res, abs(x-x1) * abs(y1-y2))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res <span class="keyword">if</span> res != float(<span class="string">'inf'</span>) <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>你可能会有疑问，怎么耗时这么长，那是因为会有重复计算，就比如上图中，选择x的时候作为第一步的基准的时候将这个矩形考虑了一次，选择x1作为第一步的时候又将这个矩形计算了一次，这样就会存在大量重复计算，那怎么修改呢？</p><p>关键在于我们始终选择第一步中的x作为矩形左边这条边，之后寻找的x1必须要比x大才行。<br>只要将<code>if x1 == x</code> 改为 <code>if x1 &lt;= x</code>即可。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1300ms</span></span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minAreaRect</span><span class="params">(points)</span>:</span></span><br><span class="line">    s = set(map(tuple, points))</span><br><span class="line">    dx = collections.defaultdict(list)</span><br><span class="line">    dy = collections.defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> x,y <span class="keyword">in</span> points:</span><br><span class="line">        dx[x].append(y)</span><br><span class="line">        dy[y].append(x)</span><br><span class="line"></span><br><span class="line">    res = float(<span class="string">'inf'</span>)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> sorted(dx.keys()):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(dx[x])):</span><br><span class="line">            y1 = dx[x][i]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(dx[x])):</span><br><span class="line">                y2 = dx[x][j]</span><br><span class="line">                <span class="keyword">for</span> x1 <span class="keyword">in</span> dy[y2]:</span><br><span class="line">                    <span class="keyword">if</span> x1 &lt;= x: <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> (x1, y1) <span class="keyword">in</span> s:</span><br><span class="line">                        res = min(res, abs(x-x1) * abs(y1-y2))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res <span class="keyword">if</span> res != float(<span class="string">'inf'</span>) <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> implementation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 938 Range Sum of BST</title>
      <link href="/2018/11/11/Leetcode-938-Range-Sum-of-BST/"/>
      <url>/2018/11/11/Leetcode-938-Range-Sum-of-BST/</url>
      <content type="html"><![CDATA[<p>给定二叉搜索树的根结点 root，返回 L 和 R（含）之间的所有结点的值的和。<br>二叉搜索树保证具有唯一的值。</p><a id="more"></a><blockquote><p>示例 1：<br>输入：root = [10,5,15,3,7,null,18], L = 7, R = 15<br>输出：32<br>示例 2：<br>输入：root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10<br>输出：23</p></blockquote><p>提示：</p><ol><li>树中的结点数量最多为 10000 个。</li><li>最终的答案保证小于 2^31。</li></ol><p><b>题意分析：</b><br>在一个二叉搜索树中找到所有的值在L,R范围的节点的值的和。</p><p><b>思路分析：</b><br>这道题真是easy中的easy，要是实在不会用递归，也可以先把整个树遍历一遍，用一个O(n)的空间把所有节点值存下来，然后一个个数都行。</p><p>当然，在这里肯定还是要用递归的。<br><code>不过，说实在的，我们看到树中的节点数量达到10000个，如果最坏情况，讲道理递归是会爆栈的。</code>但是这里可能数据强度没那么大，所以递归可行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 248ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rangeSumBST</span><span class="params">(self, root, L, R)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> root.val &lt; L:</span><br><span class="line">            <span class="keyword">return</span> self.rangeSumBST(root.right, L, R)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> root.val &gt; R:</span><br><span class="line">            <span class="keyword">return</span> self.rangeSumBST(root.left, L, R)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> root.val + self.rangeSumBST(root.left, L, root.val<span class="number">-1</span>) + self.rangeSumBST(root.right, root.val+<span class="number">1</span>, R)</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> recursion </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 937 Reorder Log Files</title>
      <link href="/2018/11/11/Leetcode-937-Reorder-Log-Files/"/>
      <url>/2018/11/11/Leetcode-937-Reorder-Log-Files/</url>
      <content type="html"><![CDATA[<p>你有一个日志数组 logs。每条日志都是以空格分隔的字串。<br>对于每条日志，其第一个字为字母数字标识符。然后，有两种情况：</p><ol><li>标识符后面的每个字将仅由小写字母组成</li><li>标识符后面的每个字将仅由数字组成。</li></ol><p>我们将这两种日志分别称为字母日志和数字日志。保证每个日志在其标识符后面至少有一个字。<br>将日志重新排序，使得所有字母日志都排在数字日志之前。字母日志按字母顺序排序，忽略标识符，标识符仅用于表示关系。数字日志应该按原来的顺序排列。<br>返回日志的最终顺序。<br><a id="more"></a><br>示例 ：<br>输入：[“a1 9 2 3 1”,”g1 act car”,”zo4 4 7”,”ab1 off key dog”,”a8 act zoo”]<br>输出：[“g1 act car”,”a8 act zoo”,”ab1 off key dog”,”a1 9 2 3 1”,”zo4 4 7”]</p><p>提示：</p><ol><li>0 &lt;= logs.length &lt;= 100</li><li>3 &lt;= logs[i].length &lt;= 100</li><li>logs[i] 保证有一个标识符，并且标识符后面有一个字。</li></ol><p><b>题意分析：</b><br>将一些字符串重新进行排序，letter型需要digit型的前面，letter型要按照字典顺序进行排序</p><p><b>思路分析：</b><br>用两个列表分别保存letter型和digit型，对letter型进行排序<br>如何排序呢？我们先找到letter中的第一个空格所在的地方，记为<code>index</code>，那么<code>log[index+1:]</code>则对应着我们需要排序的部分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 36ms</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reorderLogFiles</span><span class="params">(logs)</span>:</span></span><br><span class="line">    digit = []</span><br><span class="line">    letters = []</span><br><span class="line">    info = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> log <span class="keyword">in</span> logs:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'0'</span> &lt;= log[<span class="number">-1</span>] &lt;= <span class="string">'9'</span>:</span><br><span class="line">            digit.append(log)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            letters.append(log)</span><br><span class="line">            index = log.index(<span class="string">' '</span>)</span><br><span class="line">            info[log] = log[index+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">    letters.sort(key= <span class="keyword">lambda</span> x: info[x])</span><br><span class="line">    <span class="keyword">return</span> letters + digit</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> implementation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 936 Stamping The Sequence </title>
      <link href="/2018/11/05/leetcode-936-Stamping-The-Sequence/"/>
      <url>/2018/11/05/leetcode-936-Stamping-The-Sequence/</url>
      <content type="html"><![CDATA[<p>你想要用小写字母组成一个目标字符串 target。<br>开始的时候，序列由 target.length 个 ‘?’ 记号组成。而你有一个小写字母印章 stamp。<br>在每个回合，你可以将印章放在序列上，并将序列中的每个字母替换为印章上的相应字母。你最多可以进行 10 * target.length  个回合。<br>举个例子，如果初始序列为 “?????”，而你的印章 stamp 是 “abc”，那么在第一回合，你可以得到 “abc??”、”?abc?”、”??abc”。（请注意，印章必须完全包含在序列的边界内才能盖下去。）</p><p>如果可以印出序列，那么返回一个数组，该数组由每个回合中被印下的最左边字母的索引组成。如果不能印出序列，就返回一个空数组。<br>例如，如果序列是 “ababc”，印章是 “abc”，那么我们就可以返回与操作 “?????” -&gt; “abc??” -&gt; “ababc” 相对应的答案 [0, 2]；<br>另外，如果可以印出序列，那么需要保证可以在 10 * target.length 个回合内完成。任何超过此数字的答案将不被接受。<br><a id="more"></a></p><blockquote><p>示例 1：<br>输入：stamp = “abc”, target = “ababc”<br>输出：[0,2]<br>（[1,0,2] 以及其他一些可能的结果也将作为答案被接受）</p></blockquote><blockquote><p>示例 2：<br>输入：stamp = “abca”, target = “aabcaca”<br>输出：[3,0,1]</p></blockquote><p>提示：</p><ol><li>1 &lt;= stamp.length &lt;= target.length &lt;= 1000</li><li>stamp 和 target 只包含小写字母。</li></ol><p>本身没做出来，看的答案和discuss里的提示才想到这个方法</p><p><b>思路分析：</b><br>假设我们经过若干次操作使得stamp变为target，那么在最后一次操作中，一定使得target某处位置变成了stamp。<br>故条件1：<code>if stamp not in target: return []</code></p><p>我们采取反向还原的方法来判断，例如<code>stamp = &#39;abca&#39;, target = &#39;aabcaca&#39;</code><br>在target中找到一个’abca’，target 变为 <code>a????ca</code></p><p>如何继续找下一个和stamp匹配的字段呢？<br>因为’?’在最后一次会被覆盖，所以?之前是什么我们可以随便定，那么在这里，<code>??ca</code>与’abca’也匹配，’a???’与’abca’也匹配。</p><p>重复进行该操作，直至target被完全还原，或没法还原<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 判断是否匹配</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(self, s, t)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> t[i] == <span class="string">'?'</span>: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> s[i] != t[i]: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movesToStamp</span><span class="params">(self, s, target)</span>:</span></span><br><span class="line">        turn = <span class="number">0</span> <span class="comment"># 匹配轮次，不超过10*len(target)</span></span><br><span class="line">        n, m = len(s), len(target)</span><br><span class="line">        res = []</span><br><span class="line">        compare = <span class="string">'?'</span> * n</span><br><span class="line">        <span class="keyword">while</span> turn &lt; <span class="number">10</span>*m:</span><br><span class="line">            tmp = turn</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(m-n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> target[i:i+n] != compare <span class="keyword">and</span> self.check(s, target[i:i+n]):</span><br><span class="line">                    turn = turn + <span class="number">1</span></span><br><span class="line">                    res.append(i)</span><br><span class="line">                    target = target[:i] + compare + target[i+n:]</span><br><span class="line">            <span class="comment"># 成功还原，反向返回res</span></span><br><span class="line">            <span class="keyword">if</span> target == <span class="string">'?'</span>*m: <span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br><span class="line">            <span class="comment"># 如果一个匹配的都没找到，说明无法还原了，直接break</span></span><br><span class="line">            <span class="keyword">if</span> turn == tmp: <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>leetcode 935 Knight Dialer</title>
      <link href="/2018/11/05/leetcode-935-Knight-Dialer/"/>
      <url>/2018/11/05/leetcode-935-Knight-Dialer/</url>
      <content type="html"><![CDATA[<p>国际象棋中的骑士可以按下图所示进行移动：<br><img src="/images/leetcode_935_1.png" alt=""></p><p>这一次，我们将 “骑士” 放在电话拨号盘的任意数字键（如上图所示）上，接下来，骑士将会跳 N-1 步。每一步必须是从一个数字键跳到另一个数字键。<br>每当它落在一个键上（包括骑士的初始位置），都会拨出键所对应的数字，总共按下 N 位数字。</p><p>你能用这种方式拨出多少个不同的号码？<br>因为答案可能很大，所以输出答案模 10^9 + 7。<br><a id="more"></a></p><p><b>题意分析：</b><br>一个骑士在电话拨号盘上连续行走N次，求总共可能走出多少种不同的电话。</p><p>tips：看到mod 1e9+7，就要想到dp</p><p><b>思路分析：</b><br>我认为这道题当你往dp方面去想的时候，就变得很简单，因为dp定义和递推式都显而易见。<br>定义dp[i][j]表示现在处于i位置，继续走j步所能走出的不同电话数量。<br>那么有<code>dp[i][j] = sum(dp[nex][j-1] for nex in (i能走到的位置) )</code></p><p>使用一个字典<code>d</code>来保存每个位置所能到达的下一个位置。<br>初始化所有的<code>dp[i][0] = 1</code>，因为不能继续走，所以只有1种可能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 996ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">knightDialer</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        d = &#123;<span class="number">0</span>:[<span class="number">4</span>,<span class="number">6</span>],<span class="number">1</span>:[<span class="number">6</span>,<span class="number">8</span>],<span class="number">2</span>:[<span class="number">7</span>,<span class="number">9</span>],<span class="number">3</span>:[<span class="number">4</span>,<span class="number">8</span>],<span class="number">4</span>:[<span class="number">0</span>,<span class="number">3</span>,<span class="number">9</span>],<span class="number">5</span>:[],<span class="number">6</span>:[<span class="number">0</span>,<span class="number">1</span>,<span class="number">7</span>],<span class="number">7</span>:[<span class="number">2</span>,<span class="number">6</span>],<span class="number">8</span>:[<span class="number">1</span>,<span class="number">3</span>],<span class="number">9</span>:[<span class="number">2</span>,<span class="number">4</span>]&#125;</span><br><span class="line">        dp = [[<span class="number">0</span>]*<span class="number">10</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line">        mod = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>): dp[<span class="number">0</span>][i] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">                <span class="keyword">for</span> nex <span class="keyword">in</span> d[j]:</span><br><span class="line">                    dp[i][j] += dp[i<span class="number">-1</span>][nex]</span><br><span class="line">                dp[i][j] %= mod</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum(dp[N<span class="number">-1</span>]) % mod</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dp </tag>
            
            <tag> implementation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 934 Shortest Bridge</title>
      <link href="/2018/11/05/leetcode-934-Shortest-Bridge/"/>
      <url>/2018/11/05/leetcode-934-Shortest-Bridge/</url>
      <content type="html"><![CDATA[<p>在给定的二维二进制数组 A 中，存在两座岛。（岛是由四面相连的 1 形成的一个最大组。）<br>现在，我们可以将 0 变为 1，以使两座岛连接起来，变成一座岛。<br>返回必须翻转的 0 的最小数目。（可以保证答案至少是 1。）<br><a id="more"></a></p><blockquote><p>示例 1：<br>输入：[[0,1],[1,0]]<br>输出：1<br>示例 2：<br>输入：[[0,1,0],[0,0,0],[0,0,1]]<br>输出：2<br>示例 3：<br>输入：[[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]<br>输出：1</p></blockquote><p>提示：</p><ol><li>1 &lt;= A.length = A[0].length &lt;= 100</li><li>A[i][j] == 0 或 A[i][j] == 1</li></ol><p><b>题意分析：</b><br>在一个矩阵中，有两个岛（相连的1组成），找着两座岛的最短距离。</p><p>tips:看到找最短的xx问题，就一定要想到bfs。</p><p><b>思路分析：</b><br>我们从一个岛屿出发，用bfs遍历出所有相邻的矩形，直至和另一个岛屿有重叠的部分。如图：<br><img src="/images/leetcode_934.png" alt=""><br><img src="/images/leetcode_934_1.png" alt=""></p><p>用dfs找出两个岛屿的所在地，用bfs获得最短距离<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 328 ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestBridge</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        n = len(A)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j, land)</span>:</span></span><br><span class="line">           <span class="keyword">for</span> x,y <span class="keyword">in</span> [(i+<span class="number">1</span>,j), (i<span class="number">-1</span>,j), (i,j+<span class="number">1</span>), (i,j<span class="number">-1</span>)]:</span><br><span class="line">               <span class="keyword">if</span> <span class="number">0</span>&lt;=x&lt;n <span class="keyword">and</span> <span class="number">0</span>&lt;=y&lt;n <span class="keyword">and</span> A[x][y] == <span class="number">1</span> <span class="keyword">and</span> (x,y) <span class="keyword">not</span> <span class="keyword">in</span> land:</span><br><span class="line">                   land.add((x,y))</span><br><span class="line">                   dfs(x, y, land)</span><br><span class="line">        <span class="comment"># dfs get two island</span></span><br><span class="line">        land1 = set()</span><br><span class="line">        land2 = set()</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> A[i][j] == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> (i,j) <span class="keyword">not</span> <span class="keyword">in</span> land1:</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">                            land1.add((i,j))</span><br><span class="line">                            dfs(i, j, land1)</span><br><span class="line">                            flag = <span class="number">1</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            land2.add((i,j))</span><br><span class="line">                            dfs(i, j, land2)</span><br><span class="line">        <span class="comment"># bfs get the shortest distance</span></span><br><span class="line">        Q = collections.deque(list(land1))</span><br><span class="line">        level = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> Q:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(Q)):</span><br><span class="line">                i,j = Q.popleft()</span><br><span class="line">                <span class="keyword">if</span> (i,j) <span class="keyword">in</span> land2: <span class="keyword">return</span> level - <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> x,y <span class="keyword">in</span> [(i+<span class="number">1</span>,j), (i<span class="number">-1</span>,j), (i,j+<span class="number">1</span>), (i,j<span class="number">-1</span>)]:</span><br><span class="line">                    <span class="keyword">if</span> <span class="number">0</span> &lt;= x &lt; n <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; n <span class="keyword">and</span> (x,y) <span class="keyword">not</span> <span class="keyword">in</span> land1:</span><br><span class="line">                        land1.add((x,y))</span><br><span class="line">                        Q.append((x,y))</span><br><span class="line">            level += <span class="number">1</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 933 Number of Rencent Calls</title>
      <link href="/2018/11/05/leetcode-933-Number-of-Rencent-Calls/"/>
      <url>/2018/11/05/leetcode-933-Number-of-Rencent-Calls/</url>
      <content type="html"><![CDATA[<p>写一个 RecentCounter 类来计算最近的请求。<br>它只有一个方法：ping(int t)，其中 t 代表以毫秒为单位的某个时间。<br>返回从 3000 毫秒前到现在的 ping 数。</p><p>任何处于 [t - 3000, t] 时间范围之内的 ping 都将会被计算在内，包括当前（指 t 时刻）的 ping。<br>保证每次对 ping 的调用都使用比之前更大的 t 值。</p><a id="more"></a><blockquote><p>示例：<br>输入：inputs = [“RecentCounter”,”ping”,”ping”,”ping”,”ping”], inputs = [[],[1],[100],[3001],[3002]]<br>输出：[null,1,2,3,3]</p></blockquote><p>提示：</p><ol><li>每个测试用例最多调用 10000 次 ping。</li><li>每个测试用例会使用严格递增的 t 值来调用 ping。</li><li>每次调用 ping 都有 1 &lt;= t &lt;= 10^9。</li></ol><p><b>题意分析：</b><br>实现一个方法，使得该方法可以记录最近[t-3000,t]范围之内的数字的个数。</p><p><b>思路分析：</b><br>既然题目保证了每次ping的t值都比之前的要更大，那么我们完全可以用队列来模拟实现整个过程，所求的数量即为队列的长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 168ms, O(n) time, O(n) space</span></span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecentCounter</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.Q = collections.deque()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">(self, t)</span>:</span></span><br><span class="line">        Q = self.Q</span><br><span class="line">        <span class="keyword">while</span> Q <span class="keyword">and</span> Q[<span class="number">0</span>] &lt; t<span class="number">-3000</span>: Q.popleft()</span><br><span class="line">        Q.append(t)</span><br><span class="line">        <span class="keyword">return</span> len(Q)</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> implementation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 18 4Sum</title>
      <link href="/2018/10/31/Leetcode-18-4Sum/"/>
      <url>/2018/10/31/Leetcode-18-4Sum/</url>
      <content type="html"><![CDATA[<p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p><p>注意：<br>答案中不可以包含重复的四元组。<br><a id="more"></a></p><p>示例：<br>给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。<br>满足要求的四元组集合为：<br>[<br>  [-1,  0, 0, 1],<br>  [-2, -1, 1, 2],<br>  [-2,  0, 0, 2]<br>]</p><p><b>题意分析：</b><br>从数组中4个数，使其和为target，找出所有可能</p><p><b>思路分析：</b><br>思路同3Sum，3Sum Closest。如果本身还不知道3Sum的思路可以参考<a href="https://buptwc.github.io/2018/10/20/Leetcode-15-3Sum/" target="_blank" rel="noopener">这篇博客</a></p><p>当然即使你不知道也可以先往下看！<br>首先对数组排序，这是通用的处理方式。<br>在3Sum问题中，我们选择固定住第一个数<code>nums[i]</code>，然后问题就转换成在剩下的数组中找2个数，使其和为<code>target-num[i]</code>，即<code>twoSum()</code>问题<br>而2Sum问题我们可以用双指针法解决！！！</p><p>那么在4Sum问题，我们也可以采用同样的方式，固定住一个数，问题转换成3Sum问题，再固定一个数，问题转换成2Sum问题。然后使用双指针法解决。</p><p>以此类推，如果碰到NSum问题呢，我们就固定N-2个数，然后用双指针法解决。复杂度为O(n^(N-1))</p><p>还是按照惯例，我们先来写twoSum()函数，默认nums有序<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(nums, target)</span>:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        i, j = <span class="number">0</span>, n<span class="number">-1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[j] == target:</span><br><span class="line">                res.append([nums[i], nums[j]])</span><br><span class="line">                i += <span class="number">1</span>; j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i] + nums[j] &lt; target:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 因为要避免重复情况，所以这里要跳过若干数</span></span><br><span class="line">            <span class="keyword">while</span> j &gt; i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]: i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> n<span class="number">-1</span> &gt; j &gt; i <span class="keyword">and</span> nums[j] == nums[j+<span class="number">1</span>]: j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><p>那么，fourSum()函数也可写<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 88ms, beats 81.04%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        i, j = <span class="number">0</span>, n<span class="number">-1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[j] == target:</span><br><span class="line">                res.append([nums[i], nums[j]])</span><br><span class="line">                i += <span class="number">1</span>; j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i] + nums[j] &lt; target:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &gt; i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]: i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> n<span class="number">-1</span> &gt; j &gt; i <span class="keyword">and</span> nums[j] == nums[j+<span class="number">1</span>]: j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        n = len(nums)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-3</span>):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,n<span class="number">-2</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt; i+<span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j<span class="number">-1</span>]: <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># 类似3Sum Closest，当最小都比target大或最大都比target小就跳过</span></span><br><span class="line">                <span class="keyword">if</span> nums[i]+nums[j]+nums[j+<span class="number">1</span>]+nums[j+<span class="number">2</span>] &gt; target: <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> nums[i]+nums[n<span class="number">-3</span>]+nums[n<span class="number">-2</span>]+nums[n<span class="number">-1</span>] &lt; target: <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># 用twoSum得出结果</span></span><br><span class="line">                rec = self.twoSum(nums[j+<span class="number">1</span>:], target-nums[i]-nums[j])</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> rec: <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">for</span> info <span class="keyword">in</span> rec:</span><br><span class="line">                    res.append([nums[i],nums[j]] + info)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
            <tag> two pointers </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 17 Letter Combinations of a Phone Number</title>
      <link href="/2018/10/31/Leetcode-17-Letter-Combinations-of-a-Phone-Number/"/>
      <url>/2018/10/31/Leetcode-17-Letter-Combinations-of-a-Phone-Number/</url>
      <content type="html"><![CDATA[<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。<br>2: abc<br>3: def<br>4: ghi<br>5: jkl<br>6: mno<br>7: pqrs<br>8: tuv<br>9: wxyz</p><a id="more"></a><blockquote><p>示例：<br>输入：”23”<br>输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p></blockquote><p><b>题意分析：</b><br>相当于求一个全排列问题</p><p><b>思路分析：</b><br>这道题是在考你迭代用得怎么样<br>我们来看几种情况：</p><ol><li>假设只有一个数字2： 那么返回 ‘a’,’b’,’c’</li><li>两个数字23: 在第一种的情况下每个都分别加上’d’,’e’,’f’，返回[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</li><li>三个数字234:在第二种的情况下每个都分别加上’g’,’h’,’i’</li></ol><p>明白这个规律这道题就可以做了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 20ms, beats 100%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digit)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digit: <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        d = &#123;<span class="string">'2'</span>: <span class="string">'abc'</span>, <span class="string">'3'</span>: <span class="string">'def'</span>, <span class="string">'4'</span>: <span class="string">'ghi'</span>, <span class="string">'5'</span>: <span class="string">'jkl'</span>, <span class="string">'6'</span>: <span class="string">'mno'</span>, <span class="string">'7'</span>: <span class="string">'pqrs'</span>, <span class="string">'8'</span>: <span class="string">'tuv'</span>, <span class="string">'9'</span>: <span class="string">'wxyz'</span>&#125;</span><br><span class="line">        res = [<span class="string">''</span>]</span><br><span class="line">        rec = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> digit:</span><br><span class="line">            <span class="keyword">for</span> ss <span class="keyword">in</span> d[num]:</span><br><span class="line">                <span class="keyword">for</span> s <span class="keyword">in</span> res:</span><br><span class="line">                    rec.append(s + ss)</span><br><span class="line">            res = rec</span><br><span class="line">            rec = []</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> implementation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 16 3Sum Closest</title>
      <link href="/2018/10/31/Leetcode-16-3Sum-Closest/"/>
      <url>/2018/10/31/Leetcode-16-3Sum-Closest/</url>
      <content type="html"><![CDATA[<p>给定一个包括n个整数的数组nums和一个目标值target。找出nums中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><p>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.<br>与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).<br><a id="more"></a></p><p><b>题意分析：</b><br>3Sum问题的变种，找出3数之和使其离target最近。</p><p><b>思路分析：</b><br>显然，我们仍然可以用3Sum的思路来解决这道题，如果不知道本身3Sum的思路可以看<a href="https://buptwc.github.io/2018/10/20/Leetcode-15-3Sum/" target="_blank" rel="noopener">这篇博客</a></p><p>首先对数组进行排序，固定住第一个数，然后在剩下的有序数组中将问题转换成2Sum Closest<br>那么我们直接解决2Sum Closest问题即可(双指针法)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSumClosest</span><span class="params">(nums,target)</span>:</span></span><br><span class="line">    <span class="comment"># 认为nums此时有序</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    i,j = <span class="number">0</span>,n<span class="number">-1</span></span><br><span class="line">    res = float(<span class="string">'inf'</span>)</span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        dis = nums[i] + nums[j] - target</span><br><span class="line">        <span class="keyword">if</span> abs(dis) &lt; abs(res): res = dis</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[i] + nums[j] == target: <span class="keyword">return</span> target</span><br><span class="line">        <span class="keyword">if</span> nums[i] + nums[j] &lt; target: i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: j -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res + target</span><br></pre></td></tr></table></figure><p>ok，现在来解决3Sum Closest问题，注意处理一些终止条件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 188ms, beats</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSumClosest</span><span class="params">(self, nums,target)</span>:</span></span><br><span class="line">        <span class="comment"># 认为nums此时有序</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        i,j = <span class="number">0</span>,n<span class="number">-1</span></span><br><span class="line">        res = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            dis = nums[i] + nums[j] - target</span><br><span class="line">            <span class="keyword">if</span> abs(dis) &lt; abs(res): res = dis</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[j] == target: <span class="keyword">return</span> target</span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[j] &lt; target: i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res + target</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        n = len(nums)</span><br><span class="line">        res = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>): <span class="comment"># 预留两个数，否则没法双指针</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[i+<span class="number">1</span>] + nums[i+<span class="number">2</span>] &gt; target:</span><br><span class="line">                rec = nums[i] + nums[i+<span class="number">1</span>] + nums[i+<span class="number">2</span>] - target</span><br><span class="line">            <span class="keyword">elif</span> nums[i] + nums[n<span class="number">-2</span>] + nums[n<span class="number">-1</span>] &lt; target:</span><br><span class="line">                rec = nums[i] + nums[n<span class="number">-2</span>] + nums[n<span class="number">-1</span>] - target</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                rec = nums[i] + self.twoSumClosest(nums[i+<span class="number">1</span>:], target-nums[i]) - target</span><br><span class="line">            <span class="keyword">if</span> abs(rec) &lt; abs(res): res = rec</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res + target</span><br></pre></td></tr></table></figure></p><p>或者写到一起，直接在3Sum中用双指针<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 32ms, beats 98.37%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        res = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-2</span>):</span><br><span class="line">            j,k = i+<span class="number">1</span>,len(nums)<span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[j] + nums[j+<span class="number">1</span>] &gt;= target:</span><br><span class="line">                rec = nums[i]+nums[j]+nums[j+<span class="number">1</span>] - target</span><br><span class="line">            <span class="keyword">elif</span> nums[i] + nums[k<span class="number">-1</span>] + nums[k] &lt;= target:</span><br><span class="line">                rec = nums[i]+nums[k<span class="number">-1</span>]+nums[k] - target</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> j &lt; k:</span><br><span class="line">                    rec = (nums[i]+nums[j]+nums[k]-target)</span><br><span class="line">                    <span class="keyword">if</span> abs(rec) &lt; abs(res): res = rec</span><br><span class="line">                    <span class="keyword">if</span> nums[i]+nums[j]+nums[k] &lt; target:</span><br><span class="line">                        j += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> nums[i]+nums[j]+nums[k] &gt; target:</span><br><span class="line">                        k -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>: <span class="keyword">return</span> target</span><br><span class="line">            <span class="keyword">if</span> abs(rec) &lt; abs(res):</span><br><span class="line">                res = rec</span><br><span class="line">        <span class="keyword">return</span> res + target</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
            <tag> two pointers </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 932 Beautiful Array</title>
      <link href="/2018/10/28/Leetcode-932-Beautiful-Array/"/>
      <url>/2018/10/28/Leetcode-932-Beautiful-Array/</url>
      <content type="html"><![CDATA[<p>对于一个确定的N，一个数组A是漂亮的，当前仅当满足以下条件：</p><ol><li>数组是1,2,…,N的一个迭代</li><li>对于任意的i,k,j(i &lt; k &lt; j)，不存在A[k] * 2 = A[i] + A[j].</li></ol><p>现在给定一个N，请你找出一个漂亮的数组A。<br><a id="more"></a></p><blockquote><p>Example 1:<br>Input: 4<br>Output: [2,1,4,3]<br>Example 2:<br>Input: 5<br>Output: [3,1,2,5,4]</p></blockquote><p>Note:</p><ol><li>1 &lt;= N &lt;= 1000</li></ol><p><b>题意分析：</b><br>这道题有点东西奥，找到一个1,2,…,N的某种排列，使得对于任意的A[i],A[k],A<a href="i &lt; k &lt; j">j</a>，都满足A[k] * 2 != A[i] + A[j].</p><p><code>着重写一下我思考这道题时候的思维过程</code></p><p><b>思路分析：</b><br><code>前半部分是我自己的思维过程，虽然是错误的过程，但我想将这整个想法写下来，想直接看正确答案的可以跳到下面标记处</code></p><p>刚看到这道题的时候说实话没什么思路，就在暴力法自己一个一个写，看能不能找到什么规律出来</p><p>对于N=5，有A = [3,1,2,5,4]，那么我就在想，现在加一个6，能加在哪呢？<br>我首先想的是往两边的某个地方加，因为如果可行的话就可以直接dp了</p><p>加在最左边行吗？不行，因为有6,5,4（第一种情况）<br>加在最右边行吗？不行，因为有2,4,6（第二种情况）<br>那加在哪能行呢？要避开刚才的两种情况，只能是在5和4的中间加，[3,1,2,5,6,4]<br>但是这样就没规律了啊，因为有第二种情况的存在，所以6是不能加在4的右边的，又因为第一种情况的存在，6也不能在5的左边。那我手动把5移动一下呢，因为5和左边的数组都不冲突</p><p>我就把数组变成了[3,1,5,2,4],现在6就可以有两种方式往里放：<br>[3,1,5,6,2,4], [3,1,5,2,6,4]</p><p>但这样好像还是很蠢，只是把6能加的位置增多了而已，还是没有什么规律，我在这里为了强行找到某种规律（就是想把6加到边界的地方），我手动把2,4换了一下位置<br>那么有： A = [3,1,5,4,2,6]，诶这样就舒服了！</p><p>那么7能不能加到边界的地方呢，如果又能加在最左边感觉规律就有了啊！<br>发现好像还真可以诶，此时 A = [7,3,1,5,4,2,6]</p><p>要是现在8又能加到最右边就可以证明我想的这个规律是正确的了。<br>但是很可惜并不能，因为[4,6,8]不符合题意，但这时候我发现了另一个规律<br>如果我把8加到4左边，A = [7,3,1,5,8,4,2,6]</p><p><code>正确答案直接从这里看：</code><br>那么此时奇数部分和偶数部分大小顺序的排列是一致的，并且只要其中一个符合题目规律另一个也一定符合。</p><p>我觉得我自己想明白了，就先找偶数部分的排列，然后把奇数的排列按照偶数的顺序加上去就好了<br>此时我分析[8,4,2,6]，想分析10能放在哪，突然发现此时是可以先约分的，反正题目规定的是求和不等嘛，等式两边除2不影响结果。<br>一除之后规律就出来了：<br><code>奇数部分 odd = [7,3,1,5]`</code><br><code>偶数部分(约分) even = [4,2,1,3]</code><br>发现有 <code>odd = even*2 - 1</code>，而even又恰好是n//2的一个排列情况，递归方程式豁然开朗！</p><p><code>f(n) = f(n//2) * 2 + f(n-n//2) * 2 - 1</code><br>因为涉及到重复计算，所以用到了记忆化的思想。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 28ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">beautifulArray</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        cache = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(N)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> N == <span class="number">1</span>: <span class="keyword">return</span> [<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> N <span class="keyword">in</span> cache: <span class="keyword">return</span> cache[N]</span><br><span class="line">            </span><br><span class="line">            even_index = N // <span class="number">2</span></span><br><span class="line">            odd_index = N - even_index</span><br><span class="line">            even = solve(even_index)</span><br><span class="line">            odd = solve(odd_index)</span><br><span class="line">            even = [<span class="number">2</span>*val <span class="keyword">for</span> val <span class="keyword">in</span> even]</span><br><span class="line">            odd = [<span class="number">2</span>*val<span class="number">-1</span> <span class="keyword">for</span> val <span class="keyword">in</span> odd]</span><br><span class="line">            cache[N] = even + odd</span><br><span class="line">            <span class="keyword">return</span> cache[N]</span><br><span class="line">        <span class="keyword">return</span> solve(N)</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 931 Minimum Falling Path Sum</title>
      <link href="/2018/10/28/Leetcode-931-Minimum-Falling-Path-Sum/"/>
      <url>/2018/10/28/Leetcode-931-Minimum-Falling-Path-Sum/</url>
      <content type="html"><![CDATA[<p>给定一个正方形矩阵A，求A中的最小下坠路径和！<br>一个下坠路径是指从第一行的任意一个位置开始，依次往下一行走，但相邻两行的列之差必须小于等于1！</p><a id="more"></a><blockquote><p>Example 1:<br>Input: [[1,2,3],[4,5,6],[7,8,9]]<br>Output: 12<br>Explanation:<br>The possible falling paths are:<br>[1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9]<br>[2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9]<br>[3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]<br>The falling path with the smallest sum is [1,4,7], so the answer is 12.</p></blockquote><p>Note:</p><ol><li>1 &lt;= A.length == A[0].length &lt;= 100</li><li>-100 &lt;= A[i][j] &lt;= 100</li></ol><p><b>题意分析：</b><br>典型的dp问题，leetcode之前有一道差不多的，那道题里面是说的树，这里是矩阵，差不多一个意思！</p><p><b>思路分析：</b><br>我们从下至上分析，定义dp[i][j]表示从(i,j)这个点出发，达到最底层的最小代价。<br>显然，我们所求的答案就是min(dp[0])。<br>那么有<code>dp[i][j] = A[i][j] + min(dp[i+1][j-1],dp[i+1][j], dp[i+1][j+1])</code></p><p>初始化最后一行，<code>dp[n-1] = A[n-1]</code>！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 36ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minFallingPathSum</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        n = len(A)</span><br><span class="line">        dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            dp[n<span class="number">-1</span>][j] = A[n<span class="number">-1</span>][j]</span><br><span class="line">        <span class="comment"># 懒得用技巧缩短代码了，这种测试直接写才是最快的</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = A[i][j] + min(dp[i+<span class="number">1</span>][j], dp[i+<span class="number">1</span>][j+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">elif</span> j == n<span class="number">-1</span>:</span><br><span class="line">                    dp[i][j] = A[i][j] + min(dp[i+<span class="number">1</span>][j<span class="number">-1</span>], dp[i+<span class="number">1</span>][j])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = A[i][j] + min(dp[i+<span class="number">1</span>][j<span class="number">-1</span>], dp[i+<span class="number">1</span>][j], dp[i+<span class="number">1</span>][j+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> min(dp[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 930 Binary Subarrays With Sum</title>
      <link href="/2018/10/28/Leetcode-930-Binary-Subarrays-With-Sum/"/>
      <url>/2018/10/28/Leetcode-930-Binary-Subarrays-With-Sum/</url>
      <content type="html"><![CDATA[<p>给定一个只含0,1的数组，问数组中有多少个子串和恰好为S。</p><a id="more"></a><blockquote><p>Example 1:<br>Input: A = [1,0,1,0,1], S = 2<br>Output: 4<br>Explanation:<br>The 4 subarrays are bolded below:<br>[1,0,1]<br>[1,0,1,0]<br>[0,1,0,1]<br>[1,0,1]</p></blockquote><p>Note:</p><ol><li>A.length &lt;= 30000</li><li>0 &lt;= S &lt;= A.length</li><li>A[i] is either 0 or 1.</li></ol><p><b>题意分析：</b><br>求数组中的连续子串，使其和恰好为S。<br>问这样的连续子串一共有多少个？</p><p><b>思路分析：</b><br>这和我之前做过的一道腾讯笔试题一模一样，链接如下，第一题(包含k个1的子串)：<br><a href="https://buptwc.github.io/2018/10/15/2018-10-14-%E8%85%BE%E8%AE%AF%E7%AC%94%E8%AF%95/" target="_blank" rel="noopener">腾讯笔试</a></p><p>关键就是在于记录数组中1的下标，<br>例如对于<code>A = &#39;001010011&#39;,S = 2</code>，使用Index存储所有1的下标，那么有<br>index = [2,4,7,8]<br>假设我们选中前两个1(index1=2,index2=4)，这两个’1’一共能组成3*3=9种</p><p>3是怎么来的呢？是观察能向两边扩展多少个’0’。<br>第一个’1’左边有两个’0’，那么可以选择扩展(0个，1个，2个)，共三种情况<br>第二个’1’右边有两个’0’，同理，所以最后是3*3 = 9</p><p>中间<code>0</code>的个数是通过1的下标相减得到！<br>为了处理边界情况，我们给index前后各加一个边界(-1,n)</p><p><code>单独处理一下S = 0的情况，因为这种情况下选不了1</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 60ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSubarraysWithSum</span><span class="params">(self, A, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :type S: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        index = [<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            <span class="keyword">if</span> A[i] == <span class="number">1</span>: index.append(i)</span><br><span class="line">        index.append(len(A))</span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> S == <span class="number">0</span>: <span class="comment"># 单独处理S = 0的情况</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(index)):</span><br><span class="line">                num = index[i] - index[i<span class="number">-1</span>] - <span class="number">1</span></span><br><span class="line">                res += (num+<span class="number">1</span>)*num // <span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="comment"># 从index = 1开始遍历</span></span><br><span class="line">        i,j = <span class="number">1</span>,<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(index)<span class="number">-1</span>:</span><br><span class="line">            j = i + S</span><br><span class="line">            <span class="keyword">if</span> j &gt;= len(index): <span class="keyword">break</span></span><br><span class="line">            res += (index[i]-index[i<span class="number">-1</span>]) * (index[j]-index[j<span class="number">-1</span>])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
            <tag> implementation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 929 Unique Email Addresses</title>
      <link href="/2018/10/28/Leetcode-929-Unique-Email-Addresses/"/>
      <url>/2018/10/28/Leetcode-929-Unique-Email-Addresses/</url>
      <content type="html"><![CDATA[<p>Every email consists of a local name and a domain name, separated by the @ sign.<br>For example, in <a href="mailto:alice@leetcode.com" target="_blank" rel="noopener">alice@leetcode.com</a>, alice is the local name, and leetcode.com is the domain name.<br>Besides lowercase letters, these emails may contain ‘.’s or ‘+’s.</p><p>If you add periods (‘.’) between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name.  For example, “<a href="mailto:alice.z@leetcode.com" target="_blank" rel="noopener">alice.z@leetcode.com</a>“ and “<a href="mailto:alicez@leetcode.com" target="_blank" rel="noopener">alicez@leetcode.com</a>“ forward to the same email address.  (Note that this rule does not apply for domain names.)</p><p>If you add a plus (‘+’) in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered, for example <a href="mailto:m.y+name@email.com" target="_blank" rel="noopener">m.y+name@email.com</a> will be forwarded to <a href="mailto:my@email.com" target="_blank" rel="noopener">my@email.com</a>.  (Again, this rule does not apply for domain names.)</p><p>It is possible to use both of these rules at the same time.<br>Given a list of emails, we send one email to each address in the list.  How many different addresses actually receive mails? </p><a id="more"></a><p>Example 1:<br>Input: [“<a href="mailto:test.email+alex@leetcode.com" target="_blank" rel="noopener">test.email+alex@leetcode.com</a>“,”<a href="mailto:test.e.mail+bob.cathy@leetcode.com" target="_blank" rel="noopener">test.e.mail+bob.cathy@leetcode.com</a>“,”<a href="mailto:testemail+david@lee.tcode.com" target="_blank" rel="noopener">testemail+david@lee.tcode.com</a>“]<br>Output: 2<br>Explanation: “<a href="mailto:testemail@leetcode.com" target="_blank" rel="noopener">testemail@leetcode.com</a>“ and “<a href="mailto:testemail@lee.tcode.com" target="_blank" rel="noopener">testemail@lee.tcode.com</a>“ actually receive mails</p><p>Note:</p><ol><li>1 &lt;= emails[i].length &lt;= 100</li><li>1 &lt;= emails.length &lt;= 100</li><li>Each emails[i] contains exactly one ‘@’ character.</li></ol><p><b>题意分析：</b><br>给定一系列的邮件地址，邮件地址可以按照一定的规则进行转换，问经过转换后列表中有多少不同邮件地址。</p><p><b>思路分析：</b><br>一道简单的应用题，note中确保了每个邮件地址中只有一个‘@’符号，那么我们用‘@’符号将整个地址分为前半部分和后半部分。</p><p>对于后半部分，本身是什么就是什么，我们不做改变<br>对于前半部分，舍去<code>&#39;+&#39;</code>后后面的所有部分，这也可以使用split()函数做到<br>然后把前半部分中的<code>&#39;.&#39;</code>替换成<code>&#39;&#39;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 36ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numUniqueEmails</span><span class="params">(self, emails)</span>:</span></span><br><span class="line">        d = collections.defaultdict(int)</span><br><span class="line">        <span class="keyword">for</span> ss <span class="keyword">in</span> emails:</span><br><span class="line">            local, domain = ss.split(<span class="string">'@'</span>)</span><br><span class="line">            local = local.split(<span class="string">'+'</span>)[<span class="number">0</span>]</span><br><span class="line">            local = local.replace(<span class="string">'.'</span>, <span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">            d[local+domain] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> len(d)</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> implementation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 84 Largest Rectangle in Histogram</title>
      <link href="/2018/10/24/Leetcode-84-Largest-Rectangle-in-Histogram/"/>
      <url>/2018/10/24/Leetcode-84-Largest-Rectangle-in-Histogram/</url>
      <content type="html"><![CDATA[<p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。<br>求在该柱状图中，能够勾勒出来的矩形的最大面积。<br><img src="/images/leetcode_84.png" alt=""><br>左边是是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。<br>右边图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。<br><a id="more"></a><br>示例:<br>输入: [2,1,5,6,2,3]<br>输出: 10</p><p><b>题意分析：</b><br>在图中找一块矩形，使其最大，并求最大的矩形面积</p><p><b>思路分析：</b><br>我们发现一个矩形能取多大的面积取决于边的高度，以及底边的长度<br>当边的高度选得越高，如题目图中选到了5，那么底部的长度自然会越小，因为并不是每一个小矩形的高度都达到了5</p><p>我们可以发现，当我们确定了矩形的高度之后，是有办法确定底边的长度的<br>即向两边扩展，直至找到第一个高度比自己低的矩形</p><p>例如示例中，我们选取2(index=4)作为高度，那么底边向左延伸可以到1(index1=1)，向右延伸可以到最右边(默认index2 = n,n为数组长度)<br>那么底边的长度即为<code>index2-index1-1 = 6-1-1 = 4</code>，能构成的面积为<code>2*4=8</code>。其余依此类推。</p><p>所以关键就在于对于一个<code>index = i</code>，如何去找到其左右两边第一个比<code>nums[i]</code>小的下标<br>这个步骤可以通过栈来完成，具体代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 60ms, beats 25.71%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="comment"># left[i] record the index of first num which smaller than nums[i] before i</span></span><br><span class="line">        <span class="comment"># right[i] record the index of first num which smaller than nums[i] after i</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        stack = []</span><br><span class="line">        left = [<span class="number">-1</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> nums[stack[<span class="number">-1</span>]] &gt;= nums[i]:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">if</span> stack:</span><br><span class="line">                left[i] = stack[<span class="number">-1</span>]</span><br><span class="line">            stack.append(i)</span><br><span class="line"></span><br><span class="line">        stack = []</span><br><span class="line">        right = [n] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> nums[stack[<span class="number">-1</span>]] &gt;= nums[i]:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">if</span> stack:</span><br><span class="line">                right[i] = stack[<span class="number">-1</span>]</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="comment"># 对每一个小矩形都判断一次，找最大面积</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            res = max(nums[i]*(right[i]-left[i]<span class="number">-1</span>), res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 71 Simplify Path</title>
      <link href="/2018/10/23/Leetcode-71-Simplify-Path/"/>
      <url>/2018/10/23/Leetcode-71-Simplify-Path/</url>
      <content type="html"><![CDATA[<p>给定一个文档 (Unix-style) 的完全路径，请进行路径简化。<br>例如，<br>path = “/home/“, =&gt; “/home”<br>path = “/a/./b/../../c/“, =&gt; “/c”<br><a id="more"></a></p><p>边界情况:<br>你是否考虑了 路径 = “/../“ 的情况？<br>在这种情况下，你需返回 “/“ 。<br>此外，路径中也可能包含多个斜杠 ‘/‘ ，如 “/home//foo/“ 。<br>在这种情况下，你可忽略多余的斜杠，返回 “/home/foo” 。</p><p><b>题意分析：</b><br>这道题对于不太熟悉linux命令行的人来说可能有点不太友好。<br>其实就是相当于问你键入这么长一串命令，最后在哪个文件夹</p><p><b>思路分析：</b><br>我们知道键入<code>&#39;.&#39;</code>无变化，可以忽略，键入<code>&#39;..&#39;</code>则是回到上一个文件夹，其余合法操作都对文件路径本身无影响。</p><p>而这种需要将最近输入的元素删除的操作，很容易想到是通过栈来完成。<br>我们可以将<code>path</code>按照<code>/</code>分割开来，那么每一部分可能是：</p><ol><li><code>&#39;&#39;</code>，为空</li><li><code>&#39;name&#39;</code>，文件名</li><li><code>&#39;.&#39;</code>，无影响</li><li><code>&#39;..&#39;</code>，回到上一个文件夹</li></ol><p>总共可能如上，代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 32ms, beats 52.31%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">simplifyPath</span><span class="params">(self, path)</span>:</span></span><br><span class="line">        L = path.split(<span class="string">'/'</span>)</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> elem <span class="keyword">in</span> L:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> elem <span class="keyword">or</span> elem == <span class="string">'.'</span>: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> elem == <span class="string">'..'</span>:</span><br><span class="line">                <span class="keyword">if</span> stack:</span><br><span class="line">                    stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(<span class="string">'/'</span> + elem)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> stack: <span class="keyword">return</span> <span class="string">'/'</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(stack)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 928 Minimize Malware Spread II</title>
      <link href="/2018/10/21/Leetcode-928-Minimize-Malware-Spread-II/"/>
      <url>/2018/10/21/Leetcode-928-Minimize-Malware-Spread-II/</url>
      <content type="html"><![CDATA[<p>(这个问题与 尽量减少恶意软件的传播 是一样的，不同之处用粗体表示。)<br>在节点网络中，只有当 graph[i][j] = 1 时，每个节点 i 能够直接连接到另一个节点 j。<br>一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。</p><p>假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。<br>我们可以从初始列表中删除一个节点，并完全移除该节点以及从该节点到任何其他节点的任何连接。如果移除这一节点将最小化 M(initial)， 则返回该节点。如果有多个节点满足条件，就返回索引最小的节点。<br><a id="more"></a></p><blockquote><p>示例 1：<br>输出：graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]<br>输入：0</p></blockquote><blockquote><p>示例 2：<br>输入：graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]<br>输出：1</p></blockquote><blockquote><p>示例 3：<br>输入：graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]<br>输出：1</p></blockquote><p>提示：</p><ol><li>1 &lt; graph.length = graph[0].length &lt;= 300</li><li>0 &lt;= graph[i][j] == graph[j][i] &lt;= 1</li><li>graph[i][i] = 1</li><li>1 &lt;= initial.length &lt; graph.length</li><li>0 &lt;= initial[i] &lt; graph.length</li></ol><p><b>题意分析：</b><br>在图中删除某个结点，使最后受到感染的节点数最小。</p><p><b>思路分析：</b><br>这道题和上一道题在思路上有那么一丝丝相同。上一道题的解法在<br><a href="https://buptwc.github.io/2018/10/15/Leetcode-924-Minimize-Malware-Spread/" target="_blank" rel="noopener">https://buptwc.github.io/2018/10/15/Leetcode-924-Minimize-Malware-Spread/</a></p><p>这道题关键点在于想到，要想把一个点从本来要被感染的状态变成不被感染，那么需要把能把它感染的结点全部删除！！！</p><p>如果一个结点能够被两个或更多感染结点从不同的路径感染，那么这个结点是不可能安全的。如下图所示，其中黄色结点是初始被感染结点：<br><img src="/images/leetcode_928.png" alt=""></p><p>对于<code>1</code>结点来说，0,4能从不同的路径将其感染，即使删除一个，另一个也会将其感染。<br>对于<code>6</code>节点来说，虽然0,4也能将其感染，但是是从相同路径（要经过4），也就是如果我们删除4,即可避免6被感染！</p><p>所以我们要找的就是那些只会被一个结点感染的点（如图中的6），然后存储那个唯一可以感染他的结点，我们采用bfs来完成。如果在bfs过程中遍历到<code>其他被感染结点</code>则不再遍历下去。</p><p>最后我们统计存储的结点中哪个结点出现得最多即可，如果都是0则输出index最小的结点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 492ms</span></span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minMalwareSpread</span><span class="params">(self, graph, initial)</span>:</span></span><br><span class="line">        n = len(graph)</span><br><span class="line">        d = collections.defaultdict(list)</span><br><span class="line">        <span class="comment"># 对每个初始感染节点依次bfs，因为节点总数不超过300，所以不会超时</span></span><br><span class="line">        <span class="keyword">for</span> init <span class="keyword">in</span> initial:</span><br><span class="line">            vis = set(initial)</span><br><span class="line">            Q = collections.deque([init])</span><br><span class="line">            <span class="keyword">while</span> Q:</span><br><span class="line">                infect = Q.popleft()</span><br><span class="line">                <span class="keyword">for</span> node <span class="keyword">in</span> range(len(graph[infect])):</span><br><span class="line">                    <span class="keyword">if</span> graph[infect][node] == <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> node <span class="keyword">in</span> vis: <span class="keyword">continue</span></span><br><span class="line">                    vis.add(node)</span><br><span class="line">                    d[node].append(init)</span><br><span class="line">                    Q.append(node)</span><br><span class="line">        <span class="comment"># 统计出现最多次的感染节点</span></span><br><span class="line">        res = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> d:</span><br><span class="line">            <span class="keyword">if</span> len(d[key]) == <span class="number">1</span>:</span><br><span class="line">                res[d[key][<span class="number">0</span>]] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> max(res) == <span class="number">0</span>: <span class="keyword">return</span> min(initial)</span><br><span class="line">        <span class="keyword">return</span> res.index(max(res))</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 927 Three Equal Parts</title>
      <link href="/2018/10/21/Leetcode-927-Three-Equal-Parts/"/>
      <url>/2018/10/21/Leetcode-927-Three-Equal-Parts/</url>
      <content type="html"><![CDATA[<p>给定只包含’0’,’1’的数组A，将数组A划分成3个部分，每个部分代表一个二进制数，你需要找到一组i,j（i+1 &lt; j）使得划分的3部分所代表的二进制数的值相等。<br>其中：<br><b>A[0],A[1],…,A[i]是第一部分</b><br><b>A[i+1],…,A[j-1] 是第二部分</b><br><b>A[j],A[j+1],…,A[A.length-1]是第三部分</b></p><p>如果找不到划分方法，返回[-1,-1]<br><a id="more"></a><br>注意：<br>例如划分出[1,1,0]这个数组，他代表的值是6而不是3。<br>允许前导0的存在，例如[0,1,1]和[1,1]都可以代表3。</p><blockquote><p>Example 1:<br>Input: [1,0,1,0,1]<br>Output: [0,3]</p></blockquote><blockquote><p>Example 2:<br>Input: [1,1,0,1,1]<br>Output: [-1,-1]</p></blockquote><p>Note:</p><ol><li>3 &lt;= A.length &lt;= 30000</li><li>A[i] == 0 or A[i] == 1</li></ol><p><b>题意分析：</b><br>将数组划分成三个部分，使三个部分所代表的二进制值相同。<br>注意到A的长度达到3w，所以考虑复杂度的时候一定需要考虑清楚。</p><p><b>思路分析：</b><br>在这里我讲一下我看到这道题的时候思路过程是怎样的。</p><p>我首先想的是从第一部分和第三部分下手，因为这两个部分靠近边界，很容易可以计算出所代表的数值。我想使用left[i]表示A[:i]对应的数，right[i]表示A[i:]对应的数，然后依次找到i,j使得left[i] == right[j]，最后再判断中间的数是不是也相等。</p><p>乍一想，好像还真行诶，因为是O(n) time, O(n) space嘛。当然稍微再分析一下就会发现这是有问题的。第一个问题在于A的长度实在太大，能表示的二进制数的大小是巨大无比的，我根本没法存下来；第二个问题在于，由于A中必定存在着大量的’0’，使得很多left[i]的值与right[j]的值相同，但中间的数的大小是会发生改变的，这样会有大量计算，我估计会超时！</p><p>那么这两个问题要怎么解决呢？<br>我们不妨就将划分成的三部分分别定义为a,b,c吧，如何判断a==b==c呢？上面说了转成十进制数来判断是行不通的，所以我们直接比较数组本身是不是相同，但是这又衍生出一个问题————因为有前缀0的存在，所以每次比较都要先消除前缀0，这个比较的开销感觉挺大的，所以我采取的方式是记录的时候就只记录<code>出现了第一个1</code>之后的部分，例如[0,0,0,1,1]就只记录[1,1]，这样开销就减小很多了。下文中所提到的a,b,c数组默认都是以1开头的。</p><p>根据我们记录数组的方式(以1开头)，那么我们顺势可以确定b,c长度。为何这样说呢？<br>我们知道，二进制数中(1开头)如果长度就不相等的话最后表达的值也不可能相等。所以例如我们确定了数组a的长度为<code>l</code>，<br>那么b数组和c数组的长度也一定是<code>l</code>。如果长度都不满足，那么根本无需比较！</p><p>我们来看一个例子 A = [1,0,1,0,1,0]<br>我们首先选取a = [1]代表第一部分，那么第一部分的长度就为1；所以第二部分的长度也只能是1，则b = [1]（实际为[0,1]，我们只记录[1]），那么c的长度则是剩余的数组长度 [1,0]，长度为2，故不符合！</p><p>OK，在代码中我们使用right数组来记录<code>下一个</code>‘1’出现的位置，使用left数组记录左边<code>第一个</code>‘1’出现的位置。</p><p>当我们选取第i个位置作为第一部分的结尾，则有：<br>第一部分的开头在<code>left[i]</code>, 结尾在<code>i</code>， 长度为<code>l = (i-left[i]+1)</code><br>第二部分的开头在<code>right[i]</code>，结尾在<code>end = right[i] + l</code>， 满足长度相同<br>第三部分的开头在<code>end+1</code>,结尾在<code>end+1 + l</code>, 满足长度相同</p><p>如果第三部分的结尾不等于len(A)，则跳过不处理！！！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 120ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeEqualParts</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="comment"># 考虑到没有1的情况</span></span><br><span class="line">        <span class="keyword">if</span> A.count(<span class="number">1</span>) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>,len(A)<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># 只要有1个1，那么逻辑就成立。</span></span><br><span class="line">        n = len(A)</span><br><span class="line">        <span class="comment"># right,left数组含义如上所述</span></span><br><span class="line">        right = [<span class="number">-1</span>] * n</span><br><span class="line">        index = n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            right[i] = index</span><br><span class="line">            <span class="keyword">if</span> A[i] == <span class="number">1</span>: index = i</span><br><span class="line"></span><br><span class="line">        left = [<span class="number">-1</span>] * n</span><br><span class="line">        index = A.index(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> i &gt;= index: left[i] = index</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>):</span><br><span class="line">            f_start = left[i]</span><br><span class="line">            <span class="comment"># 左边还没有1的话则表示第一部分的值为0</span></span><br><span class="line">            <span class="comment"># 三部分的值都为0的情况在程序开头已经处理了</span></span><br><span class="line">            <span class="keyword">if</span> f_start == <span class="number">-1</span>: <span class="keyword">continue</span></span><br><span class="line">            l = i - f_start + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 第二部分如果就超过了数组长度就没有第三部分了</span></span><br><span class="line">            s_start = right[i]</span><br><span class="line">            s_end = s_start + l - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s_end &gt;= n: <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            t_start = right[s_end]</span><br><span class="line">            <span class="keyword">if</span> t_start &gt;= n: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> n - t_start != l: <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 满足上述所有条件后，再进行比较</span></span><br><span class="line">            <span class="keyword">if</span> A[f_start:i+<span class="number">1</span>] == A[s_start:s_end+<span class="number">1</span>] == A[t_start:n]:</span><br><span class="line">                <span class="keyword">return</span> [i, s_end + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> implementation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 926 Flip String to Monotone Increasing</title>
      <link href="/2018/10/21/Leetcode-926-Flip-String-to-Monotone-Increasing/"/>
      <url>/2018/10/21/Leetcode-926-Flip-String-to-Monotone-Increasing/</url>
      <content type="html"><![CDATA[<p>如果一个由 ‘0’ 和 ‘1’ 组成的字符串，是以一些 ‘0’（可能没有 ‘0’）后面跟着一些 ‘1’（也可能没有 ‘1’）的形式组成的，那么该字符串是单调递增的。</p><p>我们给出一个由字符 ‘0’ 和 ‘1’ 组成的字符串 S，我们可以将任何 ‘0’ 翻转为 ‘1’ 或者将 ‘1’ 翻转为 ‘0’。</p><p>返回使 S 单调递增的最小翻转次数。<br><a id="more"></a></p><blockquote><p>示例 1：<br>输入：”00110”<br>输出：1<br>解释：我们翻转最后一位得到 00111.</p></blockquote><blockquote><p>示例 2：<br>输入：”010110”<br>输出：2<br>解释：我们翻转得到 011111，或者是 000111。</p></blockquote><blockquote><p>示例 3：<br>输入：”00011000”<br>输出：2<br>解释：我们翻转得到 00000000。</p></blockquote><p>提示：</p><ol><li>1 &lt;= S.length &lt;= 20000</li><li>S 中只包含字符 ‘0’ 和 ‘1’</li></ol><p><b>题意分析：</b><br>将给定的字符串s中的某些字符翻转，使其变成一个以若干个0开头，紧接着若干个1结尾的字符串。<br>问最小的翻转次数</p><p><b>思路分析：</b><br>假设经过最优解的翻转使其变成了 <code>s = &#39;0&#39;*i + &#39;1&#39;*j</code><br>其实我们要决定的是在原字符串中选择哪一个位置的’1’，使其作为最优解中的第一个’1’！</p><p>例如对于示例2中的<code>010110</code>，假设我们选择<code>index=1</code>处的’1’作为开头的’1’，那么我们需要将后面所有的’0’全部翻转成’1’，翻转次数取决于后面’0’的个数。</p><p>又假设我们选取<code>index=3</code>处的’1’作为开头的’1’，那么我们需要将<code>前面所有的&#39;1&#39;翻转成0</code>，将<code>后面所有的&#39;0&#39;翻转成&#39;1&#39;</code>，翻转次数取决于前面’1’的个数和后面’0’的个数。</p><p>OK，那我们只要一直记录着当前位置的前面有多少个1，后面有多少个0即可！<br>注意：可能存在最后全为0的情况（如示例3），那么我们是选不到某个’1’作为开头的，所以我们先将全部翻转成’0’所花费的次数作为初始默认次数，然后和我们每次计算的结果比较即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 68ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minFlipsMonoIncr</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        cnt0 = s.count(<span class="string">'0'</span>)</span><br><span class="line">        cnt1 = <span class="number">0</span></span><br><span class="line">        res = n - cnt0</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">'0'</span>: </span><br><span class="line">                cnt0 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i] == <span class="string">'1'</span>:</span><br><span class="line">                res = min(res, cnt1+cnt0)</span><br><span class="line">                cnt1 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> implementation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 925 Long Pressed Name</title>
      <link href="/2018/10/21/Leetcode-925-Long-Pressed-Name/"/>
      <url>/2018/10/21/Leetcode-925-Long-Pressed-Name/</url>
      <content type="html"><![CDATA[<p>你的朋友正在使用键盘输入他的名字name。偶尔，在键入字符c时，按键可能会被长按，而字符可能被输入 1 次或多次。<br>你将会检查键盘输入的字符typed。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。<br><a id="more"></a></p><blockquote><p>示例 1：<br>输入：name = “alex”, typed = “aaleex”<br>输出：true<br>解释：’alex’ 中的 ‘a’ 和 ‘e’ 被长按。</p></blockquote><blockquote><p>示例 2：<br>输入：name = “saeed”, typed = “ssaaedd”<br>输出：false<br>解释：’e’ 一定需要被键入两次，但在 typed 的输出中不是这样。</p></blockquote><blockquote><p>示例 3：<br>输入：name = “leelee”, typed = “lleeelee”<br>输出：true</p></blockquote><blockquote><p>示例 4：<br>输入：name = “laiden”, typed = “laiden”<br>输出：true<br>解释：并不一定会长按某个键。</p></blockquote><p>提示：</p><ol><li>name.length &lt;= 1000</li><li>typed.length &lt;= 1000</li><li>name 和 typed 的字符都是小写字母。</li></ol><p><b>题意分析：</b><br>对于第一个字符串，使其中的某些字符连续出现多次，问第二个字符串是不是满足其中的一种可能。</p><p><b>思路分析：</b><br>这道题看似很简单，直接双指针依次判断就好，但我总感觉应该还会有更简单的方法。</p><p>使用i,j分别指向name和type，如果指向的字符<code>不相等</code>则直接返回False</p><p>若相等，则考虑到多次键入的可能性，只要<code>name[i] == name[i+1] or typed[j] == type[j+1]</code>，i,j就继续向右移动。但这里要注意一个点，那就是<code>i移动的距离</code>一定要小于等于<code>j移动的距离</code>，否则就会像示例2中一样返回False.</p><p>最后，两个指针应当同时走到字符串的末尾，否则说明还有字符不匹配，则返回False</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 24ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isLongPressedName</span><span class="params">(self, name, typed)</span>:</span></span><br><span class="line">        n,m = len(name), len(typed)</span><br><span class="line">        i = j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> j &lt; m:</span><br><span class="line">            <span class="keyword">if</span> name[i] != typed[j]: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            cnt_i, cnt_j = i, j</span><br><span class="line">            i += <span class="number">1</span>; j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> name[i] == name[i<span class="number">-1</span>]: i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; m <span class="keyword">and</span> typed[j] == typed[j<span class="number">-1</span>]: j += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 判断i移动的距离和j移动的距离</span></span><br><span class="line">            <span class="keyword">if</span> i - cnt_i &gt; j - cnt_j: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="comment"># 是否匹配结束</span></span><br><span class="line">        <span class="keyword">if</span> i == n <span class="keyword">and</span> j == m: <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 15 3Sum</title>
      <link href="/2018/10/20/Leetcode-15-3Sum/"/>
      <url>/2018/10/20/Leetcode-15-3Sum/</url>
      <content type="html"><![CDATA[<p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。<br><a id="more"></a><br>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，<br>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p><p><b>题意分析：</b><br>在数组找三个数，使三个数的和为0，关键在于答案中不能包含重复三元组！</p><p><b>思路分析：</b><br>碰到3Sum问题，我们一般倾向于把他变成一个2Sum问题。<br>我们首先将数组排序，然后固定住第一个数，在剩下的数组中使用双指针法来寻找剩下两个数。</p><p>那如何去重呢？<br>对于我们固定的第一个数来说，例如[-1, -1, 0, 1, 2]<br>第一个-1能组成的三元组，完全包含住了第二个-1可能组成的三元组。所以可以将第二个-1跳过。</p><p>对于双指针法找到的两个数j,k，一旦成功找到一组(j,k)那么和(j,k)相等的数全部可以跳过。</p><p><b>优化：</b><br>因为数组排序后是从小到大的，如果第一个数就大于0了，那已经不可能存在和为0的情况了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 584ms, beats 86.61%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-2</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]: <span class="keyword">continue</span></span><br><span class="line">            j,k = i+<span class="number">1</span>,len(nums)<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; k:</span><br><span class="line">                <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[i]+nums[j]+nums[k] &lt; <span class="number">0</span>:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[i]+nums[j]+nums[k] &gt; <span class="number">0</span>:</span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> j == k: <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> nums[i]+nums[j]+nums[k] == <span class="number">0</span>:</span><br><span class="line">                    res.append([nums[i],nums[j],nums[k]])</span><br><span class="line">                    <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[j] == nums[j+<span class="number">1</span>]:</span><br><span class="line">                        j += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[k] == nums[k<span class="number">-1</span>]:</span><br><span class="line">                        k -= <span class="number">1</span></span><br><span class="line">                    j += <span class="number">1</span>; k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
            <tag> two pointers </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 14 Longest Common Prefix</title>
      <link href="/2018/10/20/Leetcode-14-Longest-Common-Prefix/"/>
      <url>/2018/10/20/Leetcode-14-Longest-Common-Prefix/</url>
      <content type="html"><![CDATA[<p>编写一个函数来查找字符串数组中的最长公共前缀。<br>如果不存在公共前缀，返回空字符串 “”。</p><a id="more"></a><blockquote><p>示例 1:<br>输入: [“flower”,”flow”,”flight”]<br>输出: “fl”</p></blockquote><blockquote><p>示例 2:<br>输入: [“dog”,”racecar”,”car”]<br>输出: “”<br>解释: 输入不存在公共前缀。</p></blockquote><p>说明:<br>所有输入只包含小写字母 a-z 。</p><p><b>题意分析：</b><br>需要找到一个最长的字符串，使得这个字符串是数组中所有字符的公共前缀。</p><p><b>思路分析：</b><br>如果你是看我题解比较多的人，应该看到我题意分析中的语句可能就已经懂了这道题要怎么做了。<br><code>找一个数，使这个数满足某种条件</code>，符合这种描述的题型，极有可能是二分法。</p><p>这道题也不例外，因为前缀最长也只能是数组中最短的字符串<code>ss</code>的长度，我们只需要判断到底要在<code>ss</code>中选择多长的前缀即可。</p><p>对于我们每次选择的长度，我们判断其到底是不是数组中每个字符的前缀，如果是，说明最后的结果长度可能更长；反之，说明结果长度不够。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 24ms, beats 88.14%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        ss = min(s, key=len)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isPre</span><span class="params">(s,ss,mid)</span>:</span></span><br><span class="line">            pre = ss[:mid]</span><br><span class="line">            <span class="keyword">if</span> all(e.startswith(pre) <span class="keyword">for</span> e <span class="keyword">in</span> s): <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        l,r = <span class="number">0</span>,len(ss)</span><br><span class="line">        <span class="keyword">while</span> l &lt; r<span class="number">-1</span>:</span><br><span class="line">            mid = (l+r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> isPre(s,ss,mid):</span><br><span class="line">                l = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid<span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> isPre(s,ss,r): <span class="keyword">return</span> ss[:r]</span><br><span class="line">        <span class="keyword">return</span> ss[:l]</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> binary search </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 13 Roman to Integer</title>
      <link href="/2018/10/20/Leetcode-13-Roman-to-Integer/"/>
      <url>/2018/10/20/Leetcode-13-Roman-to-Integer/</url>
      <content type="html"><![CDATA[<p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。<br>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。<br><a id="more"></a></p><blockquote><p>示例 1:<br>输入: “III”<br>输出: 3</p></blockquote><blockquote><p>示例 2:<br>输入: “IV”<br>输出: 4</p></blockquote><blockquote><p>示例 3:<br>输入: “IX”<br>输出: 9</p></blockquote><blockquote><p>示例 4:<br>输入: “LVIII”<br>输出: 58<br>解释: L = 50, V= 5, III = 3.</p></blockquote><blockquote><p>示例 5:<br>输入: “MCMXCIV”<br>输出: 1994<br>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p></blockquote><p><b>题意分析：</b><br>这道题和上道题刚好相反，将罗马数字转换成阿拉伯数字。</p><p><b>思路分析：</b><br>在上道题我们分析了罗马数字是怎样表示数字的<br><code>III = 1 + 1 + 1</code><br><code>IV = -1 + 5 = 4</code><br><code>VIII = 5 + 1 + 1 + 1</code><br><code>IX = -1 + 10 = 9</code></p><p>其实我觉得这样写出来其实已经很清楚了，一般普通的字符我们就直接将其对于的数值累加即可。<br>唯独对于<code>4,9</code>这两个数字，应当是先减再加。而这两个数字的罗马表现形式都有一个共同的特点，那就是在<code>后面的字符所代表的数值更大</code>，想到这一步这题可解了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 108ms, beats 37.57%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        d = &#123;<span class="string">'M'</span>:<span class="number">1000</span>, <span class="string">'D'</span>:<span class="number">500</span>, <span class="string">'C'</span>:<span class="number">100</span>, <span class="string">'L'</span>:<span class="number">50</span>, <span class="string">'X'</span>:<span class="number">10</span>, <span class="string">'V'</span>:<span class="number">5</span>, <span class="string">'I'</span>:<span class="number">1</span>&#125;</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)<span class="number">-1</span>):</span><br><span class="line">            res = res + d[s[i]] * [<span class="number">1</span>,<span class="number">-1</span>][d[s[i]] &lt; d[s[i+<span class="number">1</span>]]]</span><br><span class="line">        res += d[s[<span class="number">-1</span>]]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> implementation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 12 Integer to Roman</title>
      <link href="/2018/10/18/Leetcode-12-Integer-to-Roman/"/>
      <url>/2018/10/18/Leetcode-12-Integer-to-Roman/</url>
      <content type="html"><![CDATA[<p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。<br>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。<br><a id="more"></a></p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><blockquote><p>示例 1:<br>输入: 3<br>输出: “III”</p></blockquote><blockquote><p>示例 2:<br>输入: 4<br>输出: “IV”</p></blockquote><blockquote><p>示例 3:<br>输入: 9<br>输出: “IX”</p></blockquote><blockquote><p>示例 4:<br>输入: 58<br>输出: “LVIII”<br>解释: L = 50, V = 5, III = 3.</p></blockquote><blockquote><p>示例 5:<br>输入: 1994<br>输出: “MCMXCIV”<br>解释: M = 1000, CM = 900, XC = 90, IV = 4.</p></blockquote><p><b>题意分析：</b><br>将给定的整数数字用罗马形式表示出来，规则如题所述</p><p><b>思路分析：</b><br>trick方法：因为取值不超过3999，其实我们是可以把所有的情况都写出来的，如下：<br>qw = [‘’,’M’,’MM’,’MMM’]<br>bw = [‘’,’C’,’CC’,’CCC’,’CD’,’D’,’DC’,’DCC’,’DCCC’,’CM’]<br>sw = [‘’,’X’,’XX’,’XXX’,’XL’,’L’,’LX’,’LXX’,’LXXX’,’XC’]<br>gw = [‘’,’I’,’II’,’III’,’IV’,’V’,’VI’,’VII’,’VIII’,’IX’]<br>然后只需要分别计算千位百位十位个位上的数字即可</p><p>当然我们抱着学习的态度来做这道题，肯定不能用暴力法只追求于题目所给的范围，还是得注重方法，万一你说范围给到了10^10，我们手写10个数组那就太累了。</p><p>我们先定义题目给出的规则<br><code>d = {1000: &#39;M&#39;, 500: &#39;D&#39;, 100: &#39;C&#39;, 50:&#39;L&#39;, 10:&#39;X&#39;, 5:&#39;V&#39;, 1:&#39;I&#39;}</code><br>我们观察到，如果一个数的<code>百位</code>上是val，如果val &lt;= 3，那么我们可以使用这个位的base(此时为’C’)，直接乘以val来表示即可。</p><p>如果5 &lt;= val &lt;= 8，那么我们可以使用这个位上的另一个base（此时为’D’）作为开头，然后 val -= 5，此时val &lt;= 3,即可按上面的情况补上若干个基本base</p><p>如果val == 4 or val == 9，我们则需要用这个位上的base(‘C’)加上更大一位上的base(‘D’,’M’)来表示</p><p>逻辑如上，代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="comment"># 80ms beats 54.07%</span></span><br><span class="line">        d = &#123;<span class="number">1000</span>: <span class="string">'M'</span>, <span class="number">500</span>: <span class="string">'D'</span>, <span class="number">100</span>: <span class="string">'C'</span>, <span class="number">50</span>:<span class="string">'L'</span>, <span class="number">10</span>:<span class="string">'X'</span>, <span class="number">5</span>:<span class="string">'V'</span>, <span class="number">1</span>:<span class="string">'I'</span>&#125;</span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        digit = <span class="number">1000</span></span><br><span class="line">        <span class="keyword">while</span> num &gt; <span class="number">0</span>:</span><br><span class="line">            val, num = divmod(num, digit)</span><br><span class="line">            <span class="keyword">if</span> val &lt;= <span class="number">3</span>: res += d[digit] * val</span><br><span class="line">            <span class="keyword">elif</span> val == <span class="number">9</span>:</span><br><span class="line">                res += d[digit] + d[digit*<span class="number">10</span>]</span><br><span class="line">            <span class="keyword">elif</span> val == <span class="number">4</span>:</span><br><span class="line">                res += d[digit] + d[digit*<span class="number">5</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += d[digit*<span class="number">5</span>] + (val<span class="number">-5</span>) * d[digit]</span><br><span class="line">            digit //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> implementation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 11 Container With Most Water</title>
      <link href="/2018/10/18/Leetcode-11-Container-With-Most-Water/"/>
      <url>/2018/10/18/Leetcode-11-Container-With-Most-Water/</url>
      <content type="html"><![CDATA[<p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器，且 n 的值至少为 2。<br><a id="more"></a></p><blockquote><p>示例:<br>输入: [1,8,6,2,5,4,8,3,7]<br>输出: 49</p></blockquote><p><b>题意分析：</b><br>选择两条线段，使其与x轴构成的容器的容量最大</p><p><b>思路分析：</b><br>我们知道容器的容量取决于底部长度和两边中较短的那一边的长度。<br>想让容量变大有两种方式，一种是增加底部长度，另一种是增加较短的边的长度。</p><p>我们首先先将底部长度<code>最大化</code>，即长度为n，n为数组长度。<br>在这个基础上，我们想将容量继续扩大，就只能是<code>增加较短边的长度</code>了。<br>当然，由于想增加较短边的长度就必须缩短底部长度，所以并不能保证何时能取得最大容量，我们需要每次都记录一下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 60ms, beats 18.72%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="comment"># 初始化底部长度，使其最大</span></span><br><span class="line">        i,j = <span class="number">0</span>,n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            h = min(nums[i], nums[j])</span><br><span class="line">            res = max(res, (j-i)*h)</span><br><span class="line">            <span class="comment"># 判断哪一条边是较短边，然后使其增大</span></span><br><span class="line">            <span class="keyword">if</span> h == nums[i]:</span><br><span class="line">                <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[i] &lt;= h: i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> h == nums[j]:</span><br><span class="line">                <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[j] &lt;= h: j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> two pointers </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 10 Regular Expression Matching</title>
      <link href="/2018/10/18/Leetcode-10-Regular-Expression-Matching/"/>
      <url>/2018/10/18/Leetcode-10-Regular-Expression-Matching/</url>
      <content type="html"><![CDATA[<p>给定一个字符串 (s) 和一个字符模式 (p)。实现支持 “.” 和 “*“ 的正则表达式匹配。<br>‘.’ 匹配任意单个字符。<br>‘*‘ 匹配零个或多个前面的元素。<br>匹配应该覆盖整个字符串 (s) ，而不是部分字符串。<br>说明:<br>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。<br><a id="more"></a></p><blockquote><p>示例 1:<br>输入:<br>s = “aa”<br>p = “a”<br>输出: false<br>解释: “a” 无法匹配 “aa” 整个字符串。</p></blockquote><blockquote><p>示例 2:<br>输入:<br>s = “aa”<br>p = “a*“<br>输出: true<br>解释: ‘*‘ 代表可匹配零个或多个前面的元素, 即可以匹配 ‘a’ 。因此, 重复 ‘a’ 一次, 字符串可变为 “aa”。</p></blockquote><blockquote><p>示例 3:<br>输入:<br>s = “ab”<br>p = “.*“<br>输出: true<br>解释: “.*“ 表示可匹配零个或多个(‘*‘)任意字符(‘.’)。</p></blockquote><blockquote><p>示例 4:<br>输入:<br>s = “aab”<br>p = “c*a*b”<br>输出: true<br>解释: ‘c’ 可以不被重复, ‘a’ 可以被重复一次。因此可以匹配字符串 “aab”。</p></blockquote><blockquote><p>示例 5:<br>输入:<br>s = “mississippi”<br>p = “mis*is*p*.”<br>输出: false</p></blockquote><p><b>题意分析：</b><br>就是让我们实现正则表达式的匹配函数，满足两条规则</p><ol><li>‘.’匹配任意单个字符</li><li>‘a*‘代表有x个连续的a字符 0 &lt;= x &lt; inf</li></ol><p><b>思路分析：</b><br>对于字符串p来说，我们先分析他前两个字符(先默认p的长度大于等于2，小于2的情况之后处理)，记作a,b；那么：<br>a可能是<code>&#39;.&#39;</code>，也可能是<code>小写字母</code>；<br>b可能是<code>&#39;.&#39;</code>，可能是<code>小写字母</code>，可能是<code>&#39;*&#39;</code>；<br>我们发现只要b不为<code>&#39;*&#39;</code>，那么他就无法对a产生影响，我们就可以使a和字符串s去匹配。<br>我们就可以继续分析s[1:], p[1:]了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(s,p)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(p) &gt;= <span class="number">2</span> <span class="keyword">and</span> p[<span class="number">1</span>] != <span class="string">'*'</span>:</span><br><span class="line">        <span class="keyword">if</span> p[<span class="number">0</span>] == s[<span class="number">0</span>] <span class="keyword">or</span> p[<span class="number">0</span>] == <span class="string">'.'</span>:</span><br><span class="line">            <span class="keyword">return</span> isMatch(s[<span class="number">1</span>:] ,p[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure></p><p>那如果b就是’*‘呢？此时代表着可以匹配若干个a字符。<br>我们考虑这种情况<code>s = &#39;cccbacd&#39;, p = &#39;c*cbacd&#39;</code><br>这两个字符串是否能匹配，关键在于判断<code>&#39;c*&#39;</code>到底匹配了多少个’c’，我们可以每一个都分两种情况判断一下，只要两种情况中有一种满足即可<br>如假设c*匹配0个c，<code>s = &#39;cccbacd, p = cbacd</code> False<br>如假设c*匹配1个c，<code>s = &#39;ccbacd, p = cbacd</code> False<br>如假设c*匹配2个c，<code>s = &#39;cbacd, p = cbacd</code> True<br>…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(s, p)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(p) &gt;= <span class="number">2</span> <span class="keyword">and</span> p[<span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">        <span class="keyword">return</span> isMatch(s[<span class="number">1</span>:], p) <span class="keyword">or</span> isMatch(s, p[<span class="number">2</span>:])</span><br></pre></td></tr></table></figure><p>ok，整体思路已经确定, len(p) &lt; 2的情况很简单，完整代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p: <span class="keyword">return</span> <span class="keyword">not</span> s</span><br><span class="line">        first_match = bool(s) <span class="keyword">and</span> p[<span class="number">0</span>] <span class="keyword">in</span> [s[<span class="number">0</span>],<span class="string">'.'</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(p) &gt;= <span class="number">2</span> <span class="keyword">and</span> p[<span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isMatch(s, p[<span class="number">2</span>:]) <span class="keyword">or</span> (first_match <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> first_match <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure></p><p>但是你会发现其中是会有大量重复计算的，<code>self.isMatch(s,p[2:])</code> 和 <code>self.isMatch(s[1:],p)</code> 中有很多重叠点。所以我们再采用一下记忆化的思想降低时间复杂度，但是将整个字符作为hash的key值代价太大，这里采用下标的方式处理。<br>改进代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        cache = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(i, j)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> j &gt;= len(p):</span><br><span class="line">                <span class="keyword">return</span> i == len(s)</span><br><span class="line"></span><br><span class="line">            key = (i, j)</span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">in</span> cache:</span><br><span class="line">                <span class="keyword">return</span> cache[key]</span><br><span class="line">            first_match = i &lt; len(s) <span class="keyword">and</span> p[j] <span class="keyword">in</span> [s[i], <span class="string">'.'</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> j+<span class="number">1</span> &lt; len(p) <span class="keyword">and</span> p[j+<span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">                cache[key] = helper(i, j+<span class="number">2</span>) <span class="keyword">or</span> (first_match <span class="keyword">and</span> helper(i+<span class="number">1</span>, j))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cache[key] = first_match <span class="keyword">and</span> helper(i+<span class="number">1</span>, j+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> cache[key]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 9 Palindrome Number</title>
      <link href="/2018/10/16/Leetcode-9-Palindrome-Number/"/>
      <url>/2018/10/16/Leetcode-9-Palindrome-Number/</url>
      <content type="html"><![CDATA[<p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><a id="more"></a><blockquote><p>示例 1:<br>输入: 121<br>输出: true</p></blockquote><blockquote><p>示例 2:<br>输入: -121<br>输出: false<br>解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</p></blockquote><blockquote><p>示例 3:<br>输入: 10<br>输出: false<br>解释: 从右向左读, 为 01 。因此它不是一个回文数。</p></blockquote><p>进阶:<br>你能不将整数转为字符串来解决这个问题吗？</p><p><b>题意分析：</b><br>判断一个数是否是回文数，负号也要考虑在内！</p><p><b>思路分析：</b><br>如果将x转换成字符串，那这道题直接可解，我们只需要判断x与他的reverse是否相等即可</p><p>当然，既然进阶里面说不让转字符串，我们也可以用取模的方式把反转过来的数计算出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 140ms beats 97.75%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        tmp = x</span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> tmp &gt; <span class="number">0</span>:</span><br><span class="line">            tmp,mod = tmp//<span class="number">10</span>,tmp%<span class="number">10</span></span><br><span class="line">            num = num * <span class="number">10</span> + mod</span><br><span class="line">        <span class="keyword">return</span> num == x</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 8 String to Integer(atoi)</title>
      <link href="/2018/10/16/Leetcode-8-String-to-Integer-atoi/"/>
      <url>/2018/10/16/Leetcode-8-String-to-Integer-atoi/</url>
      <content type="html"><![CDATA[<p>实现 atoi，将字符串转为整数。<br>该函数首先根据需要丢弃任意多的空格字符，直到找到第一个非空格字符为止。如果第一个非空字符是正号或负号，选取该符号，并将其与后面尽可能多的连续的数字组合起来，这部分字符即为整数的值。如果第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>字符串可以在形成整数的字符后面包括多余的字符，这些字符可以被忽略，它们对于函数没有影响。<br>当字符串中的第一个非空字符序列不是个有效的整数；或字符串为空；或字符串仅包含空白字符时，则不进行转换。<br>若函数不能执行有效的转换，返回 0。</p><p>说明：<br>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。如果数值超过可表示的范围，则返回  INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。<br><a id="more"></a></p><blockquote><p>Example 1:<br>Input: “42”<br>Output: 42</p></blockquote><blockquote><p>Example 2:<br>Input: “   -42”<br>Output: -42<br>Explanation: The first non-whitespace character is ‘-‘, which is the minus sign.Then take as many numerical digits as possible, which gets 42.</p></blockquote><blockquote><p>Example 3:<br>Input: “4193 with words”<br>Output: 4193<br>Explanation: Conversion stops at digit ‘3’ as the next character is not a numerical digit.</p></blockquote><blockquote><p>Example 4:<br>Input: “words and 987”<br>Output: 0<br>Explanation: The first non-whitespace character is ‘w’, which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed.</p></blockquote><blockquote><p>Example 5:<br>Input: “-91283472332”<br>Output: -2147483648<br>Explanation: The number “-91283472332” is out of the range of a 32-bit signed integer.Thefore INT_MIN (−231) is returned.</p></blockquote><p><b>感慨:</b><br><code>第一次做的时候还是个小白，当时这道题真把我人都气傻了，不过现在再做一遍的时候发现也不过如此，或许这就是膨胀吧。</code><br>不过！！！我总觉得test case少了很多啊，我记得以前有什么1e5 = 10^5之类的样例啊，这次为什么返回1啊！</p><p><b>题意分析：</b><br>一道需要考虑特别多特殊case的问题，例如：</p><ol><li>是否以多个空格开头</li><li>除去空格后是否以符号开头</li><li>第一段数字是否合法</li><li>转换出来的数字是否溢出</li></ol><p><b>思路分析：</b><br>这个时候不得不说python这门语言的优势了，集成了特别多好用以及通用的函数，打个比方，python中的int()函数，是不会出现因为里面的数过大而溢出的情况的。</p><p>这道题的关键就是借用try,except结构，将所有的不规则case全部一并处理。<br>首先将字符串左边的空格消去。<br>然后开始遍历首部的字符，满足终止条件则break<br>终止条件包括：</p><ol><li>除首位以外的位置出现’+-‘符号</li><li>出现非数字字符</li></ol><p>将获得的数进行int强制转换，判断其是否溢出<br>其余情况一概返回0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 36ms, beats 94.23%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        s = s.strip()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            val = <span class="string">''</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">                <span class="keyword">if</span> (s[i] <span class="keyword">in</span> <span class="string">'+-'</span> <span class="keyword">and</span> i == <span class="number">0</span>) <span class="keyword">or</span> <span class="string">'0'</span> &lt;= s[i] &lt;= <span class="string">'9'</span>:</span><br><span class="line">                    val += s[i]</span><br><span class="line">                <span class="keyword">else</span>: <span class="keyword">break</span></span><br><span class="line">            val = int(val)</span><br><span class="line">            <span class="keyword">if</span> val &lt; <span class="number">-2</span>**<span class="number">31</span>: <span class="keyword">return</span> <span class="number">-2</span>**<span class="number">31</span></span><br><span class="line">            <span class="keyword">if</span> val &gt; <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span>: <span class="keyword">return</span> <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span></span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> implementation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 7 Reverse Integer</title>
      <link href="/2018/10/16/Leetcode-7-Reverse-Integer/"/>
      <url>/2018/10/16/Leetcode-7-Reverse-Integer/</url>
      <content type="html"><![CDATA[<p>给定一个32位的有符号整数，输出其翻转之后的整数<br><a id="more"></a></p><p>示例1：<br>输入：123<br>输出：321</p><p>示例2：<br>输入：-123<br>输出：-321</p><p>示例3：<br>输入：120<br>输出：21</p><p>注意：<br>当返回值超过32位有符号整数能表示的范围时，返回0</p><p><b>题意分析：</b><br>将整数翻转，注意处理下各种特殊case。<br>由于python语言的特性，做这道题有着天然的优势。</p><p><b>思路分析：</b><br>先考虑最一般的情况，x就是一个普通的正整数，我们只需要将x强制转换成字符串类型然后反转即可。</p><p>case 1：x&lt;0，我们需要将负号先拿出来，然后把x按上面的方式处理，最后加上负号即可。<br>case 2：按上面两种方法最后得出来的结果超出了整形范围，我们就单独判断一下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 32ms, beats 80%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="comment"># 存符号，最后乘上flag</span></span><br><span class="line">        flag = [<span class="number">-1</span>,<span class="number">1</span>][x&gt;=<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 当做正整数处理</span></span><br><span class="line">        x = abs(x)</span><br><span class="line">        x = int(str(x)[::<span class="number">-1</span>])</span><br><span class="line">        x *= flag</span><br><span class="line">        <span class="comment"># 判断是否越界</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">-2</span>**<span class="number">31</span> <span class="keyword">or</span> x &gt; <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> implementation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 924 Minimize Malware Spread</title>
      <link href="/2018/10/15/Leetcode-924-Minimize-Malware-Spread/"/>
      <url>/2018/10/15/Leetcode-924-Minimize-Malware-Spread/</url>
      <content type="html"><![CDATA[<p>在节点网络中，只有当 graph[i][j] = 1 时，每个节点i能够直接连接到另一个节点 j。<br>一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。<br>假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。<br>我们可以从初始列表中删除一个节点。如果移除这一节点将最小化 M(initial)， 则返回该节点。如果有多个节点满足条件，就返回索引最小的节点。<br>请注意，如果某个节点已从受感染节点的列表 initial 中删除，它以后可能仍然因恶意软件传播而受到感染。<br><a id="more"></a></p><blockquote><p>示例 1：<br>输入：graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]<br>输出：0<br>示例 2：<br>输入：graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]<br>输出：0<br>示例 3：<br>输入：graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]<br>输出：1</p></blockquote><p>提示：</p><ol><li>1 &lt; graph.length = graph[0].length &lt;= 300</li><li>0 &lt;= graph[i][j] == graph[j][i] &lt;= 1</li><li>graph[i][i] = 1</li><li>1 &lt;= initial.length &lt; graph.length</li><li>0 &lt;= initial[i] &lt; graph.length</li></ol><p><b>题意分析：</b><br>在一个图中，有某些节点初始处于被感染状态，随着时间的流逝最终会将所有直接或间接与该节点相连的节点全部感染。<br>现在可以修复一个初始感染节点，我们想使最终的感染节点数量最小，问该修复哪一个初始感染节点。</p><p><b>思路分析：</b><br>假设图结构如下图所示，初始感染节点为[1,3,5]，由黄色节点表示:<br><img src="/images/leetcode_924.png" alt=""></p><p>如果我们什么不操作，那么最终图上所有的节点都会被感染。<br>那我们现在想删一个初始感染节点，应该怎么去选呢？<br>假设删除1，最终左边这个连通子图还是会全部被感染，因为3是感染节点<br>删除3同删除1<br>假设删除5,可以使右边这个连通子图的所有节点不被感染，成功使感染节点少了3个</p><p>我们很容易发现，如果在一个连通子图里面，有<code>两个或两个以上</code>的节点初始被感染，那么无论我们删除哪个都对最后结果没有影响。我们唯一能使感染节点减少的操作就是删除那些<code>只有一个感染节点</code>的连通子图中的感染节点。</p><p>所以整个代码的逻辑应该如下：</p><ol><li>找到一个连通子图</li><li>判断子图中感染节点的数量，若为1，执行第三步；反之执行第一步</li><li>计算该子图的长度，长度越长，就越可以最小化感染节点的数量</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 188ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minMalwareSpread</span><span class="params">(self, graph, initial)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node,vis)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span>  range(len(graph[node])):</span><br><span class="line">                <span class="keyword">if</span> graph[node][v] == <span class="number">1</span> <span class="keyword">and</span> v <span class="keyword">not</span> <span class="keyword">in</span> vis:</span><br><span class="line">                    vis.add(v)</span><br><span class="line">                    dfs(v,vis)</span><br><span class="line"></span><br><span class="line">        s = set(initial)</span><br><span class="line">        t_vis = set()</span><br><span class="line">        del_node, subgraph_len = min(initial), <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> range(len(graph)):</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> t_vis:</span><br><span class="line">                vis = set([node])</span><br><span class="line">                dfs(node,vis)</span><br><span class="line">                <span class="comment"># 计算子图中感染节点的数量</span></span><br><span class="line">                infect = vis &amp; s</span><br><span class="line">                <span class="keyword">if</span> len(infect) == <span class="number">1</span>:</span><br><span class="line">                    <span class="comment"># 长度更长 或者 长度相同但index更小</span></span><br><span class="line">                    <span class="keyword">if</span> len(vis) &gt; subgraph_len <span class="keyword">or</span> (len(vis) == subgraph_len <span class="keyword">and</span> list(infect)[<span class="number">0</span>] &lt; del_node):</span><br><span class="line">                        del_node,subgraph_len = list(infect)[<span class="number">0</span>],len(vis)</span><br><span class="line">                t_vis |= vis</span><br><span class="line">        <span class="keyword">return</span> del_node</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 923 3Sum With Multiplicity</title>
      <link href="/2018/10/15/Leetcode-923-3Sum-With-Multiplicity/"/>
      <url>/2018/10/15/Leetcode-923-3Sum-With-Multiplicity/</url>
      <content type="html"><![CDATA[<p>给定一个整数数组 A，以及一个整数 target 作为目标值，返回满足 i &lt; j &lt; k 且 A[i] + A[j] + A[k] == target 的元组 i, j, k 的数量。<br>由于结果会非常大，请返回 结果除以 10^9 + 7 的余数。<br><a id="more"></a></p><blockquote><p>示例 1：<br>输入：A = [1,1,2,2,3,3,4,4,5,5], target = 8<br>输出：20<br>解释：<br>按值枚举（A[i]，A[j]，A[k]）：<br>(1, 2, 5) 出现 8 次；<br>(1, 3, 4) 出现 8 次；<br>(2, 2, 4) 出现 2 次；<br>(2, 3, 3) 出现 2 次。</p></blockquote><blockquote><p>示例 2：<br>输入：A = [1,1,2,2,2,2], target = 5<br>输出：12<br>解释：<br>A[i] = 1，A[j] = A[k] = 2 出现 12 次：<br>我们从 [1,1] 中选择一个 1，有 2 种情况，<br>从 [2,2,2,2] 中选出两个 2，有 6 种情况。</p></blockquote><p>提示：</p><ol><li>3 &lt;= A.length &lt;= 3000</li><li>0 &lt;= A[i] &lt;= 100</li><li>0 &lt;= target &lt;= 300</li></ol><p><b>题意分析：</b><br>在整数数组A中找三个数使三个数的和等于给定值，A中包含重复元素。<br>A的长度不超过3000，理论上n^2的复杂度是可以被接受的。</p><p><b>思路分析：</b><br>我们很轻易的就能想到固定住一个数a[i]，然后在剩下的元素找和为target - a[i]的结果，就把问题转换成了一个twoSum问题。</p><p>思路没有问题，但是在这里如何去写twoSum()呢<br>通常我们有两种方法，一种是<code>使用空间vis去保存已经遍历过的数</code>，然后<code>观察target-A[i]是否存在于vis中</code>.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># O(n) time, O(n) space</span></span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(A,target)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> target &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    d = collections.Counter()</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> A:</span><br><span class="line">        <span class="keyword">if</span> target - val <span class="keyword">in</span> d:</span><br><span class="line">            res += d[target-val]</span><br><span class="line">        d[val] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><p>另一种是<code>先排序，然后使用双指针法遍历</code>，但是因为存在重复数字，所以写起来并不是那么简单。<br>当然实际排序在3Sum函数中已经排好序了。这里函数是对已经排好序的数组使用双指针法的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># O(n) time, O(1) space, 2608ms</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(A,target)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> target &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    i,j = <span class="number">0</span>,len(A)<span class="number">-1</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> A[i] + A[j] &lt; target: i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> A[i] + A[j] &gt; target: j -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 当相等之后开始分析重复数字</span></span><br><span class="line">        <span class="keyword">if</span> A[i] + A[j] == target:</span><br><span class="line">            <span class="keyword">if</span> A[i] == A[j]:</span><br><span class="line">                ans += (j-i+<span class="number">1</span>)*(j-i) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l,r = <span class="number">1</span>,<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> i+<span class="number">1</span> &lt; j <span class="keyword">and</span> A[i+<span class="number">1</span>] == A[i]: l += <span class="number">1</span>;i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> i &lt; j<span class="number">-1</span> <span class="keyword">and</span> A[j<span class="number">-1</span>] == A[j]: r += <span class="number">1</span>;j -= <span class="number">1</span></span><br><span class="line">                ans += l * r</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSumMulti</span><span class="params">(A, target)</span>:</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    mod = <span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span></span><br><span class="line">    A.sort()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">        res += twoSum(A[i+<span class="number">1</span>:], target-A[i])</span><br><span class="line">    <span class="keyword">return</span> res % mod</span><br></pre></td></tr></table></figure></p><p>第一种方法简单，但是却会TLE，首先Counter()函数的构造是很花时间的；就算把Counter()函数换成了<code>d = [0] * 100</code>(因为A[i]的取值不超过100)，还是TLE。</p><p>因为我自己代码逻辑的问题，每次twoSum都用重新开空间，确实会有很大的重复计算，但是我想每次重开的空间d，其实数量并不大，也就不到100，A的长度不超过3000，总空间也不会超过300000啊，感觉应该是能AC的。</p><p>然后我写了个O(1) space的解法，最后勉强能通过，我猜测可能是python本身语言特性的原因导致tle。</p><p>当然为了验证这个猜测，我也仿照discuss里面别人c++的思路来写python代码，但只要时间复杂度为O(n^2)并涉及到空间的都会TLE。</p><p>唯独这一种解法，在使用单纯的数组而非Counter()函数后，是勉强可以通过的，运行时间和我的解法差不多。(所以我脑子还是不够灵性，像这样计算前面的twoSum就不用每次都重开数组了)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># O(n^2) time, O(300) space 2744ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumMulti</span><span class="params">(self, A, target)</span>:</span></span><br><span class="line">        d = [<span class="number">0</span>] * <span class="number">300</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            res += d[target-A[i]] <span class="keyword">if</span> target-A[i] &gt;=<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            res %= (<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                d[A[i] + A[j]] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res % (<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 922 Sort Araay By Parity II</title>
      <link href="/2018/10/15/Leetcode-922-Sort-Araay-By-Parity-II/"/>
      <url>/2018/10/15/Leetcode-922-Sort-Araay-By-Parity-II/</url>
      <content type="html"><![CDATA[<p>给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。<br>对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。<br>你可以返回任何满足上述条件的数组作为答案。<br><a id="more"></a></p><blockquote><p>示例：<br>输入：[4,2,5,7]<br>输出：[4,5,2,7]<br>解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。</p></blockquote><p>提示：</p><ol><li>2 &lt;= A.length &lt;= 20000</li><li>A.length % 2 == 0</li><li>0 &lt;= A[i] &lt;= 1000</li></ol><p><b>题意分析：</b><br>给定一个数组，变动其内的若干数使得偶数位上的数是偶数，奇数位上的数是奇数。</p><p><b>思路分析：</b><br>当时周测的时候因为争分夺秒，我就直接写的O(n) space的方法<br>但实际上这道题是可以用O(1)的方法来求解的</p><p>因为题目中说到A中奇数偶数各一半，那么当我找到一个奇数位上的偶数，就一定存在某个奇数存在于偶数位置上。<br>我们可以使用双指针法来求解，一个指针专门记录奇数位上的偶数，另一个则记录偶数位上的奇数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 164ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArrayByParityII</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        n = len(A)</span><br><span class="line">        l,r = <span class="number">0</span>,n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; n <span class="keyword">and</span> r &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> l &lt; n <span class="keyword">and</span> A[l] % <span class="number">2</span> == <span class="number">0</span>: l += <span class="number">2</span></span><br><span class="line">            <span class="keyword">while</span> r &gt;=<span class="number">0</span> <span class="keyword">and</span> A[r] % <span class="number">2</span> == <span class="number">1</span>: r -= <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> l &lt; n <span class="keyword">and</span> r &gt;= <span class="number">0</span>:</span><br><span class="line">                A[l], A[r] = A[r], A[l]</span><br><span class="line">        <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 921 Minimum Add to Make Parentheses Valid</title>
      <link href="/2018/10/15/Leetcode-921-Minimum-Add-to-Make-Parentheses-Valid/"/>
      <url>/2018/10/15/Leetcode-921-Minimum-Add-to-Make-Parentheses-Valid/</url>
      <content type="html"><![CDATA[<p>给定一个由 ‘(‘ 和 ‘)’ 括号组成的字符串S，我们需要添加最少的括号（ ‘(‘ 或是 ‘)’，可以在任何位置），以使得到的括号字符串有效。</p><p>从形式上讲，只有满足下面几点之一，括号字符串才是有效的：<br>它是一个空字符串，或者<br>它可以被写成 AB （A 与 B 连接）, 其中 A 和 B 都是有效字符串，或者<br>它可以被写作 (A)，其中 A 是有效字符串。<br>给定一个括号字符串，返回为使结果字符串有效而必须添加的最少括号数。<br><a id="more"></a></p><blockquote><p>示例 1：<br>输入：”())”<br>输出：1<br>示例 2：<br>输入：”(((“<br>输出：3<br>示例 3：<br>输入：”()”<br>输出：0<br>示例 4：<br>输入：”()))((“<br>输出：4</p></blockquote><p>提示：<br>· S.length &lt;= 1000<br>· 只包含 ‘(‘ 和 ‘)’ 字符。</p><p><b>题意分析：</b><br>向给定字符串中任意位置添加左括号或者右括号，使整个字符串合法！</p><p><b>思路分析：</b><br>碰到这种后面的元素需要和前面的元素进行匹配的问题，通常是要用到栈这个数据结构的。<br>这类问题主要包括：括号是否合法(右括号匹配左括号)、加减乘除运算(运算符右边的数匹配运算符左边的数)等</p><p>对于这道题，我们将所有的左括号入栈，遍历到右括号就使左括号出栈，若当前栈为空，说明这个右括号是不合法的。<br>若遍历过程结束，栈内仍有多余的左括号，说明这些左括号是不合法的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 24ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minAddToMakeValid</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        stack = []</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> ss <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> ss == <span class="string">'('</span>:</span><br><span class="line">                stack.append(ss)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack: </span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack.pop()</span><br><span class="line">        <span class="keyword">return</span> res + len(stack)</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018.10.14 腾讯笔试</title>
      <link href="/2018/10/15/2018-10-14-%E8%85%BE%E8%AE%AF%E7%AC%94%E8%AF%95/"/>
      <url>/2018/10/15/2018-10-14-%E8%85%BE%E8%AE%AF%E7%AC%94%E8%AF%95/</url>
      <content type="html"><![CDATA[<p>总结：共3道算法题，2AC，1WA（90% passed），题目都很有意思。<br><a id="more"></a><br>不过腾讯也是不当人，前些天国内的笔试题，两次都是3道算法题，那真叫一个难啊，我都只A了一道，这次笔试面向海外，md题目就相对简单了很多，这是不是在搞区别对待啊？</p><h2 id="1-包含k个’1’的子串-AC"><a href="#1-包含k个’1’的子串-AC" class="headerlink" title="1. 包含k个’1’的子串(AC)"></a>1. 包含k个’1’的子串(AC)</h2><p>一个字符串如果只包含’0’和’1’，那么久称这个字符串为二进制字符串。</p><p>一个字符串w的子串v是一个非空字符串，并且它由从w的某个位置开始的一段连续字符构成。比如’010’有6个子串，’0’,’1’,’0’,’01’,’10’,’010’</p><p>如果两个子串出现的位置不相同，那么就认为这两个子串是不同。给出一个二进制字符串s，计算s中刚好包含k个字符’1’的子串的个数。</p><p><b>输入描述:</b><br>第一行一个整数k,含义如题<br>第二行一个非空二进制字符串s<br>满足0 &lt;= k &lt;= 10^6, 1 &lt;= len(s) &lt;= 10^6</p><p><b>输出描述：</b><br>一个整数，表示恰好包含k个’1’的子串的个数。</p><p>示例1：<br>2<br>111</p><p>输出：<br>2</p><p>示例2：<br>3<br>1101</p><p>输出：<br>1</p><p><b>思路：</b><br>对于 <code>s = &#39;001010011&#39;, k = 2</code>，我们先找到两个1，然后向两边扩散，观察能有多少种扩散方式，先将所有的1的下标存储<br>index = [2,4,7,8]，比如对于前两个’1’，2可以往左边扩散0个，1个，2个，分别对应下标2，下标1，下标0；对于4可以往右边扩散0个，1个，2个，分别对应下标4，下标5，下标6，所以总共扩散方式就是<code>3x3 = 9</code>种。<br>为了处理边界情况，在index数组左右两边分别加上-1,以及len(s)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">k = int(input())</span><br><span class="line">s = input()</span><br><span class="line">n = len(s)</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> s.count(<span class="string">'1'</span>) &lt; k:</span><br><span class="line">    print(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    index = [<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">if</span> s[i] == <span class="string">'1'</span>: index.append(i)</span><br><span class="line">    index.append(n)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(index)):</span><br><span class="line">        <span class="keyword">if</span> i+k &lt; len(index):</span><br><span class="line">            j = i+k</span><br><span class="line">            res += (index[i]-index[i<span class="number">-1</span>]) * (index[j] - index[j<span class="number">-1</span>])</span><br><span class="line">    print(res)</span><br></pre></td></tr></table></figure><h2 id="2-很酷的子序列-WA-90-PASSED"><a href="#2-很酷的子序列-WA-90-PASSED" class="headerlink" title="2. 很酷的子序列(WA, 90% PASSED)"></a>2. 很酷的子序列(WA, 90% PASSED)</h2><p>小Q定义A(i,j)(i&lt;=j并且都是A的合法下标)表示数组A中下标从i到j的这段子序列，即A(i,j) = {A[i],A[i+1],…,A[j]}。</p><p>对于A(i,j)，能找到一个正整数v(v&gt;1)，使得v可以整除A(i,j)中不低于一半的元素，小Q就认为A(i,j)是一段很酷的子序列。</p><p>例如A(i,j) = {3,3,7,9,1,10}，六个元素中三个元素可以被v=3整除，所以A(i,j)是酷的。<br>现在给出一个数组A，让你找出最长的酷的子序列的长度。</p><p><b>输入描述：</b><br>输入包括两行。<br>第一行包括一个正整数n(1 &lt;= n &lt;= 50)，表示数组的长度。<br>第二行包括n个正整数A[i]，(1 &lt;= A[i] &lt;= 1000)，表示数组中的每个元素。</p><p><b>输出描述：</b><br>一个整数，表示最长的酷的子序列的长度，如果没有解，输出0.</p><p>示例1：<br>输入：<br>5<br>8 8 5 5 4</p><p>输出：<br>5</p><p>解释：<br>8 8 4都能被4整除，3个数已经超过序列长度的一半，所以长度为5</p><p><b>思路分析：</b><br>假设对于一段序列，A[i],…,A[j],…,A[k]</p><p>我们知道这段序列中只有A[i],A[j],A[k]这三个数同时能被v整除，那如何来计算序列长度呢？<br>我们知道这段序列的长度<code>l = k-i+1</code>,<code>如果 3 &gt;= l//2(这是前提)</code>，那么我们可以说已经找到了个长度为l的酷的序列，当然实际上3个数能构成长度为6的序列，所以我们可以说已经找到了长度6的酷的序列（当然前提是A的长度要大于等于6）</p><p>你需要注意到实际计算时并不是l越大越好，因为数量可能跟不上，比如对于A[1],A[3],A[8]，直接看1和8会发现这段序列太长，我们数的个数并没有超过长度的一半。所以我们得先看1,3再看1,8，再看3,8，把所有的可能都计算才行。</p><p>那么怎么来找上面所说的A[i],A[j],A[k]呢</p><p>我们知道v其实就是他们的相同公约数，我们注意到A[i]的取值是不超过1000的，我们完全可以把1000以内所有的质数都计算出来，然后依次遍历，例如对于质数2，A中所有A[i] % 2 == 0的数的<code>下标</code>都存进d[2]中。这样我们就找到了A[i],A[j],A[k]，然后使用n^2的遍历方法对每一段进行分析</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 90% passed，可能是某种特殊情况没想到</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter, defaultdict, deque</span><br><span class="line">read = <span class="keyword">lambda</span>: list(map(int,input().split()))</span><br><span class="line"></span><br><span class="line">n = int(input())</span><br><span class="line">a = read()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span><span class="params">(val)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> val == <span class="number">1</span>: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, int(val**<span class="number">0.5</span>) +<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> val % i == <span class="number">0</span>: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># p中存储1000以内的质数</span></span><br><span class="line">p = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">1001</span>):</span><br><span class="line">    <span class="keyword">if</span> isPrime(i): p.append(i)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(a) == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    d = defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> p:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> a[i] % val == <span class="number">0</span>:</span><br><span class="line">                d[val].append(i)</span><br><span class="line">    res = <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> d:</span><br><span class="line">        l = len(d[key])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,l):</span><br><span class="line">                <span class="comment"># ka表示这段序列的长度,cnt表示这段序列中能被v整除的数的个数</span></span><br><span class="line">                ka = d[key][j] - d[key][i] + <span class="number">1</span></span><br><span class="line">                cnt = j-i+<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> cnt &gt;= (ka+<span class="number">1</span>) // <span class="number">2</span>:</span><br><span class="line">                    res = max(res, min(<span class="number">2</span>*cnt,n))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">print(solve(a))</span><br></pre></td></tr></table></figure><h2 id="3-数字拼凑-AC"><a href="#3-数字拼凑-AC" class="headerlink" title="3. 数字拼凑(AC)"></a>3. 数字拼凑(AC)</h2><p>小Q有一个长度为n的序列S，序列中有n个正整数。小Q现在和你玩数字游戏，每次小Q说出一个正整数X，你需要从序列中挑选出若干个数字出来进行相加，使结果等于X，如果你不能完成拼凑你就输了。</p><p>小Q现在想知道能让你输掉游戏的最小的正整数X是多少？</p><p><b>输入描述：</b><br>输入包括两行<br>第一行为一个正整数n，表示序列的长度 1 &lt;= n &lt;= 20<br>第二行包括n个正整数a[i]，用空格隔开， 1 &lt;= a[i] &lt; 10^5</p><p><b>输出描述：</b><br>一个正整数，表示最小的正整数X</p><p>示例1：<br>输入：<br>3<br>2 1 4<br>输出：<br>8</p><p><b>思路分析：</b><br>这道题是非常经典的一道题型，对于给定的数组，需要分析其所有可能组成的和(每个数字用一次)<br>PS：如果每个数字能用多次，其实就是一个零钱凑整问题</p><p>使用dp[i]表示序列中的数字能否组成正整数i<br>因为序列所能组成的最大数字为 sum(a)，所以dp = [0] * (sum(a) + 2)<br>对于每个dp[i]需要反向遍历来确保不会重复利用数字,dp[i] = any(dp[j] for j= i-a[k] for k in range(n))</p><p>用文字描述逻辑可能有点乱，建议读者直接使用测试样例的数据来分析这个代码，那样理解得更快</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter, defaultdict, deque</span><br><span class="line">read = <span class="keyword">lambda</span>: list(map(int,input().split()))</span><br><span class="line"></span><br><span class="line">mod = <span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span></span><br><span class="line">inf = float(<span class="string">'inf'</span>)</span><br><span class="line"></span><br><span class="line">n = int(input())</span><br><span class="line">a = read()</span><br><span class="line">dp = [<span class="number">0</span>] * (sum(a) + <span class="number">2</span>)</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(dp)<span class="number">-1</span>,a[i]<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        val = j - a[i]</span><br><span class="line">        <span class="keyword">if</span> dp[val] == <span class="number">1</span>:</span><br><span class="line">            dp[j] = <span class="number">1</span></span><br><span class="line"><span class="comment"># 找到第一个dp[i] = 0的位置</span></span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> dp[index] == <span class="number">1</span>:</span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line">print(index)</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 思维提升 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018.10.13 华为笔试</title>
      <link href="/2018/10/15/2018-10-13-%E5%8D%8E%E4%B8%BA%E7%AC%94%E8%AF%95/"/>
      <url>/2018/10/15/2018-10-13-%E5%8D%8E%E4%B8%BA%E7%AC%94%E8%AF%95/</url>
      <content type="html"><![CDATA[<p>总结：共两道算法题，全部AC，两道题都是算法中的经典问题，一道标准dfs，一道约瑟夫环问题，还是比较有意思的。<br><a id="more"></a></p><h2 id="1-最大连通区域面积"><a href="#1-最大连通区域面积" class="headerlink" title="1. 最大连通区域面积"></a>1. 最大连通区域面积</h2><p>在固定大小10x10的矩阵中，分布着若干个连通区域：<br><img src="/images/2018_10_13_华为_1_1.png" alt=""></p><p>连通区域是由若干个相互连接的1方格组成，每个方格面积是1，求最大连通区域面积<br>如图所示，有4个连通区域，黄色面积为19，绿色面积为2，蓝色面积为8，红色面积为8，则最大面积为19.</p><p><b>输入描述：</b><br>100个数排成一行，由空格分割，输入中只包含0和1, 100个数是由矩阵按行从上到下依次排开的顺序输入。<br>上图中的输入数据为：0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 0 0 0 0 0 1 0 0 0 1 0 1 0 0 0 1 0 1 0 1 0 1 0 0 0 1 0 1 0 1 0 1 0 0 0 1 0 0 0 1 0 1 1 0 0 1 0 1 1 1 0 1 1 1 0 1 1 1 0 0 1 0 0 0 0 0 0 0 1 1 1 1 1 0 0 0 0 0 1 0 0 1 0 0 0</p><p><b>输出描述：</b><br>一个数字，表示最大连通区域面积</p><p><b>题意分析：</b><br>标准的dfs题型，对于每一个1，都使用一个dfs去遍历所有与其连通的1，已经遍历过的1则不处理，记录下每次dfs的最大值即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">s = input().split()</span><br><span class="line"><span class="comment"># 读入数据</span></span><br><span class="line">grid = [[<span class="number">0</span>]*<span class="number">10</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        grid[i][j] = int(s[i*<span class="number">10</span>+j])</span><br><span class="line"></span><br><span class="line"><span class="comment"># dfs遍历面积</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i,j)</span>:</span></span><br><span class="line">    ans = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> x,y <span class="keyword">in</span> [(i+<span class="number">1</span>,j), (i<span class="number">-1</span>,j), (i,j+<span class="number">1</span>), (i,j<span class="number">-1</span>)]:</span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span>&lt;=x&lt;<span class="number">10</span> <span class="keyword">and</span> <span class="number">0</span>&lt;=y&lt;<span class="number">10</span> <span class="keyword">and</span> grid[x][y] == <span class="number">1</span> <span class="keyword">and</span> (x,y) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            visited.add((x,y))</span><br><span class="line">            ans += dfs(x,y)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">res = <span class="number">0</span></span><br><span class="line">visited = set()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">if</span> grid[i][j] == <span class="number">1</span> <span class="keyword">and</span> (i,j) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            visited.add((i,j))</span><br><span class="line">            res = max(res, dfs(i,j))</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><h2 id="2-餐桌-AC"><a href="#2-餐桌-AC" class="headerlink" title="2. 餐桌(AC)"></a>2. 餐桌(AC)</h2><p>一个圆形餐桌上有n个人，编号从1到n（顺时针方向），编号1与编号n相邻<br>现在从编号1开始顺时针从1开始报数，每相邻而坐的就加1，报数为m则立即出局离开餐桌，出局后不能参与后面的报数，然后其顺时针方向的下一位重新从1开始报数。<br>这样一直报数，当餐桌上只剩一人，则该人自动出局，请你打印出这n个人离开餐桌的顺序</p><p><b>输入描述：</b><br>第一行一个整数t，表示测试样例的数量<br>对于每组测试样例：<br>第一行一个整数n，表示总人数 （1 &lt;= n &lt;= 1000）<br>第二个一个整数m，表示报到m的人出局 (1 &lt;= m &lt;= 1000)</p><p><b>输出描述：</b><br>对于每组测试样例：<br>输出一行n个数，空格隔开，表示离开餐桌的顺序</p><p><b>输入样例：</b><br>3<br>2<br>3<br>4<br>2<br>4<br>5</p><p><b>输出样例：</b><br>1 2<br>2 4 3 1<br>1 3 4 2</p><p><b>题意分析：</b><br>这是经典的约瑟夫环问题，通常来说这种题只用求最后胜出的那个人的编号，是可以用数学解法来求解，复杂度O(n)，但是这道题需要我们模拟出游戏的整个过程，那复杂度为O(m*n)，这道题n,m取值都不超过1000，故复杂度完全ok！</p><p>我们可以用队列来模拟整个过程，队列首部报数的人如果不是报的m，则重新加入队列尾部；否则直接丢弃，不参与之后的报数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">t = int(input())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(t):</span><br><span class="line">    n = int(input())</span><br><span class="line">    m = int(input())</span><br><span class="line">    Q = deque(list(range(<span class="number">1</span>,n+<span class="number">1</span>)))</span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> len(Q) &gt;= <span class="number">1</span>:</span><br><span class="line">        val = Q.popleft()</span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> cnt % m == <span class="number">0</span>:</span><br><span class="line">            res.append(val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            Q.append(val)</span><br><span class="line">    print(<span class="string">' '</span>.join(map(str, res)))</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 思维提升 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018.10.11 滴滴笔试</title>
      <link href="/2018/10/15/2018-10-11-%E6%BB%B4%E6%BB%B4%E7%AC%94%E8%AF%95/"/>
      <url>/2018/10/15/2018-10-11-%E6%BB%B4%E6%BB%B4%E7%AC%94%E8%AF%95/</url>
      <content type="html"><![CDATA[<p>总结：这两道题目的题意表述得也太差了吧，明明几句话能说清楚的东西我不知道这是在写什么。<br>共两道算法题：1 give up, 1 AC<br><a id="more"></a></p><h2 id="1-DIST-give-up"><a href="#1-DIST-give-up" class="headerlink" title="1. DIST(give up)"></a>1. DIST(give up)</h2><p>在平面直角坐标系上，问从(x1,y1)到(x2,y2)有多少条路径，使得<br>1）对路径上经过的每一点(x,y)，x和y至少有一个是整数。<br>2）路径的长度为 |x1 - x2| + |y1 - y2|<br>3）对于路径的每一点(x,y)，都保证x &lt;= y<br>答案可能很大，输出其mod 1e9+7的结果</p><p><b>输入描述：</b><br>每组测试数据一行，包括x1, y1, x2, y2__四个整数__，且-1e6 &lt;= x1, y1, x2, y2 &lt;= 1e6<br>其中20%的数据：max(x1, x2) &lt;= min(y1, y2), 0 &lt;= x1, y1, x2, y2 &lt;= 100<br>其中20%的数据：(x1, y1) = (0,0), 0 &lt;= x2, y2 &lt;= 100<br>其中20%的数据：-100 &lt;= x1, y1, x2, y2 &lt;= 100<br>其中20%的数据：(x1, y1) = (0,0), 0 &lt;= x2, y2 &lt;= 1e6<br>其中20%的数据：-1e6 &lt;= x1, y1, x2, y2 &lt;= 1e6</p><p><b>输出描述：</b><br>每行一个数字，代表路径的数量</p><p><b>样例输入：</b><br>0 0 0 0<br>0 0 1 1</p><p><b>样例输出：</b><br>1<br>1</p><p><code>这道题也是天秀啊，我都得靠猜“出题人应该是这个意思吧”来做这道题，后面发到论坛上去求助，大家都没人敢说‘这道题肯定是xx意思’，都只能说 ‘应该是xx意思，否则这道题没意义’</code><br>让我恶心的不想写题解。</p><h2 id="2-Hilert曲线"><a href="#2-Hilert曲线" class="headerlink" title="2. Hilert曲线"></a>2. Hilert曲线</h2><p>在数学分析中，有这样一个问题：能否用一条无限长的线，穿过任意维度空间里面的所有点？答案是肯定的，而且不止有一种这样的曲线，hibert曲线就是其中的一种，它在边长n = 2,4,8的图上的索引效果如下：<br><img src="/images/2018_10_10_滴滴_2.png" alt=""></p><p>以边长为2的图像举例，左下角的方格编号为1，左上角为2，右上角为3，右下角为4，其余图像也可以一次找到遍历网格的顺序。<br>下面我们希望给定任何边长为2的乘方的网格矩形，给出基于Hilbert曲线索引的网格顺序，全部以左下角第一个被索引的元素，索引值为1，输出完整矩阵的索引值</p><p><b>输入描述：</b><br>一个数字N（N &lt;= 256）</p><p><b>输出描述：</b><br>一个矩阵，矩阵中包含了每一个元素的索引顺序</p><p><b>样例输入：</b><br>4</p><p><b>样例输出：</b><br>6 7 10 11<br>5 8 9 12<br>4 3 14 13<br>1 2 15 16</p><p><b>思路分析：</b><br>以边长从2到4变换进行分析，边长为2的矩阵定义为矩阵A，边长为4的矩阵定义为矩阵B<br>可以把矩阵B分为4个部分，左下，左上，右上，右下<br>可以发现左上右上两个部分和矩阵A的索引顺序完全一致。<br>左下和右下则是矩阵A的某种转置<br>这个规律也适用于边长从4到8的矩阵变换过程</p><p>在代码中，我定义<code>new_1,new_2,new_3,new_4</code>，分别代表左下、左上、右上、右下的四个矩阵，它们都可以从A变换而来</p><p><code>这道题中有一个关键点，那就是矩阵切片赋值（a = b[::]）后，修改赋值矩阵会使原矩阵变动，这是我之前一直没注意到的</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">N = int(input())</span><br><span class="line">res = [[<span class="number">1</span>]]</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> a &lt; N:</span><br><span class="line">    m,n = len(res), len(res[<span class="number">0</span>])</span><br><span class="line">    new_1 = list(zip(*res[::<span class="number">-1</span>]))[::<span class="number">-1</span>]</span><br><span class="line">    new_1 = list(map(list,new_1))</span><br><span class="line"></span><br><span class="line">    new_2 = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            new_2[i][j] = res[i][j] + a*a</span><br><span class="line"></span><br><span class="line">    new_3 = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            new_3[i][j] = res[i][j] + <span class="number">2</span>*a*a</span><br><span class="line"></span><br><span class="line">    new_4 = list(zip(*res))</span><br><span class="line">    new_4 = list(map(list,new_4))</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> new_4:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(row)):</span><br><span class="line">            row[i] += <span class="number">3</span> * a*a</span><br><span class="line">    <span class="comment"># 合并矩阵</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(new_1)):</span><br><span class="line">        new_1[i].extend(new_4[i])</span><br><span class="line">        new_2[i].extend(new_3[i])</span><br><span class="line">    new_2.extend(new_1)</span><br><span class="line">    <span class="comment"># 将新矩阵赋值给res，重新迭代</span></span><br><span class="line">    res = new_2</span><br><span class="line">    a *= <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> res:</span><br><span class="line">    print(<span class="string">' '</span>.join(map(str,row)))</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 思维提升 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018.9.27 小米笔试</title>
      <link href="/2018/10/15/2018-9-27-%E5%B0%8F%E7%B1%B3%E7%AC%94%E8%AF%95/"/>
      <url>/2018/10/15/2018-9-27-%E5%B0%8F%E7%B1%B3%E7%AC%94%E8%AF%95/</url>
      <content type="html"><![CDATA[<p>总结：共两道题，全部AC，出题人抄的leetcode原题，这个出题水平有待提高呀<br><a id="more"></a></p><h2 id="1-厨艺大赛奖金（AC）"><a href="#1-厨艺大赛奖金（AC）" class="headerlink" title="1. 厨艺大赛奖金（AC）"></a>1. 厨艺大赛奖金（AC）</h2><p>小米食堂每年都会举办一次厨艺大赛，假设参赛的厨师一共有n位(n &lt; 1000)，比赛结束后没有公布评分，但是每位厨师只能看到与自己相邻的厨师里评分比自己低的评分。<br>比赛结束后发奖金，每位厨师最少会得到1K的奖金，另外，如果一个厨师发现自己的奖金数量没有高于比自己评分低的厨师的奖金，就会不满意。作为比赛组织法，小米食堂至少需要发放多少奖金才能让所有厨师满意。</p><p><b>输入描述：</b><br>每行n+1个整数<br>第一个整数代表厨师的总人数<br>后n个整数分别代表每个厨师的得分</p><p><b>输出描述：</b><br>一个数字<br>代表至少需要发放的奖金数量（K为单位）</p><p><b>样例输入：</b><br>10 60 76 66 76 85 55 61 71 84 62</p><p><b>样例输出：</b><br>20</p><p><b>解释：__</b>位厨师实际发放奖金为：<br>1 2 1 2 3 1 2 3 4 1</p><p><b>思路分析：</b><br>这是leetcode上的一道原题，candy problem<br><a href="https://leetcode.com/problems/candy/description/" target="_blank" rel="noopener">https://leetcode.com/problems/candy/description/</a><br>最初我做这道题的时候用的one pass solution，虽然通过了，但是我自己写的代码太丑了，情况考虑得太复杂，其实很多可以合并。<br>这里采用更加标准的贪心思想来解决</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">data = list(map(int, input().split()))</span><br><span class="line">nums = data[<span class="number">1</span>:]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">candy</span><span class="params">(ratings)</span>:</span></span><br><span class="line">    n = len(ratings)</span><br><span class="line">    candy = [<span class="number">1</span>] * n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">        <span class="keyword">if</span> ratings[i] &gt; ratings[i<span class="number">-1</span>]:</span><br><span class="line">            candy[i] = candy[i<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> ratings[i] &gt; ratings[i+<span class="number">1</span>] <span class="keyword">and</span> candy[i] &lt;= candy[i+<span class="number">1</span>]:</span><br><span class="line">            candy[i] = candy[i+<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum(candy)</span><br><span class="line">print(candy(nums))</span><br></pre></td></tr></table></figure><h2 id="2-扑克牌四则运算-AC"><a href="#2-扑克牌四则运算-AC" class="headerlink" title="2. 扑克牌四则运算(AC)"></a>2. 扑克牌四则运算(AC)</h2><p>现在有一幅扑克牌，去掉大小王。随机选出4张牌，可以任意改变扑克牌的顺序，并填入+-*/四个运算符，(除法按整除计算)。计算过程中不会出现浮点数，问是否能求值得到给定的数m。</p><p><b>输入描述：</b><br>一共两行<br>第一行四个数字，空格分割，代表扑克牌的数字（J,Q,K分别为11,12,13）<br>第二行一个数字，代表m</p><p><b>输出描述：</b><br>可以输出1<br>否则输出0</p><p><b>样例输入：</b><br>13 13 13 13<br>24</p><p><b>样例输出：</b><br>0</p><p><b>思路分析：</b><br>这又是leetcode上的原题，24点游戏，只不过leetcode上固定求值为24<br>因为只有4个数字，显然可以暴力计算所有的结果，这里使用了python种Itertools库中的一个函数，直接获得所有运算符可能的组合方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">read = <span class="keyword">lambda</span> : list(map(int,input().split()))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(self, nums, m)</span>:</span></span><br><span class="line">        Ops = list(itertools.product([<span class="string">'+'</span>,<span class="string">'-'</span>,<span class="string">'*'</span>,<span class="string">'//'</span>], repeat=<span class="number">3</span>))</span><br><span class="line">        <span class="keyword">for</span> ns <span class="keyword">in</span> set(itertools.permutations(nums)):</span><br><span class="line">            <span class="keyword">for</span> ops <span class="keyword">in</span> Ops:</span><br><span class="line">                result = str(ns[<span class="number">0</span>]) + ops[<span class="number">0</span>] + str(ns[<span class="number">1</span>]) + ops[<span class="number">1</span>] + str(ns[<span class="number">2</span>]) + ops[<span class="number">2</span>] + str(ns[<span class="number">3</span>])</span><br><span class="line">                <span class="keyword">if</span> eval(result) == m: <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">nums = read()</span><br><span class="line">m = int(input())</span><br><span class="line">p = Solution()</span><br><span class="line">print(int(p.solve(nums, m)))</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 思维提升 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018.10.9 好未来笔试</title>
      <link href="/2018/10/15/2018-10-9-%E5%A5%BD%E6%9C%AA%E6%9D%A5%E7%AC%94%E8%AF%95/"/>
      <url>/2018/10/15/2018-10-9-%E5%A5%BD%E6%9C%AA%E6%9D%A5%E7%AC%94%E8%AF%95/</url>
      <content type="html"><![CDATA[<p>总结：共3道算法题，全部AC，3道题目都很麻烦，但仿佛测试数据强度很低，我所担心的溢出什么的全都没发生。<br><a id="more"></a></p><h2 id="1-细胞分裂（AC）"><a href="#1-细胞分裂（AC）" class="headerlink" title="1. 细胞分裂（AC）"></a>1. 细胞分裂（AC）</h2><p>小明是一个生物学家，最近他在做一份关于细胞研究的工作。他进行了若干次实验<br>第一次实验开始，试管里有1个细胞。每一秒1个细胞会分裂成k个细胞，并且会由于某些未知原因，还会额外产生b个细胞。即，如果在某一秒的开始试管内有x个细胞，那么在这一秒的结束时刻，试管中就会有<strong>kx + b</strong>个细胞。<br>实验结果表示，在n秒结束的那一刻，试管中一共有<strong>z</strong>个细胞。<br>第二次实验时，小明给试管中放入<strong>t</strong>个细胞，他想知道至少经过多少秒后，试管中可以至少有z个细胞(按照第一次试验细胞分裂的规律)。</p><p><b>输入描述：</b><br>一行4个整数 k, b, n, t，用空格隔开，含义如题所述<br>满足 1 &lt;= k, n, b, t &lt;= 10^6.</p><p><b>输出描述：</b><br>一个整数，代表最少需要的时间</p><p><b>样例输入：</b><br>1 1 1 1</p><p><b>样例输出：</b><br>1</p><p><b>样例输入：</b><br>2 2 3 3</p><p><b>样例输出：</b><br>3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter, defaultdict, deque</span><br><span class="line">read = <span class="keyword">lambda</span>: list(map(int,input().split()))</span><br><span class="line"></span><br><span class="line">k,b,n,t = read()</span><br><span class="line">z = <span class="number">1</span> <span class="comment"># 计算z的数量</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    z = k*z + b</span><br><span class="line"></span><br><span class="line">time = <span class="number">0</span> <span class="comment"># 模拟过程</span></span><br><span class="line"><span class="keyword">while</span> t &lt; z:</span><br><span class="line">    t = k*t + b</span><br><span class="line">    time += <span class="number">1</span></span><br><span class="line">print(time)</span><br></pre></td></tr></table></figure><h2 id="2-首尾相同的数字（AC）"><a href="#2-首尾相同的数字（AC）" class="headerlink" title="2. 首尾相同的数字（AC）"></a>2. 首尾相同的数字（AC）</h2><p>小明非常喜欢和区间有关的问题。<br>这次他有一对数字 l,r。小明想找出有多少个数字x (l &lt;= x &lt;= r)， 满足x的十进制表示的第一位数字和最后一位数字相等。x不含前导0，除了数字0本身。<br>比如 989， 2， 1001，就是满足条件的数字，但是 49, 10, 972都不满足条件。<br>请你帮小明计算出结果</p><p><b>输入描述：</b><br>一行两个数字l , r，用空格隔开<br>满足 1 &lt;= l &lt;= r &lt;= 10 ^ 18</p><p><b>输出描述：</b><br>一个整数，满足条件的数字个数</p><p><b>样例输入：</b><br>1 10</p><p><b>样例输出：</b><br>9</p><p><b>样例输入：</b><br>88 100</p><p><b>样例输出：</b><br>2</p><p><b>思路分析：</b><br>我是用helper(num)函数来计算1,num中有多少个满足条件的数<br>然后 helper(r) - helper(l) + int(l is 满足条件)得出结果<br>我们首先发现这样一个规律：<br>1位数： 9个<br>2位数： 9个<br>3位数： 90个 （固定住左右两边，中间有0-9，共10种取法）<br>4位数： 900个 （中间有00-99，共100种取法）<br>依次类推…<br>那么假设对于一个8位数  num = 32344325<br>我们可以先计算小于8位数时的满足条件的数的总数，即<code>res += 9+9+90+900+...</code><br>然后根据num的首位val，这里val = 3，从1开始向上分析直至val-1，这一段是没有任何数字丢失的，我们完全可以计算。中间有6位数字在变动。所以有10^6种取法。<code>res += (val-1) * 10^6</code><br>最后判断首位为3的情况，将首位固定为3，能有30000003 - 32344313是确保能取到的<br>所以 <code>res += int(中间6位)</code>， 最后一个32344323能否取到取决于本身最后一位是否大于3，这里大于所以最后 <code>res += 1</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter, defaultdict, deque</span><br><span class="line">read = <span class="keyword">lambda</span>: list(map(int,input().split()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用来存储发现的规律</span></span><br><span class="line">rec = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">10</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">18</span>): rec.append(rec[<span class="number">-1</span>]*<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">l,r = read()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="comment"># 3位数以下很简单，直接处理即可</span></span><br><span class="line">    <span class="keyword">if</span> num &lt; <span class="number">10</span>: <span class="keyword">return</span> num</span><br><span class="line">    <span class="keyword">if</span> num &lt; <span class="number">100</span>: <span class="keyword">return</span> <span class="number">9</span> + num // <span class="number">11</span></span><br><span class="line">    l = len(str(num))</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(l<span class="number">-1</span>):</span><br><span class="line">        res += <span class="number">9</span> * rec[i]</span><br><span class="line">    val = int(str(num)[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(val - <span class="number">1</span>):</span><br><span class="line">        res += rec[l<span class="number">-1</span>]</span><br><span class="line">    val1 = int(str(num)[<span class="number">1</span>:<span class="number">-1</span>])</span><br><span class="line">    res += val1</span><br><span class="line">    <span class="keyword">if</span> int(str(num)[<span class="number">-1</span>]) &gt;= val: res += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">val1 = helper(l)</span><br><span class="line">val2 = helper(r)</span><br><span class="line">val = val2 - val1</span><br><span class="line">s = str(l)</span><br><span class="line"><span class="keyword">if</span> s[<span class="number">0</span>] == s[<span class="number">-1</span>]: val += <span class="number">1</span></span><br><span class="line">print(val)</span><br></pre></td></tr></table></figure><h2 id="3-序列递增（AC）"><a href="#3-序列递增（AC）" class="headerlink" title="3. 序列递增（AC）"></a>3. 序列递增（AC）</h2><p>小明又找到了一个序列，包含n个整数。<br>小明希望你在这个序列中找出一个最长的子串(连续的)，可以改变其中最多一个整数，使这个子串是严格递增的。你需要输出这个最长字段的长度。</p><p><b>输入描述：</b><br>第一行一个整数n,表示序列中数字的个数<br>第二行n个整数x[i]，用空格分开</p><p><b>输出描述：</b><br>一个整数，满足条件的数字个数</p><p><b>样例输入：</b><br>2<br>3 6</p><p><b>样例输出：</b><br>2</p><p><b>样例输入：</b><br>3<br>7 1 9</p><p><b>样例输出：</b><br>3</p><p><b>思路分析：</b><br>首先我将所有上升的序列段全部分别保存了下来，两个两个的分析，看两个是否能通过改变第一个序列的结尾或者改变第二个序列的开头来进行合并</p><p>特殊case是第二个序列长度为1，可能可以再和第三个序列合并，我写得太复杂了，不知道有没有更优解！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter, defaultdict, deque</span><br><span class="line">read = <span class="keyword">lambda</span>: list(map(int,input().split()))</span><br><span class="line"></span><br><span class="line">n = int(input())</span><br><span class="line">a = read()</span><br><span class="line"><span class="keyword">if</span> n &lt;= <span class="number">2</span>: print(n)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = []</span><br><span class="line">    rec = [a[<span class="number">0</span>]]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">if</span> a[i] &gt; a[i<span class="number">-1</span>]:</span><br><span class="line">            rec.append(a[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p.append(rec)</span><br><span class="line">            rec = [a[i]]</span><br><span class="line">    <span class="keyword">if</span> rec: p.append(rec)</span><br><span class="line"></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(p)<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> len(p[i+<span class="number">1</span>]) == <span class="number">1</span> <span class="keyword">and</span> i+<span class="number">2</span> &lt; len(p):</span><br><span class="line">            <span class="keyword">if</span> p[i][<span class="number">-1</span>] &lt; p[i+<span class="number">2</span>][<span class="number">0</span>] - <span class="number">1</span>:</span><br><span class="line">                res = max(res, len(p[i]) + <span class="number">1</span> + len(p[i+<span class="number">2</span>]))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(p[i]) == <span class="number">1</span>:</span><br><span class="line">            res = max(res, <span class="number">1</span> + len(p[i+<span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> p[i][<span class="number">-2</span>] &lt; p[i+<span class="number">1</span>][<span class="number">0</span>] - <span class="number">1</span> <span class="keyword">or</span> (len(p[i+<span class="number">1</span>]) &gt; <span class="number">1</span> <span class="keyword">and</span> p[i][<span class="number">-1</span>] &lt; p[i+<span class="number">1</span>][<span class="number">1</span>]<span class="number">-1</span>):</span><br><span class="line">                res = max(res, len(p[i]) + len(p[i+<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    res = max(res, len(p[<span class="number">-1</span>]) + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> res &gt; n: print(n)</span><br><span class="line">    <span class="keyword">else</span>: print(res)</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 思维提升 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018.10.9 美团笔试</title>
      <link href="/2018/10/15/2018-10-9-%E7%BE%8E%E5%9B%A2%E7%AC%94%E8%AF%95/"/>
      <url>/2018/10/15/2018-10-9-%E7%BE%8E%E5%9B%A2%E7%AC%94%E8%AF%95/</url>
      <content type="html"><![CDATA[<p>总结：共两道算法题（1TLE, 1AC），题型比较有意思，美团还是很有东西的！<br><a id="more"></a></p><h2 id="1-外卖满减（36-passed-TLE）"><a href="#1-外卖满减（36-passed-TLE）" class="headerlink" title="1. 外卖满减（36% passed, TLE）"></a>1. 外卖满减（36% passed, TLE）</h2><p>你打开美了么外卖，选择了一家店，你手里有一张满<strong>X</strong>元减10元的券，店里总共有n种菜，第i种菜一份需要<strong>A[i]</strong>元，因为你不想吃太多份同一种菜，所以每种菜，你最多只能点一份，现在问你最少需要选择多少元的菜才能使用这张券？</p><p><b>输入描述：</b><br>第一行两个正整数n和x，分别表示菜品数量和券的最低使用价格。（1&lt;=n&lt;=100， 1&lt;=X&lt;=10000）<br>接下来一行包括n个整数，第i个整数表示第i个菜的价格(1 &lt;= A[i] &lt;= 100)</p><p><b>输出描述：</b><br>一个整数，表示最少需要选择多少元的菜才能使用这张满X元减10元的券，题目保证有解。</p><p><b>样例输入：</b><br>5 20<br>18 19 17 6 7</p><p><b>样例输出：</b><br>23</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是只过了36%的code, dfs即使剪枝复杂度还是太大了</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter, defaultdict, deque</span><br><span class="line">read = <span class="keyword">lambda</span>: list(map(int,input().split()))</span><br><span class="line"></span><br><span class="line">n,x = read()</span><br><span class="line">a = read()</span><br><span class="line">a.sort(reverse=<span class="keyword">True</span>)</span><br><span class="line">s = [a[<span class="number">-1</span>]] * n <span class="comment"># 后缀和，用作剪枝</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">    s[i] = a[i] + s[i+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(total,index,res=[float<span class="params">(<span class="string">'inf'</span>)</span>])</span>:</span></span><br><span class="line">    <span class="keyword">if</span> total &gt;= x:</span><br><span class="line">        res[<span class="number">0</span>] = min(res[<span class="number">0</span>], total)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> index &lt; n <span class="keyword">and</span> total + s[index] &lt; x: <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(index, n):</span><br><span class="line">        dfs(total + a[i], i+<span class="number">1</span>, res)</span><br><span class="line"></span><br><span class="line">res = [float(<span class="string">'inf'</span>)]</span><br><span class="line">dfs(<span class="number">0</span>,<span class="number">0</span>,res)</span><br><span class="line">print(res[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是事后写的dp，确实是一个01背包问题，但由于错过了提交时间，也不知道真正通过率怎样</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter, defaultdict, deque</span><br><span class="line">read = <span class="keyword">lambda</span>: list(map(int,input().split()))</span><br><span class="line"></span><br><span class="line">n,x = read()</span><br><span class="line">a = read()</span><br><span class="line">v = sum(a) - x <span class="comment"># 代表背包容量</span></span><br><span class="line">dp = [[<span class="number">0</span>]*v <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(v):</span><br><span class="line">        <span class="keyword">if</span> j - a[i] &gt;= <span class="number">0</span>:</span><br><span class="line">            dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j-a[i]] + a[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">        res = max(res, dp[i][j])</span><br><span class="line">print(v-res+x)</span><br></pre></td></tr></table></figure><h2 id="2-数的度序列-AC"><a href="#2-数的度序列-AC" class="headerlink" title="2. 数的度序列(AC)"></a>2. 数的度序列(AC)</h2><p>在图论中，树是一种简单无向图，其中任意两个顶点间存在唯一一条简单路径，或者说只要没有回路的简单连通图就是树。</p><p>在一张简单图中，一个顶点的度数是与其相关联的边的条数，或者说是其邻居的数目。现在给出一个整数序列，你需要判断它是否是某一颗树的度序列</p><p><b>输入描述：</b><br>用例包含多组数据；<br>第一行一个正整数T，表示数据组数<br>对于每一组数据，第一行包含一个整数n，表示序列的长短，1 &lt;= n &lt;= 10^5<br>第二行包含n个整数a[i]，a[i]表示第i个顶点的度。 1 &lt;= a[i] &lt;= 10^9</p><p><b>输出描述：</b><br>逐行输出判断结果，如果是某个数的度序列，输出‘Yes’，否则输出’No’</p><p><b>样例输入：</b><br>2<br>6<br>1 1 1 4 2 1<br>4<br>1 2 2 3</p><p><b>样例输出：</b><br>Yes<br>No</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只需要判断度之和是不是边数量的2倍</span></span><br><span class="line"><span class="comment"># 边数量又等于节点数减1</span></span><br><span class="line">t = int(input())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(t):</span><br><span class="line">    n = int(input())</span><br><span class="line">    a = list(map(int, input().split()))</span><br><span class="line">    <span class="keyword">if</span> sum(a) != <span class="number">2</span>*(n<span class="number">-1</span>): print(<span class="string">'No'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'Yes'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 思维提升 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 6 ZigZag Conversion</title>
      <link href="/2018/10/12/Leetcode-6-ZigZag-Conversion/"/>
      <url>/2018/10/12/Leetcode-6-ZigZag-Conversion/</url>
      <content type="html"><![CDATA[<p>将字符串按照Z字型排列成给定的行数，然后从左往右，逐行读取字符<br><a id="more"></a></p><p><img src="/images/leetcode_6.png" alt=""></p><p><b>题意分析：</b><br>按照Z字形读取字符串并输出</p><p><b>思路分析：</b><br>算法题分类中有一种题型叫模拟实现，也就是按照题目给的规则，我们实现算法来模拟过程<br>这道题就属于标准的一种模拟题，有人肯定会疑惑，这道题哪里有模拟嘛，其实你只要这样想，我们现在要读一个字符串，但是要读到不同的位置（行），应该怎么读呢？</p><p>我们对<code>s = &#39;PAYPALISHIRING&#39;, numRows = 4</code>来进行分析，我们直接写出这个字符串中的每一个字符所处的行数，则应该是 <code>12343212343212</code>。发现规律一下就找到了,下一个字符的行数取决于前一个字符的行数，要么+1要么-1，我们定义一个方向dire，向下走是+1，向上走是-1，当走到边界时(level == 0 or level == numRow-1)转向。具体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 64ms, beats 80.44%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(self, s, numRows)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> numRows == <span class="number">1</span>: <span class="keyword">return</span> s</span><br><span class="line">        res = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(numRows)]</span><br><span class="line">        level = <span class="number">0</span></span><br><span class="line">        dire = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> ss <span class="keyword">in</span> s:</span><br><span class="line">            res[level].append(ss)</span><br><span class="line">            <span class="keyword">if</span> level == numRows<span class="number">-1</span> <span class="keyword">or</span> level == <span class="number">0</span>: dire *= <span class="number">-1</span></span><br><span class="line">            level += dire</span><br><span class="line"></span><br><span class="line">        ans = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> ss <span class="keyword">in</span> res:</span><br><span class="line">            ans += <span class="string">''</span>.join(ss)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> implementation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 5 Longest Palindrome Substring</title>
      <link href="/2018/10/12/Leetcode-5-Longest-Palindrome-Substring/"/>
      <url>/2018/10/12/Leetcode-5-Longest-Palindrome-Substring/</url>
      <content type="html"><![CDATA[<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。</p><p>示例 1：<br>输入: “babad”<br>输出: “bab”<br>注意: “aba”也是一个有效答案。<br><a id="more"></a></p><p>示例 2：<br>输入: “cbbd”<br>输出: “bb”</p><p><b>题意分析：</b><br>经典题型，找字符串中最长的回文子串(substring)，子串的定义是要求必须连续的，和子序列（subsequence）是两个不同的东西！</p><p><b>思路分析：</b><br>在我的多篇博客里始终强调，我们解题一定要看数据范围，leetcode上很多题并不会给出数据范围，这其实特别不好，数据的大小完全决定了我们是否可以采取高复杂度的方法。</p><p>这道题s长度不超过1000，显然是在暗示我们O(n^2)的方法是可行的。</p><p>一句题外话：通常这类最长子串，最长子序列问题都是可以用dp来求解的，并且他们的dp定义大多类似，一般为<code>dp[i][j]代表在s[i:j+1]中的所求结果</code>，显然dp[0][n]即为最后所求。</p><p>这道题也是一样，我们定义<code>dp[i][j]代表s[i:j+1]中最长回文子串的长度</code>，那么dp[0][n]即为所求！</p><p><strong>递推式分析：</strong><br>那么<code>dp[i][j]</code>如何变化呢，因为子串要求连续，如果<code>s[i] != s[j]</code>，显然<code>dp[i][j] = 0</code>；<br>如果<code>s[i] == s[j]</code>，我们需要知道中间部分是否也是回文子串，若是，<code>dp[i][j] = 2 + dp[i+1][j-1]</code>，若不是，则<code>dp[i][j] = 0</code></p><p><strong>初始状态分析：</strong><br>显然<code>dp[i][i] = 1</code><br>由于<code>dp[i][j] = 2 + dp[i+1][j-1]</code>需要满足<code>j-1 &gt;= i+1</code>, 即<code>j-i &gt;= 2</code>,所以j == i+1这种情况要单独处理！</p><p>注意这道题实际要求的并不是长度，而是字符串，所以我们使用<code>dp</code>来记录长度，用另一个变量<code>cnt</code>，来记录下标<code>i,j</code>，最后返回<code>s[i:j+1]</code>即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2964ms, beats 26.39%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [[<span class="number">1</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        cnt,start,end = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">if</span> s[i] != s[j]: dp[i][j] = <span class="number">0</span>; <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> j == i+<span class="number">1</span>:<span class="comment"># 单独处理 j == i+1</span></span><br><span class="line">                    dp[i][j] = <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 判断中间子串是否也是回文串</span></span><br><span class="line">                    <span class="keyword">if</span> dp[i+<span class="number">1</span>][j<span class="number">-1</span>] &gt; <span class="number">0</span>:</span><br><span class="line">                        dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>] + <span class="number">2</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j] = <span class="number">0</span></span><br><span class="line">                <span class="comment"># 记录结果</span></span><br><span class="line">                <span class="keyword">if</span> dp[i][j] &gt; cnt:</span><br><span class="line">                    cnt = dp[i][j]</span><br><span class="line">                    start,end = i,j</span><br><span class="line">        <span class="keyword">return</span> s[start:end+<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>你可能会好奇为什么这个算法只beats这么点人。那是因为单从这道题的数据来说，还有着更优的解法。</p><p>也就是依次遍历s中的每一个字符ss，以ss作为回文串的中点向两边扩展，然后记录长度！<br>但是我个人更偏向于第一种解法(dp)，因为这才是这类型题的标准解法，不过实际我第一次做的时候也是采用的这种遍历的方法。这里给出代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getPalinLength</span><span class="params">(s,i,j)</span>:</span></span><br><span class="line">            <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; len(s) <span class="keyword">and</span> s[i] == s[j]:</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> (i+<span class="number">1</span>, j-i<span class="number">-1</span>)</span><br><span class="line">        </span><br><span class="line">        start,cnt = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            s1, l = getPalinLength(s,i,i)</span><br><span class="line">            <span class="keyword">if</span> l &gt; cnt:</span><br><span class="line">                cnt = l</span><br><span class="line">                start = s1</span><br><span class="line">            s2, l = getPalinLength(s,i,i+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> l &gt; cnt:</span><br><span class="line">                cnt = l</span><br><span class="line">                start = s2</span><br><span class="line">        <span class="keyword">return</span> s[start:start+cnt]</span><br></pre></td></tr></table></figure><p>其实还有更优的解法，但是太累了，不想写了！</p>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dp </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 4 Median of Two Sorted Arrays</title>
      <link href="/2018/10/12/Leetcode-4-Median-of-Two-Sorted-Arrays/"/>
      <url>/2018/10/12/Leetcode-4-Median-of-Two-Sorted-Arrays/</url>
      <content type="html"><![CDATA[<p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。<br>请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。<br>你可以假设 nums1 和 nums2 不同时为空。<br><a id="more"></a><br>示例 1:<br>nums1 = [1, 3]<br>nums2 = [2]<br>中位数是 2.0</p><p>示例 2:<br>nums1 = [1, 2]<br>nums2 = [3, 4]<br>中位数是 (2 + 3)/2 = 2.5</p><p><b>题意分析:</b><br>在两个有序数组中寻找中位数，关键要求时间复杂度为0(log(m+n))<br>在第一次见到这个题的时候，我真是惊呆了，当时我还是个小白，没想到这道题居然能有这么巧妙的解法，光看懂答案就花了不知道多少时间。</p><p><b>思路分析：</b><br>我们知道中位数的定义是整个数组的最中间的数，换句话说，以中位数为界，可以将数组分为两个长度相等的部分。关键也就在此，例如对于两个有序数组，一个长度为3，一个长度5，那么我们知道按中位数划分后两边的数组长度应该都为4，并且满足左边数组的最大值要小于等于右边数组的最小值。</p><p>根据这个分析，我们只需要找出左边数组的4个数有几个是从第一个数组里面获得的即可。<br>例如我们假定左边数组的4个数中有<code>i个数</code>是从第一个数组中获得，那么则有<code>4-i个数</code>从第二个数组中获得。我们只需要判断 <code>max(nums1[i-1], nums2[4-i-1])</code>（左边数组的最大值）是否小于等于 <code>min(nums1[i], nums1[4-i])</code>（右边数组的最小值），如果满足上述式子，则说明我们成功找到了这个分界点，则中位数可求（要根据长度奇偶来分别计算）！</p><p>我们在寻找具体的<code>i</code>的时候使用二分法，由于<code>i</code>代表的意义为从第一个数组中拿多少数，所以<code>i</code>的最小值为<code>0</code>，最大值为 <code>min(n, (m+n)//2)</code>，所以是满足复杂度为0(log(m+n))这个条件的。</p><p>另一个关键点，我们知道二分法需要不停的变换上下界，那么在这里如果不满足上述条件，<code>lo</code>和<code>hi</code>应该怎样变化呢？关键在于<code>nums[i-1]</code>，如果是<code>nums[i-1] &gt; 右边的最小值</code>，说明我们的<code>i</code>已经选的太大了，故<code>hi = mid</code>；反之，则说明我们的<code>i</code>选的太小了，导致<code>4-i</code>太大了，故<code>lo = mid + 1</code>。</p><p>当然在具体判断条件时可能会出现数组越界的情况，所以实际写代码的时候需要用到一点技巧来处理！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 68ms, beats 48.51%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        n, m = len(nums1), len(nums2)</span><br><span class="line">        t = (m+n) // <span class="number">2</span></span><br><span class="line">        l, r = <span class="number">0</span>, t</span><br><span class="line">        inf = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            <span class="comment"># index1代表从nums1中拿的数量，index2代表从nums2中拿的数量</span></span><br><span class="line">            <span class="comment"># 若数组长度都不够拿的数量，就直接跳过</span></span><br><span class="line">            index1 = (l+r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> index1 &gt; n:</span><br><span class="line">                r = index1; <span class="keyword">continue</span></span><br><span class="line">            index2 = t - index1</span><br><span class="line">            <span class="keyword">if</span> index2 &gt; m:</span><br><span class="line">                l = index1+<span class="number">1</span>; <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 处理数组越界的情况</span></span><br><span class="line">            <span class="comment"># 可能会出现一个都不从nums1里面拿，此时index1 = 0</span></span><br><span class="line">            <span class="comment"># 也或者nums1的所有数都要拿，此时 index1 = n</span></span><br><span class="line">            l1 = nums1[index1<span class="number">-1</span>] <span class="keyword">if</span> <span class="number">0</span> &lt;= index1<span class="number">-1</span> &lt; n <span class="keyword">else</span> -inf</span><br><span class="line">            r1 = nums1[index1] <span class="keyword">if</span> <span class="number">0</span> &lt;= index1 &lt; n <span class="keyword">else</span> inf</span><br><span class="line">            l2 = nums2[index2<span class="number">-1</span>] <span class="keyword">if</span> <span class="number">0</span> &lt;= index2<span class="number">-1</span> &lt; m <span class="keyword">else</span> -inf</span><br><span class="line">            r2 = nums2[index2] <span class="keyword">if</span> <span class="number">0</span> &lt;= index2 &lt; m <span class="keyword">else</span> inf</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 满足条件后分奇偶进行计算</span></span><br><span class="line">            <span class="keyword">if</span> max(l1,l2) &lt;= min(r1,r2):</span><br><span class="line">                <span class="keyword">if</span> (n+m) % <span class="number">2</span> != <span class="number">0</span>: <span class="keyword">return</span> min(r1,r2)</span><br><span class="line">                <span class="keyword">return</span> (max(l1,l2) + min(r1,r2)) / float(<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">elif</span> l1 &gt; min(r1,r2):</span><br><span class="line">                r = index1</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = index1 + <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 3 Longest Substring Without Repeating Characters</title>
      <link href="/2018/10/09/Leetcode-3-Longest-Substring-Without-Repeating-Characters/"/>
      <url>/2018/10/09/Leetcode-3-Longest-Substring-Without-Repeating-Characters/</url>
      <content type="html"><![CDATA[<p>给定一个字符串，找出不含有重复字符的最长子串的长度。<br>示例 1:<br>输入: “abcabcbb”<br>输出: 3<br>解释: 无重复字符的最长子串是 “abc”，其长度为 3。<br><a id="more"></a></p><p>示例 2:<br>输入: “bbbbb”<br>输出: 1<br>解释: 无重复字符的最长子串是 “b”，其长度为 1。</p><p>示例 3:<br>输入: “pwwkew”<br>输出: 3<br>解释: 无重复字符的最长子串是 “wke”，其长度为 3。<br>     请注意，答案必须是一个子串，”pwke” 是一个子序列 而不是子串。</p><p><b>题意分析：</b><br>在一个字符串中找最长子串(substring)，我们需要知道子串是连续的，而子序列(subsequence)是可以不连续的，这是两个不同的定义</p><p><b>思路分析：</b><br>通常对于这种在字符串中寻找最长XX的问题，都是使用双指针法。</p><p>我们首先固定左边，然后第二个指针向右遍历，使用一个空间记录我们已经访问过的元素，当第二个指针遍历到某个记录过的元素即停止，记录一次长度。</p><p>然后第一个指针向右移动，将遍历过的元素从记录中删除，直到完全删除掉第二个指针指向的元素为止。</p><p>例如对于示例1中的 ‘abcabcbb’，过程如图所示(只截取了一部分，后面同理)：<br><img src="/images/leetcode_3_1.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 176ms, beats 18.11% (最初写的弱智解法反而运行时间更低，可能是初始化Counter()有点费时间)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        i,j = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="comment"># 使用d作为记录，等价于图中的vis</span></span><br><span class="line">        d = collections.Counter()</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(s):</span><br><span class="line">            <span class="keyword">while</span> j &lt; len(s) <span class="keyword">and</span> s[j] <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                d[s[j]] += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            res = max(res, j - i)</span><br><span class="line">            <span class="keyword">if</span> j &gt;= len(s): <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; len(s) <span class="keyword">and</span> s[j] <span class="keyword">in</span> d:</span><br><span class="line">                d[s[i]] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> d[s[i]] == <span class="number">0</span>: <span class="keyword">del</span> d[s[i]]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> two pointers </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 2 Add Two Numbers</title>
      <link href="/2018/10/09/Leetcode-2-Add-Two-Numbers/"/>
      <url>/2018/10/09/Leetcode-2-Add-Two-Numbers/</url>
      <content type="html"><![CDATA[<p>给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。<br>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><blockquote><p>example：<br>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807<br><a id="more"></a></p></blockquote><p><b>题意分析：</b><br>用两个非空链表表示两个数字，然后将这两个数字作加法，最后所求结果也以链表形式表示</p><p><b>思路分析：</b><br>这道题十分友好，因为我们作加法需要从个位开始计算，这道题直接将个位就放在链表的头部，方便我们计算。</p><p>唯一要注意的点就是考虑进位的问题，我们使用一个flag来表示是否要进位，初始为0</p><p>有个小技巧，当l1和l2长度不相等时，我们可以默认长度不够的那一段全都是0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 68ms, beats 95.45%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="comment"># 表示进位</span></span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        <span class="comment"># ret存储返回结果</span></span><br><span class="line">        ret = head = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 以长的为标准</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2:</span><br><span class="line">            <span class="comment"># 长度不够的按0算</span></span><br><span class="line">            val1 = l1.val <span class="keyword">if</span> l1 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            val2 = l2.val <span class="keyword">if</span> l2 <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            val = (val1 + val2 + flag) % <span class="number">10</span></span><br><span class="line">            head.next = ListNode(val)</span><br><span class="line">            head = head.next</span><br><span class="line">            flag = (val1 + val2 + flag) // <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> l1: l1 = l1.next</span><br><span class="line">            <span class="keyword">if</span> l2: l2 = l2.next</span><br><span class="line">        <span class="comment"># 考虑l1 = [5], l2=[5]这种情况，循环结束后还有进位没有处理，所以单独处理</span></span><br><span class="line">        <span class="keyword">if</span> flag == <span class="number">1</span>: head.next = ListNode(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ret.next</span><br></pre></td></tr></table></figure><p>(trick: 我们也可以分别把每个链表中的数字真正读出来，然后做加法，最后再转成成链表的形式)</p>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> implementation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 1 Two Sum</title>
      <link href="/2018/10/09/Leetcode-1-Two-Sum/"/>
      <url>/2018/10/09/Leetcode-1-Two-Sum/</url>
      <content type="html"><![CDATA[<p>给定一个数组nums，一个目标值target，在数组找两个数满足这两个数的和为target。<br>返回这两个数在nums中的下标。</p><blockquote><p>example:<br>nums = [2,7,11,15]<br>target = 9<br>return [0,1]<br><a id="more"></a></p></blockquote><p><b>题意分析：</b><br>在数组中寻找两个数a,b，使得a+b = target，返回a,b的下标</p><p><b>思路分析：</b>&gt;<br>这是一道经典的在数组中找和为定值的题目。通常这种题目有以下几种解法：</p><ol><li>先将数组进行排序，然后用双指针遍历。（time: O(nlogn), space: O(1)）</li><li>将遍历过的数a全部记录下来，然后对正在遍历的数b进行判断，判断target - b是否已经遍历过。（time: O(n), space: O(n)）</li></ol><p>以上两种解法同样适用于找a+b+c=target的问题（3Sum），只是具体操作时会有一点不同。</p><p>再来看这道题，因为我们需要返回下标，如果我们使用第一种方法会将本来的下标打乱（当然你可以新开一个空间专门记录下标，但是这白浪费O(n)的空间，丧失了排序的优势），所以我们直接选择第二种方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 28ms, beats 65.80%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        vis = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> target - nums[i] <span class="keyword">in</span> vis:</span><br><span class="line">                <span class="comment"># 因为题目保证一定有解，所以可以直接返回</span></span><br><span class="line">                <span class="keyword">return</span> [vis[target- nums[i]], i]</span><br><span class="line">            vis[nums[i]] = i</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 920 Number of Music Playlists</title>
      <link href="/2018/10/08/Leetcode-920-Number-of-Music-Playlists/"/>
      <url>/2018/10/08/Leetcode-920-Number-of-Music-Playlists/</url>
      <content type="html"><![CDATA[<p>你的音乐播放器里有 N 首不同的歌，在旅途中，你的旅伴想要听 L 首歌（不一定不同，即允许歌曲重复）。请你为她按如下规则创建一个播放列表：<br>每首歌至少播放一次。<br>一首歌只有在其他 K 首歌播放完之后才能再次播放。<br>返回可以满足要求的播放列表的数量。由于答案可能非常大，请返回它模 10^9 + 7 的结果。</p><blockquote><p>示例 1：<br>输入：N = 3, L = 3, K = 1<br>输出：6<br>解释：有 6 种可能的播放列表。[1, 2, 3]，[1, 3, 2]，[2, 1, 3]，[2, 3, 1]，[3, 1, 2]，[3, 2, 1].<br><a id="more"></a></p></blockquote><blockquote><p>示例 2：<br>输入：N = 2, L = 3, K = 0<br>输出：6<br>解释：有 6 种可能的播放列表。[1, 1, 2]，[1, 2, 1]，[2, 1, 1]，[2, 2, 1]，[2, 1, 2]，[1, 2, 2]</p></blockquote><blockquote><p>示例 3：<br>输入：N = 2, L = 3, K = 1<br>输出：2<br>解释：有 2 种可能的播放列表。[1, 2, 1]，[2, 1, 2]</p></blockquote><p>提示：</p><ol><li>0 &lt;= K &lt; N &lt;= L &lt;= 100</li></ol><p><b>题意分析：</b><br>总共有n首歌，要听l首歌，必须每首歌至少听一遍，若某一首歌需要听多遍的话，其中间的歌曲数量至少为k首。</p><p><b>思路分析：</b><br>在我的很多文中都提到过，看到mod 10^9+7，一定第一时间要想到dp。不说这种题目百分之百是dp，起码在leetcode上的题目基本全是。</p><p>那么怎么去分析呢？这道题一看像一个排列组合问题，熟悉排列组合的人对下面这个式子肯定不陌生<br><img src="/images/leetcode_920.png" alt=""><br>这个式子可以这样描述，在n个人里面挑选m个人，我们从挑不挑得到某个特定人X来考虑。<br>若挑得到，那么我们从剩下的n-1个人中再挑m-1个人。<br>若挑不到，那么我们从剩下的n-1个人中挑m个人。</p><p>这道题也是用类似的思路，我们定义f(n,l,k)为题目所求，则有：<br><code>f(n,l,k) = f(n-1,l-1,k) \* n + f(n,l-1,k) \* (n-k)</code><br>其中<code>f(n-1,l-1,k)</code>代表某个特定的歌只最后出现一次，其余n-1首歌填充了前面l-1个位置，因为有n首不同的歌所以乘n。<br><code>f(n,l-1,k)</code>代表最后出现的某个特定的歌前面已经出现过了，这个最后出现的歌和当前最后k个位置的歌应当不相同，故乘(n-k)。</p><p>递推式已经找到，那么初始状态是什么呢？<br>显然当<code>n==l</code>时，则就是一个全排列，即为n!<br>当<code>n &gt; l or k &gt; n</code>时，都不存在解，故为0</p><p><strong>注意到在递推式中k其实始终无变化，所以实际定义dp时k可以省去</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numMusicPlaylists</span><span class="params">(self, n, l, k)</span>:</span></span><br><span class="line">        mod = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        <span class="comment"># fib[n-1] = n!</span></span><br><span class="line">        fib = list(range(<span class="number">1</span>,<span class="number">101</span>))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(fib)):</span><br><span class="line">            fib[i] *= fib[i<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        dp = [[<span class="number">0</span>]*(l+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i,l+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i == j: dp[i][j] = fib[i<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">elif</span> i &lt; k: <span class="keyword">continue</span> <span class="comment"># 关键，否则(i-k) &lt; 0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] * i + dp[i][j<span class="number">-1</span>] * (i-k)</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>] % mod</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 919 Complete Binary Tree Inserter</title>
      <link href="/2018/10/08/Leetcode-919-Complete-Binary-Tree-Inserter/"/>
      <url>/2018/10/08/Leetcode-919-Complete-Binary-Tree-Inserter/</url>
      <content type="html"><![CDATA[<p>完全二叉树是每一层（除最后一层外）都是完全填充（即，结点数达到最大）的，并且所有的结点都尽可能地集中在左侧。<br>设计一个用完全二叉树初始化的数据结构 CBTInserter，它支持以下几种操作：<br>CBTInserter(TreeNode root) 使用头结点为 root 的给定树初始化该数据结构；<br>CBTInserter.insert(int v) 将 TreeNode 插入到存在值为 node.val = v  的树中以使其保持完全二叉树的状态，并返回插入的 TreeNode 的父结点的值；<br>CBTInserter.get_root() 将返回树的头结点。<br><a id="more"></a></p><blockquote><p>示例 1：<br>输入：inputs = [“CBTInserter”,”insert”,”get_root”], inputs = [[[1]],[2],[]]<br>输出：[null,1,[1,2]]</p></blockquote><blockquote><p>示例 2：<br>输入：inputs = [“CBTInserter”,”insert”,”insert”,”get_root”], inputs = [[[1,2,3,4,5,6]],[7],[8],[]]<br>输出：[null,3,4,[1,2,3,4,5,6,7,8]]</p></blockquote><p>提示：</p><ol><li>最初给定的树是完全二叉树，且包含 1 到 1000 个结点。</li><li>每个测试用例最多调用 CBTInserter.insert  操作 10000 次。</li><li>给定结点或插入结点的每个值都在 0 到 5000 之间。</li></ol><p><b>题意分析：</b><br>构造一个完全二叉树，实现插入功能并返回父节点的值。</p><p><b>思路分析：</b><br>一说到完全二叉树我们就要想到其最基本的特性，如果将根结点的序号定义为1的话，则对于任意一个结点i，他的左孩子序号为2*i，右孩子序号为2*i+1，想到这一步就可做了。</p><p>我们始终使用一个数组保存每个结点，数组的下标即代表结点的序号。对于给定的初始化树，我们使用bfs方法获得初始数组（如果你对bfs算法不熟，可以参考<a href="https://buptwc.github.io/2018/07/24/bfs%E7%B3%BB%E5%88%97%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">这篇博客</a>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBTInserter</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        self.rootnode = root <span class="comment"># 始终保存根节点，为get_root函数使用</span></span><br><span class="line">        self.node = [TreeNode(<span class="number">0</span>)]<span class="comment"># 初始化一个结点，使根结点在数组中序号为1</span></span><br><span class="line">        Q = collections.deque([root])</span><br><span class="line">        <span class="keyword">while</span> Q:</span><br><span class="line">            node = Q.popleft()</span><br><span class="line">            self.node.append(node)</span><br><span class="line">            <span class="keyword">if</span> node.left: Q.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right: Q.append(node.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, v)</span>:</span></span><br><span class="line">        node = TreeNode(v)</span><br><span class="line">        index = len(self.node) // <span class="number">2</span></span><br><span class="line">        self.node.append(node)</span><br><span class="line">        <span class="comment"># 将结点插入到父节点下</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.node[index].left:</span><br><span class="line">            self.node[index].left = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.node[index].right = node</span><br><span class="line">        <span class="keyword">return</span> self.node[index].val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_root</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.rootnode</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 918 Maximum Sum Circular Subarray</title>
      <link href="/2018/10/08/Leetcode-918-Maximum-Sum-Circular-Subarray/"/>
      <url>/2018/10/08/Leetcode-918-Maximum-Sum-Circular-Subarray/</url>
      <content type="html"><![CDATA[<p>给定一个由整数数组 A 表示的环形数组 C，求 C 的非空子数组的最大可能和。<br>在此处，环形数组意味着数组的末端将会与开头相连呈环状。（形式上，当0 &lt;= i &lt; A.length 时 C[i] = A[i]，而当 i &gt;= 0 时 C[i+A.length] = C[i]）<br>此外，子数组最多只能包含固定缓冲区 A 中的每个元素一次。（形式上，对于子数组 C[i], C[i+1], …, C[j]，不存在 i &lt;= k1, k2 &lt;= j 其中 k1 % A.length = k2 % A.length）</p><blockquote><p>示例 1：<br>输入：[1,-2,3,-2]<br>输出：3<br>解释：从子数组 [3] 得到最大和 3</p></blockquote><a id="more"></a><blockquote><p>示例 2：<br>输入：[5,-3,5]<br>输出：10<br>解释：从子数组 [5,5] 得到最大和 5 + 5 = 10</p></blockquote><blockquote><p>示例 3：<br>输入：[3,-1,2,-1]<br>输出：4<br>解释：从子数组 [2,-1,3] 得到最大和 2 + (-1) + 3 = 4</p></blockquote><blockquote><p>示例 4：<br>输入：[3,-2,2,-3]<br>输出：3<br>解释：从子数组 [3] 和 [3,-2,2] 都可以得到最大和 3</p></blockquote><blockquote><p>示例 5：<br>输入：[-2,-3,-1]<br>输出：-1<br>解释：从子数组 [-1] 得到最大和 -1</p></blockquote><p>提示：</p><ol><li>-30000 &lt;= A[i] &lt;= 30000</li><li>1 &lt;= A.length &lt;= 30000</li></ol><p><b>题意分析：</b><br>这道题是要求数组连续和的最大值，但这里需要把数组看做是一个圆圈。是<a href="https://leetcode.com/problems/maximum-subarray/description/" target="_blank" rel="noopener">leetcode 53 Maximum Subarray</a>的升级版！</p><p><b>思路分析：</b><br>我们可以直接将这个“圆圈”数组看做两个相同数组连接在一起<br><img src="/images/leetcode_918.png" alt=""><br>考虑到56题的情况，我们很容易想到将这道题分成两种情况来解决：<br>第一种情况即最大值就在第一部分中，第二种情况即最大值横跨两个部分但距离不得超过n，n为数组A的长度。分别如下图所示：<br><img src="/images/leetcode_918_1.png" alt=""><br><img src="/images/leetcode_918_2.png" alt=""></p><p>对于第一种情况，我们可以直接按53题的解法做<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">left = [A[<span class="number">0</span>]] * len(A)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(A)):</span><br><span class="line">    left[i] = max(A[i], left[i<span class="number">-1</span>]+A[i])</span><br><span class="line">res = max(left)</span><br></pre></td></tr></table></figure></p><p>对于第二种情况，我们注意到数组一定经过A[-1]，对于某个左边界i，他能产生的最大和为<br>sum(A[i:]) + max(sum(A[n:j-n]) for every j &lt; i+n)<br>显然每次都要找前缀和最大的值，我们使用一个数组将其保存以节省开销。<br>定义s[i] = sum(A[:i+1])<br>定义r_max[i] = max(s[:i+1])<br>则对于某个左边界i，他能产生的最大和为sum(A[i:]) + r_max(i)<br>完整代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubarraySumCircular</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        left = [A[<span class="number">0</span>]] * len(A)</span><br><span class="line">        s = [A[<span class="number">0</span>]] * len(A)</span><br><span class="line">        r_max = [s[<span class="number">0</span>]] * len(A)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(A)):</span><br><span class="line">            left[i] = max(A[i], left[i<span class="number">-1</span>]+A[i])</span><br><span class="line">            s[i] = s[i<span class="number">-1</span>] + A[i]</span><br><span class="line">            r_max[i] = max(s[i], r_max[i<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">        res = max(left)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            res = max(res, s[<span class="number">-1</span>] - s[i] + r_max[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 911 Online Election</title>
      <link href="/2018/09/24/Leetcode-911-Online-Election/"/>
      <url>/2018/09/24/Leetcode-911-Online-Election/</url>
      <content type="html"><![CDATA[<p>在选举中，第 i 张票是在时间为 times[i] 时投给 persons[i] 的。<br>现在，我们想要实现下面的查询函数： TopVotedCandidate.q(int t) 将返回在t时刻主导选举的候选人的编号。<br>在t时刻投出的选票也将被计入我们的查询之中。在平局的情况下，最近获得投票的候选人将会获胜。</p><a id="more"></a><blockquote><p>示例：<br>输入：[“TopVotedCandidate”,”q”,”q”,”q”,”q”,”q”,”q”], [[[0,1,1,0,0,1,0],[0,5,10,15,20,25,30]],[3],[12],[25],[15],[24],[8]]<br>输出：[null,0,1,1,0,0,1]<br>解释：<br>时间为 3，票数分布情况是 [0]，编号为 0 的候选人领先。<br>时间为 12，票数分布情况是 [0,1,1]，编号为 1 的候选人领先。<br>时间为 25，票数分布情况是 [0,1,1,0,0,1]，编号为 1 的候选人领先（因为最近的投票结果是平局）。<br>之后在时间 15、24 和 8 处继续执行 3 个查询。</p></blockquote><p>提示：</p><ol><li>1 &lt;= persons.length = times.length &lt;= 5000</li><li>0 &lt;= persons[i] &lt;= persons.length</li><li>times 是严格递增的数组，所有元素都在 [0, 10^9] 范围中。</li><li>每个测试用例最多调用 10000 次 TopVotedCandidate.q。</li><li>TopVotedCandidate.q(int t) 被调用时总是满足 t &gt;= times[0]。</li></ol><p><b>题意分析：</b><br>给定一系列的时间点，在每个时间点会投出一票，在每个时间点都会有票数最高的人存在，现在有若干次询问，需要我们给询问的时间点票数最高的人</p><p><b>思路：</b><br>显然我们可以将初始给定的每个时间点的得票数最高的人记录下来，对于上面的例子有：<br>Q = {0:0, 5:1, 10:1, 15:0, 20:0, 25:1, 30:0}<br>然后对于问询的时间点t，我们只需要在Q中找到第一个比t小的时间点即可，显然是二分法！<br>由于t会比较大，所以可能存在大量重复问询，所以还需要用到缓存机制！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopVotedCandidate</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, persons, times)</span>:</span></span><br><span class="line">        maxCount = <span class="number">0</span></span><br><span class="line">        d = collections.defaultdict(int)</span><br><span class="line">        self.Q = &#123;&#125;</span><br><span class="line">        self.cache = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(persons)):</span><br><span class="line">            d[persons[i]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> d[persons[i]] &gt;= maxCount:</span><br><span class="line">                maxCount = d[persons[i]]</span><br><span class="line">                self.Q[times[i]] = persons[i]</span><br><span class="line">        self.res = sorted(self.Q.keys())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">q</span><span class="params">(self, t)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> t <span class="keyword">not</span> <span class="keyword">in</span> self.cache:</span><br><span class="line">            index = bisect.bisect_right(self.res, t)</span><br><span class="line">            self.cache[t] = self.Q[self.res[index<span class="number">-1</span>]]</span><br><span class="line">        <span class="keyword">return</span> self.cache[t]</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> Binary search </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 910 Smallest Range II</title>
      <link href="/2018/09/24/Leetcode-910-Smallest-Range-II/"/>
      <url>/2018/09/24/Leetcode-910-Smallest-Range-II/</url>
      <content type="html"><![CDATA[<p>给定一个整数数组 A，对于每个整数 A[i]，我们可以选择 x = -K 或是 x = K，并将 x 加到 A[i] 中。<br>在此过程之后，我们得到一些数组 B。<br>返回 B 的最大值和 B 的最小值之间可能存在的最小差值。<br><a id="more"></a></p><blockquote><p>示例 1：<br>输入：A = [1], K = 0<br>输出：0<br>解释：B = [1]</p></blockquote><blockquote><p>示例 2：<br>输入：A = [0,10], K = 2<br>输出：6<br>解释：B = [2,8]</p></blockquote><blockquote><p>示例 3：<br>输入：A = [1,3,6], K = 3<br>输出：3<br>解释：B = [4,6,3]</p></blockquote><p>提示：</p><ol><li>1 &lt;= A.length &lt;= 10000</li><li>0 &lt;= A[i] &lt;= 10000</li><li>0 &lt;= K &lt;= 10000</li></ol><p><b>题意分析：</b><br>对于每个A[i]，我们需要将其加上k或者减掉k，使得最后数组中的最大最小值最接近</p><p><b>思路：</b><br>初步想法肯定把大的减小，把小的增大，最次也是同时增大或者同时减小，不存在把小的减小反而把大的增大，想到这一步就好做了<br>我们先将A排序，然后将若干个大的减小，剩下的小的增大，但是具体将多少个大的减小呢，这个我们不能确定，所以我们得依次遍历<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallestRangeII</span><span class="params">(self, A, K)</span>:</span></span><br><span class="line">        A.sort()</span><br><span class="line">        <span class="comment"># 初始默认全部加k</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)): A[i] += K</span><br><span class="line">        <span class="comment"># 使用ma,mi保存当前的最大和最小值</span></span><br><span class="line">        ma, mi = A[<span class="number">-1</span>], A[<span class="number">0</span>]</span><br><span class="line">        res = ma - mi</span><br><span class="line">        <span class="comment"># M代表-k的那部分数中的最大值</span></span><br><span class="line">        <span class="comment"># m代表+k的那部分数中的最小值</span></span><br><span class="line">        M,m = ma<span class="number">-2</span>*K,mi</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">            A[i] -= <span class="number">2</span>*K</span><br><span class="line">            ma = max(M, A[i<span class="number">-1</span>])</span><br><span class="line">            mi = min(A[i], m)</span><br><span class="line">            res = min(res, ma - mi)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> greedy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 909 Snakes and Ladders</title>
      <link href="/2018/09/24/Leetcode-909-Snakes-and-Ladders/"/>
      <url>/2018/09/24/Leetcode-909-Snakes-and-Ladders/</url>
      <content type="html"><![CDATA[<p>在一块 N x N 的板子 board 上，从板的左下角开始，每一行交替方向，按从 1 到 N*N 的数字给方格编号。例如，对于一块 6 x 6 大小的板子，可以编号如下：</p><blockquote><p>36 35 34 33 32 31<br>25 26 27 28 29 30<br>24 23 22 21 20 19<br>13 14 15 16 17 18<br>12 11 10 09 08 07<br>01 02 03 04 05 06  </p></blockquote><p>从板子的方块 1 开始（总是在最后一行、第一列）出发。<br>从方块 x 开始，每一次移动都按照以下规则：</p><ol><li>你选择一个目标方块 S，它的编号是 x+1，x+2，x+3，x+4，x+5，或者 x+6，只要这个数字满足 &lt;= N*N。</li><li>如果 S 有一个坡或梯子，你就移动到那个坡或梯子的目的地。否则，你会移动到 S。<br>在 r 行 c 列上的方格里有 “坡” 或 “梯子”；如果 board[r][c] != -1，那个坡或梯子的目的地将会是 board[r][c]。<a id="more"></a>注意，你每次移动最多只能爬过一个坡或梯子一次：就算目的地是另一个坡或梯子的起点，你也不会继续移动。<br>返回达到方格 N*N 所需的最少移动次数，如果不可能，则返回 -1。</li></ol><blockquote><p>输入：[<br>[-1,-1,-1,-1,-1,-1],<br>[-1,-1,-1,-1,-1,-1],<br>[-1,-1,-1,-1,-1,-1],<br>[-1,35,-1,-1,13,-1],<br>[-1,-1,-1,-1,-1,-1],<br>[-1,15,-1,-1,-1,-1]]<br>输出：4<br>解释：<br>首先，从方格 1 [第 5 行，第 0 列] 开始。<br>你决定移动到方格 2，并必须爬过梯子移动到到方格 15。<br>然后你决定移动到方格 17 [第 3 行，第 5 列]，必须爬过坡到方格 13。<br>然后你决定移动到方格 14，且必须通过梯子移动到方格 35。<br>然后你决定移动到方格 36, 游戏结束。<br>可以证明你需要至少 4 次移动才能到达第 N*N 个方格，所以答案是 4。</p></blockquote><p>提示：</p><ol><li>2 &lt;= board.length = board[0].length &lt;= 20</li><li>board[i][j] 介于 1 和 N*N 之间或者等于 -1。</li><li>编号为 1 的方格上没有坡或梯子。</li><li>编号为 N*N 的方格上没有坡或梯子。</li></ol><p><b>题意分析：</b><br>从方格1开始移动，终点为方格N*N。每一次移动有6种选择，例如当前位于方格X上，则下一步可以到方格X+1,X+2,…,X+6上。但若移动到的方格上的值不等于-1，则需跳到这个值对应的方格上，求最少移动次数。<br>在多选择路径上找最小移动次数，显然是bfs方法。每次就像下6个方格中移动，一旦方格值不等于-1就跳到方格值对应的方格（注意别重复计算）。唯一要处理的就是方格的index如何跟board中的下标对应起来了（规律很简单，就是蛇形方格）<br>PS：我对bfs算法在这片博客里有比较详细的介绍，有兴趣的可以参考一下<br><a href="https://buptwc.github.io/2018/07/24/bfs%E7%B3%BB%E5%88%97%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">https://buptwc.github.io/2018/07/24/bfs%E7%B3%BB%E5%88%97%E8%AF%A6%E8%A7%A3/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">snakesAndLadders</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        m,n = len(grid),len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 将index转换成对应的下标</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">transIndex</span><span class="params">(index)</span>:</span></span><br><span class="line">            x,y = index // n, index % n</span><br><span class="line">            <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> y != <span class="number">0</span>: <span class="keyword">return</span> (m<span class="number">-1</span>-x,y<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> (m-x, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> y != <span class="number">0</span>: <span class="keyword">return</span> (m<span class="number">-1</span>-x,n-y)</span><br><span class="line">                <span class="keyword">return</span> (m-x, n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        Q = collections.deque([<span class="number">1</span>])</span><br><span class="line">        level = <span class="number">0</span></span><br><span class="line">        visited = set()</span><br><span class="line">        <span class="keyword">while</span> Q:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(Q)):</span><br><span class="line">                index = Q.popleft()</span><br><span class="line">                <span class="keyword">if</span> index == m*n: <span class="keyword">return</span> level</span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> range(index+<span class="number">1</span>,index+<span class="number">7</span>):</span><br><span class="line">                    <span class="keyword">if</span> x &lt;= m*n:</span><br><span class="line">                        i,j = transIndex(x)</span><br><span class="line">                        <span class="keyword">if</span> grid[i][j] != <span class="number">-1</span>: x = grid[i][j]</span><br><span class="line">                        <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                            visited.add(x)</span><br><span class="line">                            Q.append(x)</span><br><span class="line">            level += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 907 Sum of Subarray Minimums</title>
      <link href="/2018/09/16/Leetcode-907-Sum-of-Subarray-Minimums/"/>
      <url>/2018/09/16/Leetcode-907-Sum-of-Subarray-Minimums/</url>
      <content type="html"><![CDATA[<p>Given an array of integers A, find the sum of min(B), where B ranges over every (contiguous) subarray of A.<br>Since the answer may be large, return the answer modulo 10^9 + 7.</p><blockquote><p>Example 1:<br>Input: [3,1,2,4]<br>Output: 17<br>Explanation: Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4].<br>Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.  Sum is 17.</p></blockquote><p>Note:</p><ol><li>1 &lt;= A.length &lt;= 30000</li><li>1 &lt;= A[i] &lt;= 30000<a id="more"></a></li></ol><p><b>分析：</b><br>首先还是先强调一点，看到这种mod1e9+7的题目，首先要想到的就是dp！<br>那么我们怎样定义dp[i]呢？因为我以前见到过这种题目，所以我知道定义dp[i]为以nums[i]最小的子串的个数，说实话可能对于第一次见的人直接想到这样定义有点难度。<br>如[3,1,2,4]对于“1”来说，子串有[1],[3,1],[1,2],[3,1,2],[1,2,4],[3,1,2,4]，所以dp[1] = 6.</p><p>那么再来思考第二个问题，如何去计算dp[i]呢<br><img src="/images/leetcode_907.jpg" alt=""></p><p>也就是说，我们对于每个A[i]，要分别找到左边和右边第一个比他小的点，以此来确定以A[i]为最小的最长子串<br>例如对于[3,1,4,2,5,3,3,1]中的“2”，我们找到的串就为[4,2,5,3,3]，2左边有1个数，2右边有3个数，所以2作为最小值的串有2*4=8种。读者可以自己检验一下</p><p>那又有一个新的问题，如何对每一个点都找到其左边和右边第一个比他小的点呢？<br>这就要用到stack了，这部分逻辑用文字描述可能有点难度，还是看下面这段代码吧<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找到每个点左边的第一个比该点小的位置，若无则用-1表示</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getIndex</span><span class="params">(A)</span>:</span></span><br><span class="line">    stack = [<span class="number">0</span>]</span><br><span class="line">    left = [<span class="number">-1</span>] * len(A)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(A)):</span><br><span class="line">        <span class="keyword">if</span> A[i] &gt; A[stack[<span class="number">-1</span>]]:</span><br><span class="line">            left[i] = stack[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> A[i] &lt;= A[stack[<span class="number">-1</span>]]: stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack: left[i] = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>: left[i] = stack[<span class="number">-1</span>]</span><br><span class="line">        stack.append(i)</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line"><span class="comment"># example [3,1,2,4]</span></span><br><span class="line"><span class="comment"># getIndex(A) = [-1,-1,1,2]</span></span><br></pre></td></tr></table></figure></p><p>弄明白这两点之后这道题便可解了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumSubarrayMins</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        mod = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        left = [<span class="number">-1</span>] * len(A)</span><br><span class="line">        right = [len(A)] * len(A)</span><br><span class="line">        <span class="comment"># 计算left数组</span></span><br><span class="line">        stack = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(A)):</span><br><span class="line">            <span class="keyword">if</span> A[i] &gt; A[stack[<span class="number">-1</span>]]:</span><br><span class="line">                left[i] = stack[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> A[i] &lt;= A[stack[<span class="number">-1</span>]]: stack.pop()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack: left[i] = <span class="number">-1</span></span><br><span class="line">                <span class="keyword">else</span>: left[i] = stack[<span class="number">-1</span>]</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="comment"># 计算right数组</span></span><br><span class="line">        stack = [len(A)<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> A[i] &gt; A[stack[<span class="number">-1</span>]]:</span><br><span class="line">                right[i] = stack[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> A[i] &lt; A[stack[<span class="number">-1</span>]]: stack.pop()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack: right[i] = len(A)</span><br><span class="line">                <span class="keyword">else</span>: right[i] = stack[<span class="number">-1</span>]</span><br><span class="line">            stack.append(i)</span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            res += A[i] * (i-left[i]) * (right[i]-i)</span><br><span class="line">        <span class="keyword">return</span> res % mod</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dp </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 904 Fruit Into Baskets</title>
      <link href="/2018/09/16/Leetcode-904-Fruit-Into-Baskets/"/>
      <url>/2018/09/16/Leetcode-904-Fruit-Into-Baskets/</url>
      <content type="html"><![CDATA[<p>In a row of trees, the i-th tree produces fruit with type tree[i].<br>You start at any tree of your choice, then repeatedly perform the following steps:<br>Add one piece of fruit from this tree to your baskets.  If you cannot, stop.<br>Move to the next tree to the right of the current tree.  If there is no tree to the right, stop.<br>Note that you do not have any choice after the initial choice of starting tree: you must perform step 1, then step 2, then back to step 1, then step 2, and so on until you stop.<br>You have two baskets, and each basket can carry any quantity of fruit, but you want each basket to only carry one type of fruit each.<br>What is the total amount of fruit you can collect with this procedure?</p><blockquote><p>Example 1:<br>Input: [1,2,1]<br>Output: 3<br>Explanation: We can collect [1,2,1].</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: [0,1,2,2]<br>Output: 3<br>Explanation: We can collect [1,2,2].<br>If we started at the first tree, we would only collect [0, 1].</p></blockquote><blockquote><p>Example 3:<br>Input: [1,2,3,2,2]<br>Output: 4<br>Explanation: We can collect [2,3,2,2].<br>If we started at the first tree, we would only collect [1, 2].</p></blockquote><blockquote><p>Example 4:<br>Input: [3,3,3,1,2,1,1,2,3,3,4]<br>Output: 5<br>Explanation: We can collect [1,2,1,1,2].<br>If we started at the first tree or the eighth tree, we would only collect 4 fruits.</p></blockquote><p>Note:</p><ol><li>1 &lt;= tree.length &lt;= 40000</li><li>0 &lt;= tree[i] &lt; tree.length</li></ol><p><b>分析：</b></p><ol><li>这道题实际上是找到一段最长的距离，使得这段距离内包含的元素只有两种，显然双指针解决，使用一个字典存储已经有的元素及对应的数量。</li><li>对tree[j]分析时，若向字典中加入tree[j]使得字典中元素数量大于2，便开始从左开始删元素，直至字典元素只剩1种，然后将tree[j]加入</li><li>每进行2操作之前需要先比较一次长度，取最大长度作为结果</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">totalFruit</span><span class="params">(self, tree)</span>:</span></span><br><span class="line">        d = collections.defaultdict(int)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        i,j = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(tree):</span><br><span class="line">            <span class="comment"># 将字典大小填充到2</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; len(tree) <span class="keyword">and</span> len(d) &lt; <span class="number">2</span>: </span><br><span class="line">                d[tree[j]] += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 如果继续添加直到字典长度将要变为3的那一刻</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; len(tree) <span class="keyword">and</span> tree[j] <span class="keyword">in</span> d:</span><br><span class="line">                d[tree[j]] += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 保存结果</span></span><br><span class="line">            res = max(res, j-i)</span><br><span class="line">            <span class="keyword">if</span> j &gt;= len(tree): <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 从左删除元素直至字典长度为1</span></span><br><span class="line">            <span class="keyword">while</span> len(d) &gt; <span class="number">1</span> <span class="keyword">and</span> i &lt; len(tree):</span><br><span class="line">                d[tree[i]] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> d[tree[i]] == <span class="number">0</span>: <span class="keyword">del</span> d[tree[i]]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> two pointers </tag>
            
            <tag> sliding window </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 905 Sort Array By Parity</title>
      <link href="/2018/09/16/Leetcode-905-Sort-Array-By-Parity/"/>
      <url>/2018/09/16/Leetcode-905-Sort-Array-By-Parity/</url>
      <content type="html"><![CDATA[<p>Given an array A of non-negative integers, return an array consisting of all the even elements of A, followed by all the odd elements of A.<br>You may return any answer array that satisfies this condition.</p><blockquote><p>Example 1:<br>Input: [3,1,2,4]<br>Output: [2,4,3,1]<br>The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.</p></blockquote><a id="more"></a><p>Note:</p><ol><li>1 &lt;= A.length &lt;= 5000</li><li>0 &lt;= A[i] &lt;= 5000</li></ol><p><b>分析：</b></p><ol><li>要将数组中所有偶数排在奇数前面，并且还不限制顺序，并且长度还不超过5000，已经是特别简单了</li><li>如果使用O(n)的空间，我们可以将偶数全部取出来存一个数组，将奇数全部取出来存一个数组，最后将两个数组合并即可。</li><li>如果使用O(1)的空间，我们就只能做swap，用两个指针，一个指着奇数，一个指着偶数然后交换即可。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># O(1) space</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArrayByParity</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        i,j = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">        <span class="comment"># 使用i记录奇数的位置，然后j往后遍历，找到偶数后进行交换</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(A):</span><br><span class="line">            <span class="keyword">if</span> j &lt; i: j = i</span><br><span class="line">            <span class="keyword">while</span> j &lt; len(A) <span class="keyword">and</span> A[i] % <span class="number">2</span> != <span class="number">0</span> <span class="keyword">and</span> A[j] % <span class="number">2</span> != <span class="number">0</span>: j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j &gt;= len(A): <span class="keyword">break</span></span><br><span class="line">            A[i], A[j] = A[j], A[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 894 All Possible Full Binary Trees</title>
      <link href="/2018/08/26/Leetcode-894-All-Possible-Full-Binary-Trees/"/>
      <url>/2018/08/26/Leetcode-894-All-Possible-Full-Binary-Trees/</url>
      <content type="html"><![CDATA[<p>A full binary tree is a binary tree where each node has exactly 0 or 2 children.<br>Return a list of all possible full binary trees with N nodes.  Each element of the answer is the root node of one possible tree.<br>Each node of each tree in the answer must have node.val = 0.<br>You may return the final list of trees in any order.</p><a id="more"></a><p><img src="/images/leetcode_894.png" alt=""></p><p><b>分析：</b></p><ol><li>显然完全二叉树的节点个数必是奇数，故if N % 2 == 0: return []</li><li>我们定义cache[i]表示i个节点构造出的完全二叉树的所有可能</li><li>如果N = 1，显然只有一种情况</li><li>如果N = 3，显然也只有一种情况</li><li>如果N = 5，如果左孩子为cache[1]，右孩子则为cache[3];如果左孩子为cache[3]，右孩子为cache[1]</li><li>依此类推</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allPossibleFBT</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> N % <span class="number">2</span> == <span class="number">0</span>: <span class="keyword">return</span> []</span><br><span class="line">        cache = &#123;&#125;</span><br><span class="line">        <span class="comment"># 只考虑奇数情况</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N+<span class="number">1</span>)[<span class="number">1</span>::<span class="number">2</span>]:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">1</span>: <span class="comment"># 初始化</span></span><br><span class="line">                cache[<span class="number">1</span>] = [TreeNode(<span class="number">0</span>)]</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            cache[i] = []</span><br><span class="line">            <span class="comment"># j 代表左孩子的数量</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i)[<span class="number">1</span>::<span class="number">2</span>]:</span><br><span class="line">                <span class="keyword">for</span> lkid <span class="keyword">in</span> cache[j]:</span><br><span class="line">                    <span class="keyword">for</span> rkid <span class="keyword">in</span> cache[i<span class="number">-1</span>-j]:</span><br><span class="line">                        node = TreeNode(<span class="number">0</span>)</span><br><span class="line">                        node.left = lkid</span><br><span class="line">                        node.right = rkid</span><br><span class="line">                        cache[i].append(node)</span><br><span class="line">        <span class="keyword">return</span> cache[N]</span><br><span class="line"></span><br><span class="line"><span class="number">20</span> / <span class="number">20</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">136</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 893 Groups of Special-Equivalent Strings</title>
      <link href="/2018/08/26/Leetcode-893-Groups-of-Special-Equivalent-Strings/"/>
      <url>/2018/08/26/Leetcode-893-Groups-of-Special-Equivalent-Strings/</url>
      <content type="html"><![CDATA[<p>You are given an array A of strings.<br>Two strings S and T are special-equivalent if after any number of moves, S == T.<br>A move consists of choosing two indices i and j with i % 2 == j % 2, and swapping S[i] with S[j].<br>Now, a group of special-equivalent strings from A is a non-empty subset S of A such that any string not in S is not special-equivalent with any string in S.<br>Return the number of groups of special-equivalent strings from A.</p><blockquote><p>Example 1:<br>Input: [“a”,”b”,”c”,”a”,”c”,”c”]<br>Output: 3<br>Explanation: 3 groups [“a”,”a”], [“b”], [“c”,”c”,”c”]</p></blockquote><blockquote><p>Example 2:<br>Input: [“aa”,”bb”,”ab”,”ba”]<br>Output: 4<br>Explanation: 4 groups [“aa”], [“bb”], [“ab”], [“ba”]</p></blockquote><a id="more"></a><blockquote><p>Example 3:<br>Input: [“abc”,”acb”,”bac”,”bca”,”cab”,”cba”]<br>Output: 3<br>Explanation: 3 groups [“abc”,”cba”], [“acb”,”bca”], [“bac”,”cab”]</p></blockquote><blockquote><p>Example 4:<br>Input: [“abcd”,”cdab”,”adcb”,”cbad”]<br>Output: 1<br>Explanation: 1 group [“abcd”,”cdab”,”adcb”,”cbad”]</p></blockquote><p>Note:</p><ol><li>1 &lt;= A.length &lt;= 1000</li><li>1 &lt;= A[i].length &lt;= 20</li><li>All A[i] have the same length.</li><li>All A[i] consist of only lowercase letters.</li></ol><p><b>分析：</b></p><ol><li>觉不觉得有点像union find，找“同源”的所有元素将其归为一组，最后看有多少组</li><li>我们如何判断两个字符串是否“相同”呢，根据题目要求，奇数位可以和奇数位交换位置，偶数位可以和偶数位交换位置，那么我们自然想到，只要两个字符串分别在奇数位上和偶数位上的字符组成都相同即可，<code>在这即可分两种思路</code>：<ol><li>使用Counter函数可快速获得，一共26个字母，所以比较两个Counter非常快速，例如’abcd’和’cdab’：<ol><li>‘abcd’：奇数位：{‘a’:1,’c’:1},偶数位：{‘b’:1,’d’:1}</li><li>‘cdab’：奇数位：{‘a’:1,’c’:1},偶数位：{‘b’:1,’d’:1}</li><li>故两者相同</li></ol></li><li>将字符串先排序再比较，因为每个A[i]长度不超过20，所以实际这个可以更快</li></ol></li></ol><p><b>思路1（针对Counter方法）：</b></p><ol><li>我们先默认所有的元素都不“同源”，则应该有len(A)个不同的组</li><li>每次我们遍历到一个字符串，将其和前面所有的字符串进行对比，如果出现同源则将总数减一，且终止比较（否则可能多减，如例4）（虽然实际上我是用的visited来模仿union find的思路）</li></ol><p><b>思路2（针对sort方法）：</b></p><ol><li>直接将排序好的字符串作为key值，最后判断有多少种不同的key</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 思路1,O(m*n^2),n=len(A), m=len(A[i])</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSpecialEquivGroups</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        d = &#123;s:&#123;&#125; <span class="keyword">for</span> s <span class="keyword">in</span> A&#125;</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> A:</span><br><span class="line">            d[s][<span class="number">0</span>] = collections.Counter(s[::<span class="number">2</span>])</span><br><span class="line">            d[s][<span class="number">1</span>] = collections.Counter(s[<span class="number">1</span>::<span class="number">2</span>])</span><br><span class="line">        res = len(A)</span><br><span class="line">        visited = set()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> d[A[i]] == d[A[j]] <span class="keyword">and</span> j <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    visited.add(j)<span class="comment">#同源之后就将其删除，只保留最初的那一个</span></span><br><span class="line">                    res -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="number">34</span> / <span class="number">34</span> test cases passed.</span><br><span class="line">difficulty: easy</span><br><span class="line">Runtime: <span class="number">384</span> ms</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#思路2,O(n*mlogm),n=len(A), m=len(A[i])</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSpecialEquivGroups</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        d = collections.defaultdict(int)</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> A:</span><br><span class="line">            s1 = <span class="string">''</span>.join(sorted(s[::<span class="number">2</span>]))</span><br><span class="line">            s2 = <span class="string">''</span>.join(sorted(s[<span class="number">1</span>::<span class="number">2</span>]))</span><br><span class="line">            d[(s1, s2)] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> len(d)</span><br><span class="line"></span><br><span class="line"><span class="number">34</span> / <span class="number">34</span> test cases passed.</span><br><span class="line">difficulty: easy</span><br><span class="line">Runtime: <span class="number">40</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 892 Surface Area of 3D Shapes</title>
      <link href="/2018/08/26/Leetcode-892-Surface-Area-of-3D-Shapes/"/>
      <url>/2018/08/26/Leetcode-892-Surface-Area-of-3D-Shapes/</url>
      <content type="html"><![CDATA[<p>On a N * N grid, we place some 1 * 1 * 1 cubes.<br>Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j).<br>Return the total surface area of the resulting shapes.</p><blockquote><p>Example 1:<br>Input: [[2]]<br>Output: 10</p></blockquote><blockquote><p>Example 2:<br>Input: [[1,2],[3,4]]<br>Output: 34</p></blockquote><a id="more"></a><blockquote><p>Example 3:<br>Input: [[1,0],[0,2]]<br>Output: 16</p></blockquote><blockquote><p>Example 4:<br>Input: [[1,1,1],[1,0,1],[1,1,1]]<br>Output: 32</p></blockquote><blockquote><p>Example 5:<br>Input: [[2,2,2],[2,1,2],[2,2,2]]<br>Output: 46</p></blockquote><p>Note:</p><ol><li>1 &lt;= N &lt;= 50</li><li>0 &lt;= grid[i][j] &lt;= 50</li></ol><p><b>分析：</b></p><ol><li>根据样例1可以知道这里是需要计算上下底面积的，并且上下底面积是不会被遮盖的，所以每遍历到一个非0的grid[i][j]，结果都需加上2</li><li>然后考虑侧面积，侧面积是有可能被覆盖的，对于一个格子上的柱子，四个侧面被覆盖的面积取决于他周围4个柱子的高度，两者高度取最低值即可。</li></ol><p><b>思路：</b></p><ol><li>当我们计算周围柱子的时候，可能出现越界的情况，那么这需要单独处理，我们用一个函数处理这种情况，将其视作高度为的柱子，其余照常即可。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">surfaceArea</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m,n = len(grid),len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(i,j)</span>:</span></span><br><span class="line">            ans = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> x,y <span class="keyword">in</span> [(i+<span class="number">1</span>,j),(i<span class="number">-1</span>,j),(i,j+<span class="number">1</span>),(i,j<span class="number">-1</span>)]:</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=x&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=y&lt;n:</span><br><span class="line">                    ans += max(<span class="number">0</span>, grid[i][j]-grid[x][y])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans += grid[i][j]</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j]:</span><br><span class="line">                    res += <span class="number">2</span></span><br><span class="line">                    res += helper(i,j)<span class="comment"># 对一个柱子的四周进行分析</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="number">90</span> / <span class="number">90</span> test cases passed.</span><br><span class="line">difficulty: easy</span><br><span class="line">Runtime: <span class="number">84</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>搜狗输入法换肤功能</title>
      <link href="/2018/08/25/%E6%90%9C%E7%8B%97%E8%BE%93%E5%85%A5%E6%B3%95%E6%8D%A2%E8%82%A4%E5%8A%9F%E8%83%BD/"/>
      <url>/2018/08/25/%E6%90%9C%E7%8B%97%E8%BE%93%E5%85%A5%E6%B3%95%E6%8D%A2%E8%82%A4%E5%8A%9F%E8%83%BD/</url>
      <content type="html"><![CDATA[<p>嗨呀，之前在dilidili上看到好多有意思的东西，像什么windows主题换肤啊，QQ主题换肤啊，输入法主题换肤啊，感觉都好骚啊！这些画师太秀了，忍不住就先弄了个最简单的输入法换肤玩一玩。</p><a id="more"></a><p>还是老样子，先来看下效果，我是用的最近有丶火的血小板皮肤<br><img src="/images/sougou.png" alt=""></p><p>这里以搜狗输入法为例，其他的输入法大同小异，首先我们了解一下搜狗输入法本身的一些构造。<br>我们右键输入法图标点击设置，弹出控制面板的语言界面，然后点击选项<br><img src="/images/sougou_1.png" alt=""><br>然后选择对应输入法的选项按钮，进入设置界面，依次如图选择：<br><img src="/images/sougou_2.png" alt=""><br><img src="/images/sougou_3.png" alt=""><br><img src="/images/sougou_4.png" alt=""></p><p>点开使用皮肤那一栏之后我们可以看到有很多皮肤可以供我们选择。我们作为coder肯定能意识到这些主题皮肤肯定是存储在某个特定目录下面的特定文件啦。于是稍微找一下，我的目录是：<br><code>C:/Program Files (x86)/SogouInput/9.0.0.2502/AllSkin</code><br>这是因为当时我安装搜狗输入法时选择的默认安装，实际目录需以各人当时安装目录为准！</p><p>OK，现在找到源文件的安放地点了，得去下一些有意思的主题皮肤了<br>dilidili皮肤网站： <a href="http://moe.005.tv/style/srf/" target="_blank" rel="noopener">http://moe.005.tv/style/srf/</a><br>这里面包含挺多有意思的皮肤吧，当然你也可以选择去搜狗皮肤官网上去下载。<br>之后过程超级简单，将下载的文件存放进之前找到的皮肤目录，然后在选择皮肤处选择新下好的皮肤就OK了！<br><img src="/images/sougou_5.png" alt=""></p>]]></content>
      
      
        <tags>
            
            <tag> 有趣的东西 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>贴吧emoji表情导入微信</title>
      <link href="/2018/08/24/%E8%B4%B4%E5%90%A7emoji%E8%A1%A8%E6%83%85%E5%AF%BC%E5%85%A5%E5%BE%AE%E4%BF%A1/"/>
      <url>/2018/08/24/%E8%B4%B4%E5%90%A7emoji%E8%A1%A8%E6%83%85%E5%AF%BC%E5%85%A5%E5%BE%AE%E4%BF%A1/</url>
      <content type="html"><![CDATA[<p>555555，有个人就是不告诉我怎么导进来，气的我只好自己疯狂百度，发现这个方法原来是通用的，就是做图有点点麻烦。注意如果什么操作都不做，直接从贴吧把表情拷贝过来，你会发现表情很模糊，并且可能有白底，看起来超丑！所以一定要操作一下，最后效果如下：<br><a id="more"></a><br><img src="/images/emoji_1.png" alt=""></p><p>那么怎么弄呢，目前有两种方法，如果你图方便可以直接用第一种方法：</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>链接：<a href="https://pan.baidu.com/s/1v4kqajXZmaUOFlMh4D2GBw" target="_blank" rel="noopener">https://pan.baidu.com/s/1v4kqajXZmaUOFlMh4D2GBw</a><br>密码：94vh<br>里面是已经制作好了优良的贴吧emoji图片，用电脑下载下来然后把所有图片直接给手机发就OK，呈现出来的就是上述图里一样的效果，因为这个制作得比较好，所以不会产生带白底的情况。但这个毕竟素材有限，如果你想获得新的emoji还是得看第二种方法。</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>方法二属于通用方法，适用于任何表情，具体可以分为以下几个步骤：<br>step 1: 在贴吧里先将你想要的表情在任意一个帖子下面回复，然后在<code>网页版</code>贴吧中将这些表情另存为图片<code>（可能看起来会模糊但其实最后并不会）。</code><br>step 2: 把这些图片发送到手机端，并依次存储到相册中（记得下载原图），你会发现这些图就是我说的带白底的，超丑。<br>step 3: 在微信对话框先点下图所示的+号，然后在新界面疯狂往下拉，拉到最下面又有一个+号，再点进去就进入到我的相册里面了，然后选中你要保存的图，依次类推。<code>（但是这样做由于没有进行任何修饰，图的清晰度会明显差一点，不过勉强能用吧）</code><br><img src="/images/emoji_2.png" alt=""></p><p>方法二效果图（有些清晰，有些模糊，还是跟图本身质量有关吧）：<br><img src="/images/emoji_3.png" alt=""></p><hr>]]></content>
      
      
        <tags>
            
            <tag> 有趣的东西 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 891 Sum of Subsequence Widths</title>
      <link href="/2018/08/23/Leetcode-891-Sum-of-Subsequence-Widths/"/>
      <url>/2018/08/23/Leetcode-891-Sum-of-Subsequence-Widths/</url>
      <content type="html"><![CDATA[<p>Given an array of integers A, consider all non-empty subsequences of A.<br>For any sequence S, let the width of S be the difference between the maximum and minimum element of S.<br>Return the sum of the widths of all subsequences of A.<br>As the answer may be very large, return the answer modulo 10^9 + 7.</p><blockquote><p>Example 1:<br>Input: [2,1,3]<br>Output: 6<br>Explanation:<br>Subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3].<br>The corresponding widths are 0, 0, 0, 1, 1, 2, 2.<br>The sum of these widths is 6.<br><code>这道题还算有点意思</code><br><a id="more"></a><br>Note:</p><ol><li>1 &lt;= A.length &lt;= 20000</li><li>1 &lt;= A[i] &lt;= 20000</li></ol></blockquote><p><b>分析：</b></p><ol><li>首先我们需要明确，题目所求的widths和数组的本身的顺序没有关系，所以排序不会影响最后的结果，其次如果子串长度为1则widths为0，所以可以不用考虑</li><li>OK，对于[1,2,3,4]这个数组，我们从第二个数开始分析：<ol><li>dp[1] = dp[0] + (2-1)*1 (对于nums[1] = 2)</li><li>dp[2] = dp[1] + (3-1)*2 + (3-2)*1 (对于nums[2] = 3)</li><li>dp[3] = dp[2] + (4-1)*4 + (4-2)*2 + (4-3)*1 (对于nums[3] = 4)</li></ol></li><li>相信这么一写你肯定已经<em>初步</em>看出规律了，但是如果按照这个规律不做任何处理依次累加的话复杂度仍然是O(n^2)，肯定是不过关的，我们这里再写一下通用的式子吧:<br><img src="/images/leetcode_891.png" alt=""></li><li>至此，递推式关系已出，显然dp[0] = 0, dp[1] = A[1]-A[0].</li></ol><p><b>思路：</b></p><ol><li>注意递推式中有一个2^(i+1)，因为这个i可以达到20000，所以我们必须先对所有2的次方进行预处理，也就是mod 1e9+7！(把这个作为全局变量，不要来一组数据又重新算一次)</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">rec,mod,s = [],<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>,<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20000</span>):</span><br><span class="line">    rec.append(s)</span><br><span class="line">    s *= <span class="number">2</span></span><br><span class="line">    s %= mod</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumSubseqWidths</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(A) &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        A.sort()</span><br><span class="line">        dp = [<span class="number">0</span>] * len(A)</span><br><span class="line">        dp[<span class="number">0</span>],dp[<span class="number">1</span>] = <span class="number">0</span>,A[<span class="number">1</span>]-A[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,len(dp)):</span><br><span class="line">            dp[i] = (<span class="number">3</span>*dp[i<span class="number">-1</span>] - <span class="number">2</span>*dp[i<span class="number">-2</span>] + (A[i]-A[i<span class="number">-1</span>]) * (rec[i]<span class="number">-1</span>)) % mod</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">64</span> / <span class="number">64</span> test cases passed.</span><br><span class="line">difficulty: hard</span><br><span class="line">Runtime: <span class="number">120</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dp </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 640 Solve the Equation</title>
      <link href="/2018/08/09/Leetcode-640-Solve-the-Equation/"/>
      <url>/2018/08/09/Leetcode-640-Solve-the-Equation/</url>
      <content type="html"><![CDATA[<p>Solve a given equation and return the value of x in the form of string “x=#value”. The equation contains only ‘+’, ‘-‘ operation, the variable x and its coefficient.<br>If there is no solution for the equation, return “No solution”.<br>If there are infinite solutions for the equation, return “Infinite solutions”.<br>If there is exactly one solution for the equation, we ensure that the value of x is an integer.</p><blockquote><p>Example 1:<br>Input: “x+5-3+x=6+x-2”<br>Output: “x=2”</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: “x=x”<br>Output: “Infinite solutions”<br>Example 3:<br>Input: “2x=x”<br>Output: “x=0”<br>Example 4:<br>Input: “2x+3x-6x=x+2”<br>Output: “x=-1”<br>Example 5:<br>Input: “x=x+2”<br>Output: “No solution”</p></blockquote><p><b>分析：</b></p><ol><li>题目意思是求解一个只含加减法的方程，我们自然想到平常是如何去解方程的<ol><li>把含x的项都移到左边，把常数项都移到右边</li><li>构成ax=b的形式，最后x = b/a</li><li>显然如果a=b=0，有无限解</li><li>a=0,b!=0,无解</li><li>其他情况，唯一解</li></ol></li><li>我们发现答案只和系数有关，那么我们就分别计算x的系数v和常数项c的大小</li><li>如何去计算呢，我们发现不管是常数项还是未知项都是处于+-号中间的，那么有最简单的思路，我直接将一对+-号中间的字符串取出来，判断其是不是以x结尾，若是，则前面的系数加到v上，反之则加到c上，只需要注意处理下边界情况即可（但是这种思路当你真去写的时候发现有点坑，因为测试样例稀奇古怪，有好多烦人的情况）</li><li>所以还是采用直接迭代的方式是最稳的(也有点麻烦，垃圾样例)，具体见代码</li></ol><p><b>思路：</b></p><ol><li>因为s包含’=’，所以我们应该对左右两边分别求系数，然后再进行分析</li><li>构建函数求一串字符串的x系数和常数项大小</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveEquation</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type equation: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        s1,s2 = s.split(<span class="string">'='</span>)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(a)</span>:</span></span><br><span class="line">            const, varia = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            i,flag = <span class="number">0</span>,<span class="number">1</span> <span class="comment">#flag用于判断系数正负</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; len(a):</span><br><span class="line">                rec = <span class="string">''</span> <span class="comment"># 用来记录系数</span></span><br><span class="line">                <span class="keyword">while</span> i &lt; len(a) <span class="keyword">and</span> a[i] <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">'+-'</span>:</span><br><span class="line">                    <span class="keyword">if</span> a[i] == <span class="string">'x'</span>:</span><br><span class="line">                        <span class="comment"># 可能出现单一个'x'或'-x'的情况</span></span><br><span class="line">                        varia += int(rec) * flag <span class="keyword">if</span> rec <span class="keyword">else</span> flag</span><br><span class="line">                        rec = <span class="string">''</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        rec += a[i]</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> rec: const += int(rec) * flag</span><br><span class="line">                <span class="keyword">if</span> i &gt;= len(a): <span class="keyword">break</span></span><br><span class="line">                <span class="comment"># 因为上面的判断语句，这里a[i]只会是'+-'中的一种</span></span><br><span class="line">                <span class="keyword">if</span> a[i] == <span class="string">'+'</span>: flag = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: flag = <span class="number">-1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> const, varia</span><br><span class="line">        c1,v1 = helper(s1)</span><br><span class="line">        c2,v2 = helper(s2)</span><br><span class="line">        v = v1 - v2</span><br><span class="line">        c = c2 - c1</span><br><span class="line">        <span class="keyword">if</span> v == c == <span class="number">0</span>: <span class="keyword">return</span> <span class="string">"Infinite solutions"</span></span><br><span class="line">        <span class="keyword">if</span> v == <span class="number">0</span> <span class="keyword">and</span> c != <span class="number">0</span>: <span class="keyword">return</span> <span class="string">"No solution"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"x="</span> + str(c//v)</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 884 Decoded String an Index</title>
      <link href="/2018/08/05/Leetcode-884-Decoded-String-an-Index/"/>
      <url>/2018/08/05/Leetcode-884-Decoded-String-an-Index/</url>
      <content type="html"><![CDATA[<p>An encoded string S is given.  To find and write the decoded string to a tape, the encoded string is read one character at a time and the following steps are taken:<br>If the character read is a letter, that letter is written onto the tape.<br>If the character read is a digit (say d), the entire current tape is repeatedly written d-1 more times in total.<br>Now for some encoded string S, and an index K, find and return the K-th letter (1 indexed) in the decoded string.</p><blockquote><p>Example 1:<br>Input: S = “leet2code3”, K = 10<br>Output: “o”<br>Explanation:<br>The decoded string is “leetleetcodeleetleetcodeleetleetcode”.<br>The 10th letter in the string is “o”.</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: S = “ha22”, K = 5<br>Output: “h”<br>Explanation:<br>The decoded string is “hahahaha”.  The 5th letter is “h”.<br>Example 3:<br>Input: S = “a2345678999999999999999”, K = 1<br>Output: “a”<br>Explanation:<br>The decoded string is “a” repeated 8301530446056247680 times.  The 1st letter is “a”.</p></blockquote><p>Note:</p><ol><li>2 &lt;= S.length &lt;= 100</li><li>S will only contain lowercase letters and digits 2 through 9.</li><li>S starts with a letter.</li><li>1 &lt;= K &lt;= 10^9</li><li>The decoded string is guaranteed to have less than 2^63 letters.</li></ol><p><b>分析：</b></p><ol><li>这道题是把字符串按照给定的规则展开，然后返回展开后的字符串的第K个字符，应该要怎么思考呢？</li><li>我不知道大家注意到note的第5点没有，为什么他在这里突然加这么一点，告诉我们长度小于2^63，其实就是在暗示我们要用到总长度（因为我们不可能真把展开后的字符串写出来）</li><li>然后这里的测试样例也有点迷惑作用，因为他故意不给出最后以字符结尾的例子，就是担心把思路直接暴露出来了，我们来看一个例子</li><li>S = ‘leet2code3problem’，这个字符串展开后总长度为43，’problem’是没有重复的部分，前面’leet2code3’总长度是36，那么假设此时K = 37,38,39…，43，我们可以直接得出答案。那如果K小于37呢，那么问题是不是可以转换成在S=’leet2code3’求第K个字符（多余的部分可以直接不要）</li><li>当以数字结尾时，那么整个字符串就是S[:-1]的若干次重复，例如此时S=’leet2code3’的长度为36，设K=18吧，那么基本字符串的长度应该为36/3=12，那么我们要求的字符应该是第18%12=6个字符，现在问题转换成了S=’leet2code’,K=6,又变成我们第4点中分析的情况了，依次类推即可</li></ol><p><b>思路：</b></p><ol><li>分析过程很简单明了，但是代码却不太好写，比较繁杂</li><li>我们先去找S中最后一个数字的位置，然后判断K是不是处于这个数字后面的那串字符串中（关键），若是则直接返回</li><li>若不是则改变S，K的值，注意了我们的总长度不能每次改变一次S重新计算一次，那样太麻烦了(不过我猜应该不会超时，因为s长度不超过100)，而是每次通过减去多余字符串的长度和除以结尾数字来改变！！！</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decodeAtIndex</span><span class="params">(self, S, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 先计算总长度</span></span><br><span class="line">        M = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(S)):</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'1'</span> &lt; S[i] &lt;= <span class="string">'9'</span>: M *= int(S[i])</span><br><span class="line">            <span class="keyword">else</span>: M += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(S,K,M)</span>:</span></span><br><span class="line">            <span class="comment"># 找到最后数字出现的位置</span></span><br><span class="line">            index = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(S)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="string">'1'</span> &lt; S[i] &lt;= <span class="string">'9'</span>: index = i;<span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 若没有数字，说明已经是最简字符串了，直接返回即可</span></span><br><span class="line">            <span class="keyword">if</span> index == <span class="number">-1</span>: <span class="keyword">return</span> S[K<span class="number">-1</span>]</span><br><span class="line">            <span class="comment"># 判断K是不是在数字后面的那串字符串中</span></span><br><span class="line">            <span class="keyword">if</span> M-K &lt; len(S)<span class="number">-1</span>-index: <span class="keyword">return</span> S[K-M<span class="number">-1</span>]</span><br><span class="line">            <span class="comment"># 先减去多余字符串的长度，然后再除以最后数字的大小，然后调整K的大小</span></span><br><span class="line">            M -= len(S)-index<span class="number">-1</span></span><br><span class="line">            M //= int(S[index])</span><br><span class="line">            K %= M</span><br><span class="line">            <span class="comment"># 这里一个小问题，假如K=3，M=3，那么实际应该返回第三个字符但是这里去mod的话会是0，所以要单独处理这种情况</span></span><br><span class="line">            <span class="keyword">if</span> K == <span class="number">0</span>: K = M</span><br><span class="line">            <span class="keyword">return</span> helper(S[:index],K,M)</span><br><span class="line">        <span class="keyword">return</span> helper(S,K,M)</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 885 Boats to Save People</title>
      <link href="/2018/08/05/Leetcode-885-Boats-to-Save-People/"/>
      <url>/2018/08/05/Leetcode-885-Boats-to-Save-People/</url>
      <content type="html"><![CDATA[<p>The i-th person has weight people[i], and each boat can carry a maximum weight of limit.<br>Each boat carries at most 2 people at the same time, provided the sum of the weight of those people is at most limit.<br>Return the minimum number of boats to carry every given person.  (It is guaranteed each person can be carried by a boat.)</p><blockquote><p>Example 1:<br>Input: people = [1,2], limit = 3<br>Output: 1<br>Explanation: 1 boat (1, 2)</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: people = [3,2,2,1], limit = 3<br>Output: 3<br>Explanation: 3 boats (1, 2), (2) and (3)<br>Example 3:<br>Input: people = [3,5,3,4], limit = 5<br>Output: 4<br>Explanation: 4 boats (3), (3), (4), (5)</p></blockquote><p>Note:</p><ol><li>1 &lt;= people.length &lt;= 50000</li><li>1 &lt;= people[i] &lt;= limit &lt;= 30000</li></ol><p><b>分析：</b></p><ol><li>我感觉这道题该归为easy才对，每条船最多只能装两个人，那么只要能装两个人我就装</li><li>从重量最大的人开始分析，能不能和重量最小的人一起呢？能就一起不能就拉倒！为什么在这里贪心不会出错呢？</li><li>因为之后分析的人的重量都比这个人要小，也就不存在某个人不能和现在这个人一起反而能和比这个人轻的人一起的情况。</li></ol><p><b>思路：</b></p><ol><li>用一个双向队列，分别把最重最轻的人依次出队</li><li>如果目前最重的人和最轻的人加一起比Limit要小，就都pop出来，否则就只pop最重的人</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numRescueBoats</span><span class="params">(self, people, limit)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type people: List[int]</span></span><br><span class="line"><span class="string">        :type limit: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        people.sort()</span><br><span class="line">        Q = collections.deque(people)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> Q:</span><br><span class="line">            w = Q.pop()</span><br><span class="line">            <span class="keyword">if</span> Q <span class="keyword">and</span> Q[<span class="number">0</span>] &lt;= limit - w:</span><br><span class="line">                Q.popleft()</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 887 Projection Area of 3D Shapes</title>
      <link href="/2018/08/05/Leetcode-887-Projection-Area-of-3D-Shapes/"/>
      <url>/2018/08/05/Leetcode-887-Projection-Area-of-3D-Shapes/</url>
      <content type="html"><![CDATA[<p>On a N * N grid, we place some 1 * 1 * 1 cubes that are axis-aligned with the x, y, and z axes.</p><p>Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j).</p><p>Now we view the projection of these cubes onto the xy, yz, and zx planes.</p><p>A projection is like a shadow, that maps our 3 dimensional figure to a 2 dimensional plane. </p><p>Here, we are viewing the “shadow” when looking at the cubes from the top, the front, and the side.</p><p>Return the total area of all three projections.</p><a id="more"></a><p><img src="/images/leetcode_887.png" alt=""><br>Note:</p><ol><li>1 &lt;= grid.length = grid[0].length &lt;= 50</li><li>0 &lt;= grid[i][j] &lt;= 50</li></ol><p><b>分析：</b></p><ol><li>这道题就是高中所学的正视图、侧视图、俯视图</li><li>对于正视图，也就是从x轴方向看，我们看到的就是沿y轴方向的一系列最高的柱子</li><li>对于侧视图，也就是从y轴方向看，我们看到的就是沿x轴方向的一系列最高的柱子</li><li>对于俯视图，所有的柱子都是1，因为底面积是1</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">projectionArea</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid <span class="keyword">or</span> <span class="keyword">not</span> grid[<span class="number">0</span>]: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        m,n = len(grid),len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 俯视图的所有柱子，包括了0，等下需要减去</span></span><br><span class="line">        res += m*n</span><br><span class="line">        <span class="comment"># 侧视图的最高</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> grid: </span><br><span class="line">            res += max(row)</span><br><span class="line">            <span class="comment"># 减去俯视图里多计算的0的数量</span></span><br><span class="line">            res -= row.count(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 正视图的最高</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> zip(*grid): </span><br><span class="line">            res += max(row)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 877 Stone Game</title>
      <link href="/2018/07/29/Leetcode-877-Stone-Game/"/>
      <url>/2018/07/29/Leetcode-877-Stone-Game/</url>
      <content type="html"><![CDATA[<p>Alex and Lee play a game with piles of stones.  There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].<br>The objective of the game is to end with the most stones.  The total number of stones is odd, so there are no ties.<br>Alex and Lee take turns, with Alex starting first.  Each turn, a player takes the entire pile of stones from either the beginning or the end of the row.  This continues until there are no more piles left, at which point the person with the most stones wins.<br>Assuming Alex and Lee play optimally, return True if and only if Alex wins the game.</p><blockquote><p>Example 1:<br>Input: [5,3,4,5]<br>Output: true<br>Explanation:<br>Alex starts first, and can only take the first 5 or the last 5.<br>Say he takes the first 5, so that the row becomes [3, 4, 5].<br>If Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points.<br>If Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points.<br>This demonstrated that taking the first 5 was a winning move for Alex, so we return true.</p></blockquote><a id="more"></a><p>Note:</p><ol><li>2 &lt;= piles.length &lt;= 500</li><li>piles.length is even.</li><li>1 &lt;= piles[i] &lt;= 500</li><li>sum(piles) is odd.</li></ol><p>和leetcode 486题一样，只是更简单了<br><b>分析：</b></p><ol><li>不妨认为Alex第一次拿的piles[0]，那么剩下的是piles[1:]</li><li>Lee拿piles[1]还是piles[-1]不取决于这两个数哪个大，而是拿了某个数之后使得剩下的数中Alex能获得的总数小</li><li>若定义firstscore(piles)表示在当前piles数组中，先拿的人最后能获得的总分数，则alex的分数应该是<code>max(piles[0]+min(firstscore(piles[1:-1]),firstscore(piles[2:])), piles[-1] + min(firstscore(piles[1:-1]), firstscore(piles[:-2])))</code></li></ol><p><b>思路：</b></p><ol><li>因为涉及到大量重复计算，所以需要采用记忆化的思想，用一个cache存已经计算过的值</li><li>但如果用piles作为key值，所花的时间和空间都太大了，所以改成用下标替代的方法</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stoneGame</span><span class="params">(piles)</span>:</span></span><br><span class="line">cache = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">firstscore</span><span class="params">(i,j)</span>:</span></span><br><span class="line"><span class="keyword">if</span> i&gt;=j: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> j==i+<span class="number">1</span> <span class="keyword">and</span> j &lt; len(piles): <span class="keyword">return</span> piles[i]</span><br><span class="line"><span class="keyword">if</span> (i,j) <span class="keyword">in</span> cache: <span class="keyword">return</span> cache[i,j]</span><br><span class="line">res = max(piles[i]+min(firstscore(i+<span class="number">2</span>,j), firstscore(i+<span class="number">1</span>,j<span class="number">-1</span>)) , piles[j<span class="number">-1</span>] + min(firstscore(i+<span class="number">1</span>,j<span class="number">-1</span>), firstscore(i,j<span class="number">-2</span>)))</span><br><span class="line">cache[i,j] = res</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">Alex = firstscore(<span class="number">0</span>,len(piles))</span><br><span class="line">Lee = sum(piles) - Alex</span><br><span class="line"><span class="keyword">return</span> Alex &gt; Lee</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 878 Nth Magical Number</title>
      <link href="/2018/07/29/Leetcode-878-Nth-Magical-Number/"/>
      <url>/2018/07/29/Leetcode-878-Nth-Magical-Number/</url>
      <content type="html"><![CDATA[<p>A positive integer is magical if it is divisible by either A or B.<br>Return the N-th magical number.  Since the answer may be very large, return it modulo 10^9 + 7.</p><blockquote><p>Example 1:<br>Input: N = 1, A = 2, B = 3<br>Output: 2</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: N = 4, A = 2, B = 3<br>Output: 6</p></blockquote><blockquote><p>Example 3:<br>Input: N = 5, A = 2, B = 4<br>Output: 10</p></blockquote><blockquote><p>Example 4:<br>Input: N = 3, A = 6, B = 4<br>Output: 8</p></blockquote><p>Note:</p><ol><li>1 &lt;= N &lt;= 10^9</li><li>2 &lt;= A &lt;= 40000</li><li>2 &lt;= B &lt;= 40000<br>2，3，4，6，8，9，10，12，14，15，16</li></ol><p><b>分析:</b></p><ol><li>在极大的范围内找到一个数,使其满足某种条件，显然是二分法</li><li>对于找到的某个数K，要判断其是不是正好是满足条件的第N个数，也就是判断是不是刚好有N-1个满足条件的数比他小。</li><li>举个例子，N，A，B = 11，2，3<ol><li>我们用二分搜索搜到了16，那么比16小的2的倍数的数有2，4，6，8，10，12，14，共7个</li><li>比16小的3的倍数的数有3，6，9，12，15共5个</li><li>其中6，12重复了，故应减去这两个数，而这也正好是A,B最小公倍数即6的倍数</li><li>故比16小且满足条件的数共有7+5-2=10，说明16正好是第11个数</li></ol></li></ol><p><b>思路：</b></p><ol><li>先找到A,B的最小公倍数</li><li>二分计算结果</li><li>mod 1e9+7</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthMagicalNumber</span><span class="params">(self, N, A, B)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :type A: int</span></span><br><span class="line"><span class="string">        :type B: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        mod = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        A,B = min(A,B),max(A,B)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">gcd</span><span class="params">(a,b)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> b: <span class="keyword">return</span> a</span><br><span class="line">            <span class="keyword">return</span> gcd(b,a%b)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">lcm</span><span class="params">(a,b)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> a*b == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> int(a*b/gcd(a,b))</span><br><span class="line">        C = lcm(A,B)</span><br><span class="line">        </span><br><span class="line">        lo = <span class="number">1</span></span><br><span class="line">        hi = <span class="number">10</span>**<span class="number">14</span></span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mid = (lo+hi) / <span class="number">2</span></span><br><span class="line">            num1 = int(math.ceil(mid/float(A))) - <span class="number">1</span></span><br><span class="line">            num2 = int(math.ceil(mid/float(B))) - <span class="number">1</span></span><br><span class="line">            num3 = int(math.ceil(mid/float(C))) - <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> num1+num2-num3 == N<span class="number">-1</span>  <span class="keyword">and</span> (mid % A == <span class="number">0</span> <span class="keyword">or</span> mid % B == <span class="number">0</span>): <span class="keyword">return</span> mid % mod</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">elif</span> num1+num2-num3 &gt; N<span class="number">-1</span>:</span><br><span class="line">                hi = mid</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lo = mid+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">66</span> / <span class="number">66</span> test cases passed.</span><br><span class="line">difficulty: hard</span><br><span class="line">Runtime: <span class="number">24</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> math </tag>
            
            <tag> Binary search </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>bfs系列详解</title>
      <link href="/2018/07/24/bfs%E7%B3%BB%E5%88%97%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/07/24/bfs%E7%B3%BB%E5%88%97%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1 id="BFS算法基本套路"><a href="#BFS算法基本套路" class="headerlink" title="BFS算法基本套路"></a>BFS算法基本套路</h1><p>本文默认读者是有一定算法基础的，对于基本的语法和bfs概念都了解，本文由浅入深(也不是很深咯)，让你知道碰到bfs系列题目应该去怎么想，代码应该怎么去写，OK，直接进入正题。</p><a id="more"></a><h2 id="基本bfs算法"><a href="#基本bfs算法" class="headerlink" title="基本bfs算法"></a>基本bfs算法</h2><p>这一部分是<code>重中之重</code>，因为在这里给出最基本bfs算法的写法，之后底下大部分的题，只是在这个基础上加一点东西罢了，所以这里的代码得牢记。<br>本文默认所有二叉树的定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br></pre></td></tr></table></figure></p><p>那么最基本的，用bfs算法去遍历一颗二叉树(bfs算法基本格式，很好记)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">    Q = collections.deque([root])</span><br><span class="line">    <span class="keyword">while</span> Q:</span><br><span class="line">        node = Q.popleft()</span><br><span class="line">        <span class="keyword">if</span> node.left: Q.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right: Q.append(node.right)</span><br></pre></td></tr></table></figure></p><p>以小见大，我们就从最基本的bfs算法中总结一下bfs算法的流程。</p><ol><li>初始化队列，将起始点保存</li><li>节点依次出队列，并将出队列的节点的所有相邻节点加入队列</li><li>直至找到所求或队列遍历结束</li></ol><p>bfs不仅用在树中，在二维数组（也可看成是一个图）中，也是经常使用的，正好利用上面总结的流程来看bfs算法在数组中怎么写<br>不妨设给定数组名为matrix，matrix[i][j]为起始点<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(i,j)</span>:</span></span><br><span class="line">    m,n = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">    visited = set((i,j))</span><br><span class="line">    <span class="comment"># 初始化队列，保存起始点</span></span><br><span class="line">    Q = collections.deque([(i,j)])</span><br><span class="line">    <span class="keyword">while</span> Q:</span><br><span class="line">        i,j = Q.popleft()</span><br><span class="line">        <span class="comment"># visited.add((x,y))</span></span><br><span class="line">        <span class="comment"># 所有相邻节点加入队列</span></span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> [(i+<span class="number">1</span>,j),(i<span class="number">-1</span>,j),(i,j+<span class="number">1</span>),(i,j<span class="number">-1</span>)]:</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>&lt;=x&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=y&lt;n <span class="keyword">and</span> (x,y) <span class="keyword">not</span> <span class="keyword">in</span> visited: <span class="comment"># 未出界and不走回头路</span></span><br><span class="line">                Q.append((x,y))</span><br><span class="line">                <span class="comment"># 注意visited一定要放在这里，不能是放在上面注释的地方，否则产生大量重复计算</span></span><br><span class="line">                visited.add((x,y))</span><br></pre></td></tr></table></figure></p><p><strong>OK，基本套路在心里有个印象，然后来看两个简单例子巩固一下</strong></p><hr><h2 id="leetcode-107-Binary-Tree-Level-Order-Traversal"><a href="#leetcode-107-Binary-Tree-Level-Order-Traversal" class="headerlink" title="leetcode 107 Binary Tree Level Order Traversal"></a>leetcode 107 Binary Tree Level Order Traversal</h2><p>给定一棵树的根节点，按照自下而上的顺序依次输出每层节点<br><img src="/images/bfs_1.png" alt=""><br>显然，这道题应用bfs进行遍历，但是需要一层一层的遍历，如何在遍历过程中知道现在这个节点是该层的最后一个节点呢？<br>这道题就体现了一个思路，每次记录一下当前队列的长度<code>l</code>，然后用一个长度为l的循环来pop node，循环结束时，刚好遍历完一层的节点<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">    Q = collections.deque([root])</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> Q:</span><br><span class="line">        rec = [] <span class="comment"># record all node in the same level</span></span><br><span class="line">        l = len(Q)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</span><br><span class="line">            node = Q.popleft()</span><br><span class="line">            rec.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left: Q.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right: Q.append(node.right)</span><br><span class="line">        <span class="comment"># 循环结束rec正好储存了该层的所有节点</span></span><br><span class="line">        res.append(rec)</span><br><span class="line">    <span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><hr><h2 id="leetcode-103-Binary-Tree-Zigzag-Level-Order-Traversal"><a href="#leetcode-103-Binary-Tree-Zigzag-Level-Order-Traversal" class="headerlink" title="leetcode 103 Binary Tree Zigzag Level Order Traversal"></a>leetcode 103 Binary Tree Zigzag Level Order Traversal</h2><p>给定一棵树的根节点，按照zigzag顺序输出每层节点，即第一层节点从左至右，第二层节点从右至左，第三层节点从左至右，依次类推。<br><img src="/images/bfs_2.png" alt=""><br>这道题和上道基本一样，无非是在处理某些层时，记录的节点顺序需要反转一下，引入一个level变量判定是否反转即可<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">    Q = collections.deque([root])</span><br><span class="line">    res = []</span><br><span class="line">    level = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> Q:</span><br><span class="line">        rec = [] <span class="comment"># record all node in the same level</span></span><br><span class="line">        l = len(Q)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</span><br><span class="line">            node = Q.popleft()</span><br><span class="line">            rec.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left: Q.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right: Q.append(node.right)</span><br><span class="line">        <span class="comment"># 循环结束rec正好储存了该层的所有节点</span></span><br><span class="line">        <span class="keyword">if</span> level % <span class="number">2</span> != <span class="number">0</span>: res.append(rec)</span><br><span class="line">        <span class="keyword">else</span>: res.append(rec[::<span class="number">-1</span>])</span><br><span class="line">        level += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><hr><p>上面两个跟树相关的bfs相对较为简单，因为对于总结的流程来说，二叉树通常有：</p><ol><li><code>明确的起点，通常是根节点</code></li><li><code>明确的相邻节点且不用考虑重复遍历的情况（因为单向）</code></li></ol><p>但在更多的题目中却不是这样，不论是起始点还是相邻节点，都需要我们自己去分析判断才能得出。再来看下面两个例子，感受下这类题目如何去找流程中的两个关键点。</p><h2 id="leetcode-542-01-Matrix"><a href="#leetcode-542-01-Matrix" class="headerlink" title="leetcode 542 01 Matrix"></a>leetcode 542 01 Matrix</h2><p>给定一个矩阵matrix（只包含0or1，保证至少有一个0），返回一个矩阵res，其中res[i][j]代表距离matrix[i][j]处最近的0的距离。<br><img src="/images/bfs_3.png" alt=""><br>对于这道题，<strong>怎么找bfs的起始点呢</strong>，我们可能最初想到的是对每一个1都进行一次bfs遍历，去寻找与他最近的0的位置，但这样显然会超时，因为当1都聚集在一起的时候会有大量重复计算。<br>换个思路，既然1不行，那0行吗，以单个的0肯定不行，因为这个0找到的最近的1，并不一定是最短的，还得计算别的0然后来比较，所以还是得有大量重复计算和比较。<br>既然起始点找单个不行，我们可以找多个，我们<code>将所有的0作为起始点</code>，去找所有最后res[i][j]=1的点，然后<code>将res=1的点作为起始点</code>，去找所有最后res[i][j]=2的点，以此类推。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(matrix)</span>:</span></span><br><span class="line">    m,n = len(matrix),len(matrix[<span class="number">0</span>])</span><br><span class="line">    Q = collections.deque([])</span><br><span class="line">    visited = set()</span><br><span class="line">    <span class="comment"># 初始化队列，将所有起始点加入</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">                Q.append((i,j))</span><br><span class="line">                visited.add((i,j))</span><br><span class="line">    <span class="comment"># 标准bfs写法，将相邻节点加入队列</span></span><br><span class="line">    <span class="keyword">while</span> Q:</span><br><span class="line">        i,j = Q.popleft()</span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> [(i+<span class="number">1</span>,j),(i<span class="number">-1</span>,j),(i,j+<span class="number">1</span>),(i,j<span class="number">-1</span>)]:</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>&lt;=x&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=y&lt;n <span class="keyword">and</span> (x,y) <span class="keyword">not</span> <span class="keyword">in</span> visited:<span class="comment"># 不出界 and 不走回头路</span></span><br><span class="line">                matrix[x][y] = matrix[i][j] + <span class="number">1</span></span><br><span class="line">                <span class="comment"># visited一定要在这里添加，否则产生大量重复计算</span></span><br><span class="line">                visited.add((x,y))</span><br><span class="line">                Q.append((x,y))</span><br><span class="line">    <span class="keyword">return</span> matrix</span><br></pre></td></tr></table></figure></p><hr><h2 id="leetcode-279-Perfect-Squares"><a href="#leetcode-279-Perfect-Squares" class="headerlink" title="leetcode 279 Perfect Squares"></a>leetcode 279 Perfect Squares</h2><p>给定一个正整数n，找到m个平方数(1,4,9…)使得m个数的和为n，返回满足条件的最小的m<br>n = 12, return 3; because 12 = 4 + 4 + 4<br>n = 13, return 2; because 13 = 4 + 9</p><p>一般看到这道题大家第一反应可能是dp，记dp[i]表示组成和为i的平方数的最优个数，则dp[n]为所求。<br>递推式为：<code>dp[n] = 1 + min(dp[n-1],dp[n-4],dp[n-9],...)</code><br>当然这是完全正确的，但是这里我们如果用bfs方法应该怎么做呢？</p><ol><li>找起点，显然是n本身。</li><li>找相邻节点，显然为n-1,n-4,n-9,…,n-k^2，k满足(k+1)^2 &gt; n。<br><img src="/images/bfs_4.png" alt=""><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(n)</span>:</span></span><br><span class="line">    Q = collections.deque([n])</span><br><span class="line">    visited = set()</span><br><span class="line">    level = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> Q:</span><br><span class="line">        l = len(Q)<span class="comment"># 按层处理</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</span><br><span class="line">            n = Q.popleft()</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> level</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,int(n**<span class="number">0.5</span>)+<span class="number">1</span>):<span class="comment"># 遍历相邻节点 and  不重复计算</span></span><br><span class="line">                val = n - i**<span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> val <span class="keyword">in</span> visited: <span class="keyword">continue</span></span><br><span class="line">                Q.append(val)</span><br><span class="line">                visited.add(val)</span><br><span class="line">        level += <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ol><hr><p>如果你看到这里觉得仿佛有点感觉了，那么建议你用这道题练一练<br><a href="https://leetcode.com/problems/open-the-lock/description/" target="_blank" rel="noopener">https://leetcode.com/problems/open-the-lock/description/</a></p><hr><p>OK，截至到目前位置，我默认你应该对这种比较基础的bfs问题已经“一般”掌握了<br>所以我们稍微来看一点进阶的题目</p><h2 id="leetcode-127-Word-Ladder"><a href="#leetcode-127-Word-Ladder" class="headerlink" title="leetcode 127 Word Ladder"></a>leetcode 127 Word Ladder</h2><p>给定一个word1和word2，和一个转换列表wlist，找出最短的变换路径使word1变成word2，其变换规则需满足：</p><ol><li>一次只能改变word1中的一个字母</li><li>每次改变后的单词必须存在于wlist中</li><li>如果无法转换则返回0</li></ol><p>word1 = “hit”,word2= “cog”<br>wlist = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]<br>return 5; because hit -&gt; hot -&gt; dot -&gt; dog -&gt; cog</p><p>相信你看了上面那么多题之后这道题应该不用我详细分析了吧，如图就完事了：<br><img src="/images/bfs_5.png" alt=""><br>我们仍然根据之前说的bfs解题思路来分析：</p><ol><li>找起始点，显然是word1</li><li>找相邻节点，显然是与当前单词只有一处地方不同的单词</li></ol><p>那么我们得想办法保存一下每个单词的“相邻”单词。<br>例如对于’hot’，我们分别去找形如’_ot’,’h_t’,’ho_’ 的单词，又想到如果看到一个再去找一个复杂度也太高了，不如最初就把他们按照这种规则存在字典里面。<br>例如’hot’就分别存入d[‘_ot’],d[‘h_t’],d[‘ho_’]中，这样只花费了n*m个空间，其中n=len(wlist),m=len(wlist[0])<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(word1,word2,wlist)</span>:</span></span><br><span class="line">    <span class="comment"># 按照上述规则存储每个字符</span></span><br><span class="line">    d = collections.defaultdict(list)</span><br><span class="line">    visited = set()</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> wlist:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            d[s[i:]+<span class="string">'_'</span>+s[i+<span class="number">1</span>:]].append(s)</span><br><span class="line">    <span class="comment"># 初始化队列，将起点加入</span></span><br><span class="line">    Q = collections.deque([word1])</span><br><span class="line">    level = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> Q:</span><br><span class="line">        l = len(Q)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</span><br><span class="line">            s = Q.popleft()</span><br><span class="line">            <span class="keyword">if</span> s == word2: <span class="keyword">return</span> level  <span class="comment"># 找到s</span></span><br><span class="line">            <span class="comment"># visited.add(s)</span></span><br><span class="line">            <span class="comment"># 添加相邻节点 and 不重复计算</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(s)):</span><br><span class="line">                <span class="keyword">for</span> s1 <span class="keyword">in</span> d[s[:j]+<span class="string">'_'</span>+s[j+<span class="number">1</span>:]]:</span><br><span class="line">                    <span class="keyword">if</span> s1 <span class="keyword">not</span> <span class="keyword">in</span> visited: </span><br><span class="line">                        Q.append(s1)</span><br><span class="line">                        <span class="comment"># visited一定要放在这，不能在上面注释的地方，否则产生大量重复计算</span></span><br><span class="line">                        visited.add(s1)</span><br><span class="line">        level += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p><hr><p>上面那道题关键就在如何保存相邻节点，而这其实是bfs问题中很关键的一环，我们再来看一道题，虽说被leetcode划分为hard，但我觉得应该只勉强够个medium,可以说还没有前面几道题难！</p><h2 id="leetcode-815-Bus-Routes"><a href="#leetcode-815-Bus-Routes" class="headerlink" title="leetcode 815 Bus Routes"></a>leetcode 815 Bus Routes</h2><p>给定一系列的bus，其中bus[i]表示第i辆bus能经过的所有站，然后给定起始站和终点站，问从起始站出发需要换乘几辆车才能到达终点站。<br>bus = [[1,2,7], [3,6,7]]<br>start = 1,target = 6<br>return 2; because first take bus[0](1-&gt;7),then take bus[1](7-&gt;6)<br>Note:bus.length &lt;= 500, bus[i].length &lt;= 500, bus[i][j] &lt; 10^6;</p><p>我们还是按照之前提到的bfs解题思路来分析：</p><ol><li>找起始点，显然是start</li><li>找相邻节点，显然是当前站乘一次bus就可到的所有站，例如对于start，我们需要把bus里面所有含start的bus中的所有站设为start的相邻节点！</li></ol><p>看到这里我们应该已经意识到问题所在了，如果我们把每个节点的相邻节点的保存下来的话，所需的空间实在太大了，从数据范围上可以看出，如果每个len(bus[i])=500，那么对于其中任意两个站a,b，都要有b in d[a] and a in d[b]（也就是花费两个空间），那么总共就是Combs(500,2)，再乘以500的话会超出空间限制！</p><p>那么这里应该怎么存呢？其实换个角度想，bus本身已经帮我们把每个节点的相邻节点存好了，只是没有放在一起而已，我们要做的应该是记录下对应的下标即可，例如对于测试样例中的站台7，我们应该保存(0,1)，说明bus[0]和bus[1]中的所有节点都是站台7的相邻节点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numBusesToDestination</span><span class="params">(self, routes, S, T)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type routes: List[List[int]]</span></span><br><span class="line"><span class="string">        :type S: int</span></span><br><span class="line"><span class="string">        :type T: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        d = collections.defaultdict(set)</span><br><span class="line">        visited = set([S])</span><br><span class="line">        <span class="comment"># 只存储下标</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(routes)):</span><br><span class="line">            <span class="keyword">for</span> val <span class="keyword">in</span> routes[i]:</span><br><span class="line">                d[val].add(i)</span><br><span class="line">        </span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 初始化队列，起点为start</span></span><br><span class="line">        Q = collections.deque([S])</span><br><span class="line">        <span class="keyword">while</span> Q:</span><br><span class="line">            <span class="comment"># 按层遍历，每遍历完一层res+1</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(Q)):</span><br><span class="line">                node = Q.popleft()</span><br><span class="line">                <span class="keyword">if</span> node == T: <span class="keyword">return</span> res</span><br><span class="line">                <span class="keyword">for</span> index <span class="keyword">in</span> d[node]:</span><br><span class="line">                    <span class="keyword">for</span> station <span class="keyword">in</span> routes[index]:</span><br><span class="line">                        <span class="comment"># 添加相邻节点 and 不重复计算</span></span><br><span class="line">                        <span class="keyword">if</span> station <span class="keyword">in</span> visited: <span class="keyword">continue</span></span><br><span class="line">                        visited.add(station)</span><br><span class="line">                        Q.append(station)</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> bfs </tag>
            
            <tag> 经典算法分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 875 Koko Eating Bananas</title>
      <link href="/2018/07/22/Leetcode-875-Koko-Eating-Bananas/"/>
      <url>/2018/07/22/Leetcode-875-Koko-Eating-Bananas/</url>
      <content type="html"><![CDATA[<p>Koko loves to eat bananas.  There are N piles of bananas, the i-th pile has piles[i] bananas.  The guards have gone and will come back in H hours.<br>Koko can decide her bananas-per-hour eating speed of K.  Each hour, she chooses some pile of bananas, and eats K bananas from that pile.  If the pile has less than K bananas, she eats all of them instead, and won’t eat any more bananas during this hour.<br>Koko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back.<br>Return the minimum integer K such that she can eat all the bananas within H hours.</p><blockquote><p>Example 1:<br>Input: piles = [3,6,7,11], H = 8<br>Output: 4</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: piles = [30,11,23,4,20], H = 5<br>Output: 30</p></blockquote><blockquote><p>Example 3:<br>Input: piles = [30,11,23,4,20], H = 6<br>Output: 23</p></blockquote><p>Note:</p><ol><li>1 &lt;= piles.length &lt;= 10^4</li><li>piles.length &lt;= H &lt;= 10^9</li><li>1 &lt;= piles[i] &lt;= 10^9</li></ol><p><b>分析：</b></p><ol><li>去找一个值满足某种条件，这种题见得太多了，显然是二分法，之后我整理一下所有的这种题目做一个合辑。</li><li>那么这里怎么选定初始的lo和hi呢？我们要明确我们找的是吃的速度，那么最低，起码得在吃吧，所以起码lo = 1，那hi呢？我们注意到note中第二点pile.length &lt;= H，因为我们吃的速度就算再快，一次也只能吃一盘而已，所以无论怎样最少都得pile.length个小时才能吃完，所以hi = max(piles)</li></ol><p><b>思路：</b></p><ol><li>对于某个确定的k值，我们如何计算吃完所有pile需要的时间呢，对于一盘，时间应该是piles[i]/k 向上取整，然后求和判断是否大于H</li><li>若小于，则说明吃完还绰绰有余，还可以吃慢一点，从lo,mid中继续找</li><li>若大于，则说明吃得太慢了，则应该从mid,hi中继续找</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># O(NlogM) time，N = len(piles), M = max(piles)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minEatingSpeed</span><span class="params">(self, piles, H)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type piles: List[int]</span></span><br><span class="line"><span class="string">        :type H: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        lo,hi = <span class="number">1</span>,max(piles)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">canEat</span><span class="params">(k)</span>:</span></span><br><span class="line">            time = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(piles)):</span><br><span class="line">                time += int(math.ceil(piles[i]/float(k)))</span><br><span class="line">                <span class="keyword">if</span> time &gt; H: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mid = (lo + hi) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> canEat(mid):</span><br><span class="line">                hi = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lo = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> lo</span><br><span class="line"></span><br><span class="line"><span class="number">113</span> / <span class="number">113</span> test cases passed.</span><br><span class="line">diffculty: medium</span><br><span class="line">Runtime: <span class="number">824</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> Binary search </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 874 Walking Robot Simulation</title>
      <link href="/2018/07/22/Leetcode-874-Walking-Robot-Simulation/"/>
      <url>/2018/07/22/Leetcode-874-Walking-Robot-Simulation/</url>
      <content type="html"><![CDATA[<p>A robot on an infinite grid starts at point (0, 0) and faces north.  The robot can receive one of three possible types of commands:<br>-2: turn left 90 degrees<br>-1: turn right 90 degrees<br>1 &lt;= x &lt;= 9: move forward x units<br>Some of the grid squares are obstacles.<br>The i-th obstacle is at grid point (obstacles[i][0], obstacles[i][1])<br>If the robot would try to move onto them, the robot stays on the previous grid square instead (but still continues following the rest of the route.)<br>Return the square of the maximum Euclidean distance that the robot will be from the origin.</p><blockquote><p>Example 1:<br>Input: commands = [4,-1,3], obstacles = []<br>Output: 25<br>Explanation: robot will go to (3, 4)</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: commands = [4,-1,4,-2,4], obstacles = [[2,4]]<br>Output: 65<br>Explanation: robot will be stuck at (1, 4) before turning left and going to (1, 8)</p></blockquote><p>Note:</p><ol><li>0 &lt;= commands.length &lt;= 10000</li><li>0 &lt;= obstacles.length &lt;= 10000</li><li>-30000 &lt;= obstacle[i][0] &lt;= 30000</li><li>-30000 &lt;= obstacle[i][1] &lt;= 30000</li><li>The answer is guaranteed to be less than 2 ^ 31.</li></ol><p><b>分析：</b></p><ol><li>首先应该确定目前行进的方向，我用(1,-1,-2,2)这四个值分别代表上下左右,dire = 1代表目前向上行进，故初始化dire = 1</li><li>当commands[i] = -2 or -1时，改变dire的值，这跟dire当前的值有关，具体方法于思路中说</li><li>因为每次行进的距离不超过10，那么最多也就走90000步，我们完全可以每一步都判断其是否被一个obstacles所阻挡，但是每次比较一个元祖是不是在集合中也太蠢了，所以稍微处理一下，我们用两个字典记录obstacles，例如，dx[x1]代表一个列表，列表里面记录所有横坐标为x1的点的纵坐标,dy[y1]同理</li><li><code>注意，这道题是要求整个过程中达到的最大的欧拉距离，并不是最后的距离，所有每移动一次就要比较一次，我就是没看到这一点，做了特别特别久，都不知道哪里错了！</code></li></ol><p><b>思路：</b></p><ol><li>我们用一个directions = {1:[-2,2], -1:[2,-2], -2:[-1,1], 2:[1,-1]}记录方向的变换，对于directions[x]，x代表当前方向，directions[x][0]表示向左转之后的方向，directions[x][1]代表向右转之后的方向</li><li>用position=[x,y]记录此时的位置，每进行一次移动就记录一次</li><li>别看代码这么长，其实后面的代码都是一样的（只跟方向有关），因为太恶心了我也懒得整合了</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># O(n) time, O(n) space</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">robotSim</span><span class="params">(self, commands, obstacles)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type commands: List[int]</span></span><br><span class="line"><span class="string">        :type obstacles: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dx = collections.defaultdict(set)</span><br><span class="line">        dy = collections.defaultdict(set)</span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> obstacles:</span><br><span class="line">            dx[x].add(y)</span><br><span class="line">            dy[y].add(x)</span><br><span class="line"></span><br><span class="line">        position = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        directions = &#123;<span class="number">1</span>:[<span class="number">-2</span>,<span class="number">2</span>], <span class="number">-1</span>:[<span class="number">2</span>,<span class="number">-2</span>], <span class="number">-2</span>:[<span class="number">-1</span>,<span class="number">1</span>], <span class="number">2</span>:[<span class="number">1</span>,<span class="number">-1</span>]&#125;</span><br><span class="line">        dire = <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(commands)):</span><br><span class="line">            <span class="comment"># 左转</span></span><br><span class="line">            <span class="keyword">if</span> commands[i] == <span class="number">-2</span>:</span><br><span class="line">                dire = directions[dire][<span class="number">0</span>]</span><br><span class="line">            <span class="comment"># 右转</span></span><br><span class="line">            <span class="keyword">elif</span> commands[i] == <span class="number">-1</span>:</span><br><span class="line">                dire = directions[dire][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x = commands[i]</span><br><span class="line">                <span class="comment"># 若在向上or下走，固定x,判断每个y是否存在于dx[x]中</span></span><br><span class="line">                <span class="keyword">if</span> dire == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,x+<span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">if</span> position[<span class="number">1</span>] + i <span class="keyword">in</span> dx[position[<span class="number">0</span>]]:</span><br><span class="line">                            position[<span class="number">1</span>] = position[<span class="number">1</span>] + i - <span class="number">1</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        position[<span class="number">1</span>] = position[<span class="number">1</span>] + i</span><br><span class="line">                <span class="keyword">elif</span> dire == <span class="number">-1</span>:</span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,x+<span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">if</span> position[<span class="number">1</span>] - i <span class="keyword">in</span> dx[position[<span class="number">0</span>]]:</span><br><span class="line">                            position[<span class="number">1</span>] = position[<span class="number">1</span>] - i + <span class="number">1</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        position[<span class="number">1</span>] = position[<span class="number">1</span>] - i</span><br><span class="line">                <span class="comment"># 若在向左or右走，固定y，判断每个x是否存在于dy[y]中</span></span><br><span class="line">                <span class="keyword">elif</span> dire == <span class="number">-2</span>:</span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,x+<span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">if</span> position[<span class="number">0</span>] - i <span class="keyword">in</span> dy[position[<span class="number">1</span>]]:</span><br><span class="line">                            position[<span class="number">0</span>] = position[<span class="number">0</span>] - i + <span class="number">1</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        position[<span class="number">0</span>] = position[<span class="number">0</span>] - i</span><br><span class="line">                <span class="keyword">elif</span> dire == <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,x+<span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">if</span> position[<span class="number">0</span>] + i <span class="keyword">in</span> dy[position[<span class="number">1</span>]]:</span><br><span class="line">                            position[<span class="number">0</span>] = position[<span class="number">0</span>] + i - <span class="number">1</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        position[<span class="number">0</span>] = position[<span class="number">0</span>] + i</span><br><span class="line">            res = max(res, position[<span class="number">0</span>]**<span class="number">2</span> + position[<span class="number">1</span>]**<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="number">47</span> / <span class="number">47</span> test cases passed.</span><br><span class="line">diffculty: easy</span><br><span class="line">Runtime: <span class="number">144</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 873 Length of Longest Fibonacci Subsequence</title>
      <link href="/2018/07/22/Leetcode-873-Length-of-Longest-Fibonacci-Subsequence/"/>
      <url>/2018/07/22/Leetcode-873-Length-of-Longest-Fibonacci-Subsequence/</url>
      <content type="html"><![CDATA[<p>A sequence X_1, X_2, …, X_n is fibonacci-like if:<br>· n &gt;= 3<br>· X_i + X_{i+1} = X_{i+2} for all i + 2 &lt;= n<br>Given a strictly increasing array A of positive integers forming a sequence, find the length of the longest fibonacci-like subsequence of A.  If one does not exist, return 0.<br>(Recall that a subsequence is derived from another sequence A by deleting any number of elements (including none) from A, without changing the order of the remaining elements.  For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].)</p><blockquote><p>Example 1:<br>Input: [1,2,3,4,5,6,7,8]<br>Output: 5<br>Explanation:<br>The longest subsequence that is fibonacci-like: [1,2,3,5,8].</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: [1,3,7,11,12,14,18]<br>Output: 3<br>Explanation:<br>The longest subsequence that is fibonacci-like:<br>[1,11,12], [3,11,14] or [7,11,18].</p></blockquote><p>Note:</p><ol><li>3 &lt;= A.length &lt;= 1000</li><li>1 &lt;= A[0] &lt; A[1] &lt; … &lt; A[A.length - 1] &lt;= 10^9<br>(The time limit has been reduced by 50% for submissions in Java, C, and C++.)</li></ol><p><b>分析：</b></p><ol><li>对于这种找子串的问题，大家应该敏感一点，虽然不说绝对，但是极大可能是dp，在这里写一下我分析这道题的心路历程</li><li>第一反应，dp[i]表示nums[:i]的最长fiboc序列长度。但仔细想想dp[i]只记录长度，我根本没法去判断nums[i]能否组出一个更长的序列，那用dp[i]记录下一个期望的数（序列中最后两个数的和）？但是就想example2一样，首先可能会有很多期望的值，其次，可能最后最长的那个序列在最初分析数组前几个数时根本不包括其中，所以这个方法应该是行不通。</li><li>第二反应，发现A的长度不超过1000，这不是暗示我n^2的方法嘛，一想dp[i][j]表示nums[i:j]的最长fibco序列长度，乍一看好像可行诶，首先可以初始化，因为j-i&lt;2则dp[i][j] = 0，所有的j-i=2都可以判断出来（因为就三个数），对于j-i&gt;2，可以依次分析dp[i][i+2],dp[i][i+3]…dp[i][j-1]与nums[j]能否构成更长的序列，取最长的那个保存，但想到这里的时候，发现这个方法复杂度好像有点高哦，达到n^3了，想了一会也没想到怎么优化，而且也还是会面临第2点中说的第一个问题，遂放弃。</li><li>第三反应，逆向思维一下，像上面两个方法都是判断最后一个数能不能和前面的组成更长的序列，那为什么不固定住最后的序列，去找前面的序列呢(这个思维正好把第2点中提到的那个“其次”解决了)，dp[i][j]表示以nums[i]和nums[j]结尾的fibco序列的最长长度，则dp[i][j] = dp[nums[j]-nums[i]的index][i] + 1，当然这必须要满足nums[j]-nums[i]在A中</li></ol><p><b>思路：</b></p><ol><li>用一个字典保存值和下标的对应关系，用于获得nums[j]-nums[i]的index</li><li>集合记录A（有序）中元素，判断nums[j]-nums[i]是否在A中</li><li>这一点inspired by @lee215，判断nums[j]-nums[i] &lt; nums[i] and nums[j]-nums[i] in s，可以避免重复计算</li><li>inspired by @lee215，可以用值来代替下标(python版本，它的C++版本是用的我上面说的思路，这么一看python实在太方便了)，可以让代码简洁很多（这是真的大神！！！）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lenLongestFibSubseq</span><span class="params">(A)</span>:</span></span><br><span class="line">    dp = collections.defaultdict(int)</span><br><span class="line">    s = set(A)</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> xrange(len(A)):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(j):</span><br><span class="line">            <span class="keyword">if</span> A[j] - A[i] &lt; A[i] <span class="keyword">and</span> A[j] - A[i] <span class="keyword">in</span> s:</span><br><span class="line">                dp[A[i], A[j]] = dp.get((A[j] - A[i], A[i]), <span class="number">2</span>) + <span class="number">1</span></span><br><span class="line">                res = max(res, dp[A[i], A[j]])</span><br><span class="line">    <span class="keyword">return</span> max(dp.values() <span class="keyword">or</span> [<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="number">33</span> / <span class="number">33</span> test cases passed.</span><br><span class="line">diffculty: medium</span><br><span class="line">Runtime: <span class="number">328</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 872 Leaf-Similar Trees</title>
      <link href="/2018/07/22/Leetcode-872-Leaf-Similar-Trees/"/>
      <url>/2018/07/22/Leetcode-872-Leaf-Similar-Trees/</url>
      <content type="html"><![CDATA[<p><img src="/images/leetcode_872.png" alt=""></p><a id="more"></a><p><b>分析：</b></p><ol><li>一棵树的叶子节点的值从左至右构成的序列叫做叶子序列</li><li>判断两颗树的叶子序列是否相同</li><li>显然要处理不同层的叶子还要从左至右，肯定是dfs了</li></ol><p><b>思路：</b></p><ol><li>编写dfs()用于遍历树，并记录叶子序列</li><li>对两棵树分别调用dfs函数，比较叶子序列是否相同</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">leafSimilar</span><span class="params">(self, root1, root2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root1: TreeNode</span></span><br><span class="line"><span class="string">        :type root2: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root,rec)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                rec.append(root.val)</span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                dfs(root.left,rec)</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                dfs(root.right,rec)</span><br><span class="line">        rec1, rec2 = [], []</span><br><span class="line">        dfs(root1, rec1)</span><br><span class="line">        dfs(root2, rec2)</span><br><span class="line">        <span class="keyword">return</span> rec1 == rec2</span><br><span class="line"></span><br><span class="line"><span class="number">36</span> / <span class="number">36</span> test cases passed.</span><br><span class="line">diffculty: easy</span><br><span class="line">Runtime: <span class="number">28</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dfs </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 583 Delete Operation for Two Strings</title>
      <link href="/2018/07/19/Leetcode-583-Delete-Operation-for-Two-Strings/"/>
      <url>/2018/07/19/Leetcode-583-Delete-Operation-for-Two-Strings/</url>
      <content type="html"><![CDATA[<p>给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。</p><blockquote><p>示例 1:<br>输入: “sea”, “eat”<br>输出: 2<br>解释: 第一步将”sea”变为”ea”，第二步将”eat”变为”ea”</p></blockquote><a id="more"></a><p>说明:<br>给定单词的长度不超过500。<br>给定单词中的字符只含有小写字母。</p><p><b>分析：</b></p><ol><li>因为只能做删除操作，所以这其实就是一个最长公共子序列问题</li><li>定义dp[i][j]表示word1[:i+1]和word2[:j+1]之间的最长公共子序列长度</li><li>递推式如下：<ol><li>dp[i][j] = dp[i-1][j-1] + 1 if word1[i] == word2[j]</li><li>dp[i][j] = max(dp[i-1][j], dp[i][j-1])</li></ol></li><li>示例中dp数组应如下：</li></ol><table><thead><tr><th></th><th>e</th><th>a</th><th>t</th></tr></thead><tbody><tr><td>s</td><td>0</td><td>0</td><td>0</td></tr><tr><td>e</td><td>1</td><td>1</td><td>1</td></tr><tr><td>a</td><td>1</td><td>2</td><td>2</td></tr></tbody></table><p><b>思路：</b></p><ol><li>初始化所有的dp[0][j],dp[i][0]</li><li>按照递推式运算</li><li>记l = dp[-1][-1]，则应返回 m-l + n-l，m,n分别代表word1和word2的长度</li><li>处理数据为空的情况</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, w1, w2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type word1: str</span></span><br><span class="line"><span class="string">        :type word2: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> w1: <span class="keyword">return</span> len(w2)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> w2: <span class="keyword">return</span> len(w1)</span><br><span class="line">        m,n = len(w1), len(w2)</span><br><span class="line">        dp = [[<span class="number">1</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> w1[i] != w2[<span class="number">0</span>]: dp[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> w1[<span class="number">0</span>] != w2[j]: dp[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">if</span> w1[i] == w2[j]:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])</span><br><span class="line">        l = dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> m - l + n - l</span><br><span class="line"></span><br><span class="line"><span class="number">1307</span> / <span class="number">1307</span> test cases passed.</span><br><span class="line">diffculty: medium</span><br><span class="line">Runtime: <span class="number">180</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 581 Shortest Unsorted Continuous Subarray</title>
      <link href="/2018/07/19/Leetcode-581-Shortest-Unsorted-Continuous-Subarray/"/>
      <url>/2018/07/19/Leetcode-581-Shortest-Unsorted-Continuous-Subarray/</url>
      <content type="html"><![CDATA[<p>给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。<br>你找到的子数组应是最短的，请输出它的长度。</p><blockquote><p>示例 1:<br>输入: [2, 6, 4, 8, 10, 9, 15]<br>输出: 5<br>解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。</p></blockquote><a id="more"></a><p>说明 :</p><ol><li>输入的数组长度范围在 [1, 10,000]。</li><li>输入的数组可能包含重复元素 ，所以升序的意思是&lt;=。</li></ol><p><b>分析：</b></p><ol><li>我们需要找一段<code>最短无序数组nums[start:end]</code>，使其排序完成后整个数组也是有序的，换个角度想，我们也可以找<code>两段最长的有序数组nums[:start]和nums[end:]</code>，那么怎样找到“最长”的情况呢</li><li>对于某一个元素nums[i]，如果其满足<code>nums[i] &lt; min(nums[i+1:])</code>，则我们可以说nums[i]是处于有序序列中的，即nums[:start]中。</li><li>对于某一个元素nums[j]，如果其满足<code>nums[j] &gt; max(nums[:j])</code>，则我们可以说nums[j]也是处于有序序列中的，即nums[end:]中。</li></ol><p><b>思路：</b></p><ol><li>从0开始，找到第一个不满足<code>nums[i] &lt; min(nums[i+1:])</code>的i，记为start</li><li>从len(nums)-1开始，找到第一个不满足<code>nums[j] &gt; max(nums[:j])</code>的j，记为end</li><li>用s[i]记录min(nums[i:])，用l[j]记录max(nums[:j])</li><li>处理数组初始有序情况</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findUnsortedSubarray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        s = [nums[<span class="number">-1</span>]] * len(nums)</span><br><span class="line">        l = [nums[<span class="number">0</span>]] * len(nums)</span><br><span class="line">        start = end = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 找到start</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            s[i] = min(nums[i], s[i+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; s[i+<span class="number">1</span>]:</span><br><span class="line">                start = i;<span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 找到end</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            l[i] = max(l[i<span class="number">-1</span>],nums[i])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; l[i<span class="number">-1</span>]:</span><br><span class="line">                end = i;<span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 处理初始有序情况</span></span><br><span class="line">        <span class="keyword">if</span> start == end == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> end - start + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">307</span> / <span class="number">307</span> test cases passed.</span><br><span class="line">difficulty: easy</span><br><span class="line">Runtime: <span class="number">72</span> ms,beats <span class="number">29</span>%</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 576 Out of Boundary Paths</title>
      <link href="/2018/07/19/Leetcode-576-Out-of-Boundary-Paths/"/>
      <url>/2018/07/19/Leetcode-576-Out-of-Boundary-Paths/</url>
      <content type="html"><![CDATA[<p>给定一个 m × n 的网格和一个球。球的起始坐标为 (i,j) ，你可以将球移到相邻的单元格内，或者往上、下、左、右四个方向上移动使球穿过网格边界。但是，你最多可以移动N次。找出可以将球移出边界的路径数量。答案可能非常大，返回结果mod 1e9+7的值。</p><p><img src="/images/leetcode_576.png" alt=""><br><a id="more"></a><br>说明:</p><ol><li>球一旦出界，就不能再被移动回网格内。</li><li>网格的长度和高度在 [1,50] 的范围内。</li><li>N 在 [0,50] 的范围内。</li></ol><p><b>分析：</b></p><ol><li>这道题乍一看很像一个标准的bfs，因为限定最多只能移动N次，我们只要bfs依次遍历发现出界就+1，当bfs的深度大于N的时候break。当然理论上是没有任何问题的，确实能得出正确答案，但是这里N的取值范围达到了50，我们对任意一个点bfs有四个方向（可以走回头路），那么复杂度达到了4^N，显然会超时。当然我会在文章后面给出bfs的做法，毕竟这是可以处理N比较小的情况的解法，让大家更熟悉bfs的套路。</li><li>我不知道你们有没有这种感觉，一般看到这个mod 1e9+7，这道题8成就是dp了，而且就是那种每个dp值你都得mod一下再去进行运算的那种。我觉得这算一个小技巧吧，看到mod 1e9+7就要想到dp。</li><li>显然，这里dp很好定义，我们定义<code>dp[(i,j,N)]</code>表示<code>从i,j出发，最多走N步情况下满足题意的路径数量</code>，那么我们所求也就是dp[(i,j,N)]。根据我们上面说的bfs的思路，递推式可得：<br><code>dp[(i,j,N)] = dp[(i+1,j,N-1)] + dp[(i-1,j,N-1)] + dp[(i,j+1,N-1)] + dp[(i,j-1,N-1)]</code></li></ol><p><b>思路：</b></p><ol><li>处理好边界情况：<ol><li>当i,j仍然在网格内时，如果N=0，说明这条路走不出去,dp[(i,j,N)] = 0</li><li>当i,j仍然在网格内时，如果N&gt;0，如递推式</li><li>当i,j在网格外时，说明已经走出去，dp[(i,j,N)] = 1</li></ol></li><li>这里我为了方便代码书写就用的记忆化的形式，用一个cache来存储已经计算过的结果</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPaths</span><span class="params">(self, m, n, N, i, j)</span>:</span></span><br><span class="line">        mod = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        cache = collections.defaultdict(int)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(i,j,N)</span>:</span></span><br><span class="line">            <span class="comment"># 记忆化思想</span></span><br><span class="line">            <span class="keyword">if</span> (i,j,N) <span class="keyword">in</span> cache:</span><br><span class="line">                <span class="keyword">return</span> cache[(i,j,N)]</span><br><span class="line">            <span class="comment">#i,j在网格内情况</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>&lt;=i&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=j&lt;n:</span><br><span class="line">                <span class="keyword">if</span> N == <span class="number">0</span>:</span><br><span class="line">                    cache[(i,j,N)] = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">return</span> cache[(i,j,N)]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> x,y <span class="keyword">in</span> [(i+<span class="number">1</span>,j),(i<span class="number">-1</span>,j),(i,j+<span class="number">1</span>),(i,j<span class="number">-1</span>)]:</span><br><span class="line">                    cache[(i,j,N)] += helper(x,y,N<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> cache[(i,j,N)] % mod</span><br><span class="line">            <span class="comment"># 网格外情况</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cache[(i,j,N)] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> cache[(i,j,N)]</span><br><span class="line">        <span class="keyword">return</span> helper(i,j,N) % mod</span><br><span class="line"></span><br><span class="line"><span class="number">94</span> / <span class="number">94</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">272</span> ms</span><br></pre></td></tr></table></figure><p>下面是bfs代码，在这道题中tle<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPaths</span><span class="params">(m,n,N,i,j)</span>:</span></span><br><span class="line">    mod = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">    Q = collections.deque([(i,j,<span class="number">0</span>)])</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> Q:</span><br><span class="line">        x,y,step = Q.popleft()</span><br><span class="line">        <span class="keyword">if</span> step &gt; N: <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span>&lt;=x&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=y&lt;n:</span><br><span class="line">            Q.append((x+<span class="number">1</span>,y,step+<span class="number">1</span>))</span><br><span class="line">            Q.append((x<span class="number">-1</span>,y,step+<span class="number">1</span>))</span><br><span class="line">            Q.append((x,y+<span class="number">1</span>,step+<span class="number">1</span>))</span><br><span class="line">            Q.append((x,y<span class="number">-1</span>,step+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res % mod</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 575 Distribute Candies</title>
      <link href="/2018/07/18/Leetcode-575-Distribute-Candies/"/>
      <url>/2018/07/18/Leetcode-575-Distribute-Candies/</url>
      <content type="html"><![CDATA[<p>给定一个偶数长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。你需要把这些糖果平均分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数。</p><blockquote><p>示例 1:<br>输入: candies = [1,1,2,2,3,3]<br>输出: 3<br>解析: 一共有三种种类的糖果，每一种都有两个。最优分配方案：妹妹获得[1,2,3],弟弟也获得[1,2,3]。这样使妹妹获得糖果的种类数最多。</p></blockquote><a id="more"></a><blockquote><p>示例 2 :<br>输入: candies = [1,1,2,3]<br>输出: 2<br>解析: 妹妹获得糖果[2,3],弟弟获得糖果[1,1]，妹妹有两种不同的糖果，弟弟只有一种。这样使得妹妹可以获得的糖果种类数最多。</p></blockquote><p>注意:</p><ol><li>数组的长度为[2, 10,000]，并且确定为偶数。</li><li>数组中数字的大小在范围[-100,000, 100,000]内。</li></ol><p><b>分析：</b></p><ol><li>设总共有2*n个糖果，那么显然妹妹最后会分到n个糖果，如果糖果的种类数大于n，妹妹最多只能得到n种糖果，若糖果的种类数小于n，妹妹则最多只能得到糖果的种类数</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distributeCandies</span><span class="params">(self, candies)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type candies: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        s = set(candies)</span><br><span class="line">        <span class="keyword">return</span> min(len(candies)/<span class="number">2</span>, len(s))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">205</span> / <span class="number">205</span> test cases passed.</span><br><span class="line">difficulty: easy</span><br><span class="line">Runtime: <span class="number">92</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 529 Minesweeper</title>
      <link href="/2018/07/11/Leetcode-529-Minesweeper/"/>
      <url>/2018/07/11/Leetcode-529-Minesweeper/</url>
      <content type="html"><![CDATA[<p>让我们一起来玩扫雷游戏！<br>给定一个代表游戏板的二维字符矩阵。 ‘M’ 代表一个未挖出的地雷，’E’ 代表一个未挖出的空方块，’B’ 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的已挖出的空白方块，数字（’1’ 到 ‘8’）表示有多少地雷与这块已挖出的方块相邻，’X’ 则表示一个已挖出的地雷。<br>现在给出在所有未挖出的方块中（’M’或者’E’）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：</p><ol><li>如果一个地雷（’M’）被挖出，游戏就结束了- 把它改为 ‘X’。</li><li>如果一个没有相邻地雷的空方块（’E’）被挖出，修改它为（’B’），并且所有和其相邻的方块都应该被递归地揭露。</li><li>如果一个至少与一个地雷相邻的空方块（’E’）被挖出，修改它为数字（’1’到’8’），表示相邻地雷的数量。</li><li>如果在此次点击中，若无更多方块可被揭露，则返回面板。</li></ol><a id="more"></a><p><img src="/images/leetcode_529_1.png" alt=""><br><img src="/images/leetcode_529_2.png" alt=""></p><p><b>注意:</b></p><ol><li>输入矩阵的宽和高的范围为 [1,50]。</li><li>点击的位置只能是未被挖出的方块 (‘M’ 或者 ‘E’)，这也意味着面板至少包含一个可点击的方块。</li><li>输入面板不会是游戏结束的状态（即有地雷已被挖出）。</li><li>简单起见，未提及的规则在这个问题中可被忽略。例如，当游戏结束时你不需要挖出所有地雷，考虑所有你可能赢得游戏或标记方块的情况。</li></ol><p><b>分析：</b></p><ol><li>根据规则中所述，关键有以下几点<ol><li>点击处必为’E’或’M’，若是’M’，将其改为’X’游戏结束</li><li>若点击处为’E’，则判断’E’周围是否有雷存在，若有则返回雷的数量，将其修改为雷的数量</li><li>若’E’周围无雷，则对’E’周围格子（共8个）依次按照上述规则递归</li></ol></li><li>这里举个简单例子，若点击(0,0)：(<code>不能越过数字去递归(0,2)，这一点从示例1中也能看出</code>)<br>[E,E,E]————&gt;[B,1,E]<br>[E,E,M]————&gt;[B,1,M]</li></ol><p><b>思路：</b></p><ol><li>当我们递归E的时候如何判断周边是否有雷呢，每次都遍历8个方向会有大量重复工作，虽然在这道题中即使你这样做也可以通过，但是显然这不是我们追求的</li><li>我们使用一个字典d[(i,j)]来存储(i,j)处周围的雷数量，那么容易想到我先遍历每一个雷，然后对雷周围的格子在d中进行一次变换存储</li><li>这样我们之后递归E时便可通过判断(i,j)是否存在于d中来判断E周边是否有雷</li><li>本身递归的dfs是很简单的，这里不做详细说明了</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">updateBoard</span><span class="params">(self, board, click)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :type click: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m,n = len(board),len(board[<span class="number">0</span>])</span><br><span class="line">        d = collections.defaultdict(int)</span><br><span class="line">        directions = [(i<span class="number">-1</span>,j<span class="number">-1</span>),(i<span class="number">-1</span>,j),(i<span class="number">-1</span>,j+<span class="number">1</span>),(i,j<span class="number">-1</span>),(i,j+<span class="number">1</span>),(i+<span class="number">1</span>,j<span class="number">-1</span>),(i+<span class="number">1</span>,j),(i+<span class="number">1</span>,j+<span class="number">1</span>)]</span><br><span class="line">        click_i,click_j = click</span><br><span class="line">        <span class="comment"># 点击处为雷</span></span><br><span class="line">        <span class="keyword">if</span> board[click_i][click_j] == <span class="string">'M'</span>:</span><br><span class="line">            board[click_i][click_j] = <span class="string">'X'</span></span><br><span class="line">            <span class="keyword">return</span> board</span><br><span class="line">        <span class="comment"># 初始化字典</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">setNum</span><span class="params">(i,j,d)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> x,y <span class="keyword">in</span> directions:</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=x&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=y&lt;n <span class="keyword">and</span> board[x][y] != <span class="string">'M'</span>:</span><br><span class="line">                    d[(x,y)] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">'M'</span>:</span><br><span class="line">                    setNum(i,j,d)</span><br><span class="line">        <span class="comment"># 点击处周边有雷</span></span><br><span class="line">        <span class="keyword">if</span> (click_i,click_j) <span class="keyword">in</span> d:</span><br><span class="line">            board[click_i][click_j] = str(d[(click_i,click_j)])</span><br><span class="line">            <span class="keyword">return</span> board</span><br><span class="line">        <span class="comment"># dfs依次递归</span></span><br><span class="line">        visited = set()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i,j)</span>:</span></span><br><span class="line">            visited.add((i,j))</span><br><span class="line">            <span class="comment"># 递归到数字则修改board</span></span><br><span class="line">            <span class="keyword">if</span> (i,j) <span class="keyword">in</span> d: </span><br><span class="line">                board[i][j] = str(d[(i,j)])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                board[i][j] = <span class="string">'B'</span></span><br><span class="line">            <span class="keyword">for</span> x,y <span class="keyword">in</span> directions:</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=x&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=y&lt;n <span class="keyword">and</span> (x,y) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    dfs(x,y)</span><br><span class="line"></span><br><span class="line">        dfs(click_i,click_j)</span><br><span class="line">        <span class="keyword">return</span> board</span><br><span class="line"></span><br><span class="line"><span class="number">54</span> / <span class="number">54</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">248</span> ms,beats <span class="number">97</span>%</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 525 Contiguous Array</title>
      <link href="/2018/07/10/Leetcode-525-Contiguous-Array/"/>
      <url>/2018/07/10/Leetcode-525-Contiguous-Array/</url>
      <content type="html"><![CDATA[<p>给定一个二进制数组, 找到含有相同数量的 0 和 1 的最长连续子数组。</p><blockquote><p>示例 1:<br>输入: [0,1]<br>输出: 2<br>说明: [0, 1] 是具有相同数量0和1的最长连续子数组。<br>示例 2:<br>输入: [0,1,0]<br>输出: 2<br>说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。</p></blockquote><p>注意: 给定的二进制数组的长度不会超过50000。<br><a id="more"></a></p><p><code>不想做重复的工作，这道题和523 560一模一样，如果你想弄懂前缀和的这个解法，建议先看560，再看523，我在另外两篇博客中写得很详细了</code><br>具体见<a href="https://buptwc.github.io/2018/07/10/Leetcode-523-Continuous-Subarray-Sum/" target="_blank" rel="noopener">https://buptwc.github.io/2018/07/10/Leetcode-523-Continuous-Subarray-Sum/</a></p><p><code>当你看懂前两道题后再来分析这道题，将所有的0变成-1，这道题就变成找最长的和为0的连续子数组，前缀和可解</code></p><p><b>思路：</b><br>（建议先看560，否则你可能不知道我在说什么）</p><ol><li>改用字典存储已经遍历过的值，对应相应的下标，即d[sum(nums[:i])] = i，相同的key值取最小（最左边）的下标</li><li>依次遍历判断，若成功找到key值，存储一次长度</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxLength</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">0</span>: nums[i] = <span class="number">-1</span></span><br><span class="line">        sm = <span class="number">0</span></span><br><span class="line">        d = collections.defaultdict(<span class="keyword">lambda</span>: float(<span class="string">'inf'</span>))</span><br><span class="line">        d[<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            sm += nums[i]</span><br><span class="line">            <span class="keyword">if</span> sm <span class="keyword">in</span> d: </span><br><span class="line">                res = max(res,i-d[sm])</span><br><span class="line">            d[sm] = min(d[sm],i) </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">555</span> / <span class="number">555</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">292</span> ms,beats <span class="number">91.27</span>%</span><br><span class="line"><span class="comment"># 可以稍微优化一下，第一次的遍历nums将0改成1可以去除，直接在sm += nums[i]时判断nums[i]的值即可</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 523 Continuous Subarray Sum</title>
      <link href="/2018/07/10/Leetcode-523-Continuous-Subarray-Sum/"/>
      <url>/2018/07/10/Leetcode-523-Continuous-Subarray-Sum/</url>
      <content type="html"><![CDATA[<p>给定一个包含非负数的数组和一个目标整数k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为2，总和为k的倍数，即总和为 n*k，其中n也是一个整数。</p><blockquote><p>示例 1:<br>输入: [23,2,4,6,7], k = 6<br>输出: True<br>解释: [2,4] 是一个大小为 2 的子数组，并且和为 6。<br>示例 2:<br>输入: [23,2,6,4,7], k = 6<br>输出: True<br>解释: [23,2,6,4,7]是大小为 5 的子数组，并且和为 42。</p></blockquote><a id="more"></a><p>说明:</p><ol><li>数组的长度不会超过10,000。</li><li>你可以认为所有数字总和在 32 位有符号整数范围内。</li></ol><p><b>分析：</b></p><ol><li>这道题和560题解法一样，强烈建议先看那道题，具体见<a href="https://leetcode.com/problems/subarray-sum-equals-k/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/subarray-sum-equals-k/solution/</a></li><li>当我们分析数组中连续的若干数之和时，很容易想到先用一个数组sm[i]记录sum(nums[:i])，那么则有<code>sm[j] - sm[i] = sum(nums[i:j])</code></li><li>但是如果依次遍历时间复杂度为O(n^2)，在这里肯定超时，所以我们得想个简单的办法，这也就是这类型题的经典思想，前缀和处理</li><li>我们先来考虑一个简单的情况，即是否存在连续的子数组的和为k，我们应该怎么做呢？<ol><li>假设存在i,j满足<code>sum(nums[i:j]) = k</code>，那么则应有<code>sm[j] - sm[i] = k</code>，也就是如果我们找到i,j满足这个式子就可以说明存在…！</li><li>那当我们遍历sm数组时，将遍历的数依次存进集合，遍历至<code>sm[j]</code>时，我们如果发现<code>sm[j]-k</code>，即<code>sm[i]</code>是存在于集合中的，那么我们就可以确定,确实存在sum(nums[i:j]) = k</li></ol></li><li>回到我们这道题上，假设确实存在i,j(j-i&gt;=2)满足<code>sum(nums[i:j]) = n * k</code>，即<code>sm[j] - sm[i] = n * k</code>，此时用上面的方法是不可行的，因为n*k是个不确定的数，我们无法判断其是否在集合内，但我们只用作一个小小的变换————对上式两边同时模k，上式变为<code>sm[j]%k - sm[i]%k = 0</code>，此时就和4中情况是等价的，唯独是集合中存储的数从sm[i]变成了sm[i]%k</li></ol><p><b>思路：</b></p><ol><li>因为j-i&gt;=2，所以更新集合的时候应当推迟一步，即分析完sm[i]之后才将sm[i-1]%k加入集合之中</li><li>注意k = 0的情况，因为模0操作是不被允许的，所以需要单独处理</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkSubarraySum</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>: <span class="keyword">return</span> <span class="string">'00'</span> <span class="keyword">in</span> <span class="string">''</span>.join(map(str,nums))</span><br><span class="line">        <span class="comment"># 初始化集合和前缀和数组</span></span><br><span class="line">        s = set([<span class="number">0</span>])</span><br><span class="line">        sm = [nums[<span class="number">0</span>]] * len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            sm[i] = sm[i<span class="number">-1</span>] + nums[i]</span><br><span class="line">            <span class="keyword">if</span> sm[i] % k <span class="keyword">in</span> s: </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="comment"># 分析完之后再更新集合</span></span><br><span class="line">            s.add(sm[i<span class="number">-1</span>]%k)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">75</span> / <span class="number">75</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">36</span> ms,beats <span class="number">98</span>%</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 518 Coin Change 2</title>
      <link href="/2018/07/10/Leetcode-518-Coin-Change-2/"/>
      <url>/2018/07/10/Leetcode-518-Coin-Change-2/</url>
      <content type="html"><![CDATA[<p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 </p><p>注意: 你可以假设</p><ol><li>0 &lt;= amount (总金额) &lt;= 5000</li><li>1 &lt;= coin (硬币面额) &lt;= 5000</li><li>硬币种类不超过500种</li><li>结果符合32位符号整数</li></ol><a id="more"></a><blockquote><p>示例 1:<br>输入: amount = 5, coins = [1, 2, 5]<br>输出: 4<br>解释: 有四种方式可以凑成总金额:<br>5=5<br>5=2+2+1<br>5=2+1+1+1<br>5=1+1+1+1+1</p></blockquote><blockquote><p>示例 2:<br>输入: amount = 3, coins = [2]<br>输出: 0<br>解释: 只用面额2的硬币不能凑成总金额3。</p></blockquote><blockquote><p>示例 3:<br>输入: amount = 10, coins = [10]<br>输出: 1</p></blockquote><p><b>分析：</b></p><ol><li>回溯过不了，因为最小的coin会很小，当amount达到5000的时候递归爆炸</li><li>只能是用dp[i]记录组成i元钱有多少种方法，最后返回dp[amount]即可</li><li>这种思想还挺常见的，我要不是以前做过好几道这样的题目可能也想不到，所以你如果也没想到不要担心，多做之后自然就能想到了</li><li>不过这里有一个点和我以前见到用这个方法的题目是不太一样的，那就是这里是对dp进行<code>顺序遍历</code>，以往都是需要<code>逆序遍历</code>的，就为了<code>防止重复利用数字</code>，但这里恰恰是要重复使用！</li></ol><p><b>思路：</b></p><ol><li>建立dp数组，初始化dp[0] = 1</li><li><code>dp[i] += dp[i-coins[j]] for j in range(len(coins)</code></li><li>顺序遍历数组，以示例1中数据为例：<ol><li>dp = [1,0,0,0,0,0] 初始情况</li><li>dp = [1,1,1,1,1,1] 对于coins[0]=1</li><li>dp = [1,1,2,2,3,3] 对于coins[1]=2</li><li>dp = [1,1,2,2,3,4] 对于coins[2]=5</li></ol></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(self, amount, coins)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type amount: int</span></span><br><span class="line"><span class="string">        :type coins: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        :这道题的数据有丶搞的，看样子回溯可能怎样优化都过不了了，只能是dp了</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> amount: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> coins: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        coins.sort()</span><br><span class="line">        dp = [<span class="number">0</span>] * (amount+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(dp)):</span><br><span class="line">                <span class="keyword">if</span> i - c &gt;= <span class="number">0</span>:</span><br><span class="line">                    dp[i] += dp[i-c]</span><br><span class="line">        <span class="comment"># print dp</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">27</span> / <span class="number">27</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">144</span> ms,beats <span class="number">79</span>%</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 516 Longest Palindromic Subsequence</title>
      <link href="/2018/07/09/Leetcode-516-Longest-Palindromic-Subsequence/"/>
      <url>/2018/07/09/Leetcode-516-Longest-Palindromic-Subsequence/</url>
      <content type="html"><![CDATA[<p>给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。</p><blockquote><p>示例 1:<br>输入:<br>“bbbab”<br>输出:<br>4<br>一个可能的最长回文子序列为 “bbbb”。</p></blockquote><a id="more"></a><blockquote><p>示例 2:<br>输入:<br>“cbbd”<br>输出:<br>2<br>一个可能的最长回文子序列为 “bb”。</p></blockquote><p><b>分析：</b></p><ol><li>这道题如果能想到定义<code>dp[i][j]表示s[i:j+1]的最长回文子序列长度</code>的话就很简单了，所以在这里的话，我更想去说一下我是怎么想到要用dp以及这样来定义dp的，我认为这才是有帮助的</li><li>看到示例1的时候，’bbbab’，我想首先依次遍历，然后看此时遍历的字符有没有在之前出现过，如果出现过，以这个两个相同字符为边界，看是否能找到一个回文串，那么中间的字符是什么状态呢？是本身就是回文串呢或者说其子串包含回文串呢，想到这一步我突然意识到，这不就是问题的解依赖于其子问题的解吗，于是想到用dp来解决</li><li>那么怎么定义dp呢，因为按照我的思路是固定住两边观察中间，所以我定义一个二维dp，那么上面说的那种情况就可以写成<code>dp[i][j] = dp[i+1][j-1] + 2</code>，到这里豁然开朗，我知道自己没想错……</li></ol><p><b>思路：</b></p><ol><li><code>if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2</code></li><li><code>else: dp[i][j] = max(dp[i+1][j], dp[i][j-1])</code></li><li>我是用斜向遍历的，对于示例1：<ol><li>(0,1)-&gt;(1,2)-&gt;(2,3)-&gt;(3,4)</li><li>(0,2)-&gt;(1,3)-&gt;(2,4)</li><li>(0,3)-&gt;(2,4)</li><li>(0,4) # 最后结果</li></ol></li><li>实际上你可以用从最后一层向上遍历，那样的代码应该是最优美的！<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindromeSubseq</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># dp[i][j] reps from i to j,the length of LPS</span></span><br><span class="line">        <span class="keyword">if</span> s == s[::<span class="number">-1</span>]: <span class="keyword">return</span> len(s) <span class="comment"># this code helps my runtime decrease from 1500ms to 500ms,beats 99%</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [[<span class="number">1</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="comment"># 处理斜向遍历时i,j的间隔</span></span><br><span class="line">        gap = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">            i,j = <span class="number">0</span>,gap</span><br><span class="line">            <span class="keyword">while</span> j &lt; n:</span><br><span class="line">                <span class="keyword">if</span> gap == <span class="number">1</span>:</span><br><span class="line">                    dp[i][j] += s[i] == s[j]</span><br><span class="line">                <span class="keyword">elif</span> s[i] == s[j]:</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>] + <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = max(dp[i+<span class="number">1</span>][j],dp[i][j<span class="number">-1</span>])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            gap += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>]<span class="comment"># 返回dp中最大的数，实际也就是这个</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dp </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 567 Permutation in String</title>
      <link href="/2018/07/09/Leetcode-567-Permutation-in-String/"/>
      <url>/2018/07/09/Leetcode-567-Permutation-in-String/</url>
      <content type="html"><![CDATA[<p>给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。<br>换句话说，第一个字符串的排列之一是第二个字符串的子串。</p><blockquote><p>示例1:<br>输入: s1 = “ab” s2 = “eidbaooo”<br>输出: True<br>解释: s2 包含 s1 的排列之一 (“ba”).</p></blockquote><a id="more"></a> <blockquote><p>示例2:<br>输入: s1= “ab” s2 = “eidboaoo”<br>输出: False</p></blockquote><p>注意：</p><ol><li>输入的字符串只包含小写字母</li><li>两个字符串的长度都在 [1, 10000] 之间</li></ol><p><b>分析：</b></p><ol><li>标准的滑动窗口解法，示例都太简单，我在这里给出一个例子帮助理解,s1 = ‘abca’,s2 = ‘baabc’</li><li>我们有很多方法判断两个等长的字符串是不是所含字母个数也相同，如collections模块中的Counter函数，如构造一个长度为26的数组，分别记录对应英文字母的个数，这里我们不妨就选后者来进行存储</li><li>对于例子来说:<ol><li>初始化一个d1 = [2,1,1,0,…,0] 记录s1</li><li>初始化一个d2 = [2,2,0,0,…,0] 记录s2中<code>前len(s1)个元素</code>，此时窗口笼罩着<code>&#39;baab&#39;</code></li><li>判断d1 == d2，因为长度为26，且字符串长度不超过10000，故滑动一次只需要比较26次，共滑动<code>len(s2)-len(s1)+1</code>次，所以显然不会超时</li><li>开始滑动，此时窗口笼罩着<code>&#39;aabc&#39;</code>，d2中<code>b减少1</code>，<code>c增加1</code>，再次比较，依此类推，直至遍历结束</li></ol></li></ol><p><b>思路：</b></p><ol><li>用ord()函数将字符串转换成asc码</li><li>防止index error，先判断一下len(s2) &lt; len(s1)？</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkInclusion</span><span class="params">(self, s1, s2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s1: str</span></span><br><span class="line"><span class="string">        :type s2: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(s2) &lt; len(s1): <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        d1 = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        d2 = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(s)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> ord(s) - ord(<span class="string">'a'</span>)</span><br><span class="line">        <span class="comment"># 初始化d1,d2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s1)):</span><br><span class="line">            d1[helper(s1[i])] += <span class="number">1</span></span><br><span class="line">            d2[helper(s2[i])] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> d1 == d2: <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 开始滑动</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s2)-len(s1)):</span><br><span class="line">            d2[helper(s2[i])] -= <span class="number">1</span></span><br><span class="line">            d2[helper(s2[i+len(s1)])] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> d1 == d2: <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="number">102</span> / <span class="number">102</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">60</span> ms,beats <span class="number">99</span>%</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> string </tag>
            
            <tag> sliding window </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 866 Smallest Subtree with all the Deepest Nodes</title>
      <link href="/2018/07/09/leetcode-866-Smallest-Subtree-with-all-the-Deepest-Nodes/"/>
      <url>/2018/07/09/leetcode-866-Smallest-Subtree-with-all-the-Deepest-Nodes/</url>
      <content type="html"><![CDATA[<p>Given a binary tree rooted at root, the depth of each node is the shortest distance to the root.<br>A node is deepest if it has the largest depth possible among any node in the entire tree.<br>The subtree of a node is that node, plus the set of all descendants of that node.<br>Return the node with the largest depth such that it contains all the deepest nodes in it’s subtree.</p><p><img src="/images/leetcode_866.png" alt="题目描述"></p><a id="more"></a><p><b>分析：</b></p><ol><li>标准的bfs问题，我们只需要记录最后一层的所有节点，然后获取他们的父节点，依次类推，当父节点的数量只有1个时，说明找到了最后所求</li><li>bfs中队列存储数据格式为<code>(node,parent_node)</code>，初始化为<code>(root,None)</code>,让我们用字典能建立对应关系!</li></ol><p><b>思路：</b></p><ol><li>我们在用bfs遍历时，用一个字典记录下结点与其父节点的对应关系，并用一个列表记录下每一层的所有结点，当bfs遍历结束时，列表中所存结点即为最后一层结点</li><li>对列表中结点进行迭代，用一个集合来记录父节点，当集合长度为1时，循环结束</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtreeWithAllDeepest</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        Q = collections.deque([(root,<span class="keyword">None</span>)])</span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">while</span> Q:</span><br><span class="line">            iters = len(Q)</span><br><span class="line">            rec = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(iters):</span><br><span class="line">                a,b = Q.popleft()</span><br><span class="line">                rec.append(a)</span><br><span class="line">                <span class="keyword">if</span> a.left: Q.append((a.left,a))</span><br><span class="line">                <span class="keyword">if</span> a.right: Q.append((a.right,a))</span><br><span class="line">                <span class="comment"># 建立对应关系</span></span><br><span class="line">                d[a] = b</span><br><span class="line">        <span class="comment"># rec records the last level node</span></span><br><span class="line">        s = set(rec)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> len(s) != <span class="number">1</span>:</span><br><span class="line">            s = set()</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> rec:</span><br><span class="line">                s.add(d[node])</span><br><span class="line">            res += rec</span><br><span class="line">            rec = list(s)</span><br><span class="line">        <span class="keyword">return</span> list(s)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">57</span> / <span class="number">57</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">24</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> bfs </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 865 Shortest Path to Get All keys</title>
      <link href="/2018/07/09/leetcode-865-Shortest-Path-to-Get-All-keys/"/>
      <url>/2018/07/09/leetcode-865-Shortest-Path-to-Get-All-keys/</url>
      <content type="html"><![CDATA[<p>We are given a 2-dimensional grid. “.” is an empty cell, “#” is a wall, “@” is the starting point, (“a”, “b”, …) are keys, and (“A”, “B”, …) are locks.<br>We start at the starting point, and one move consists of walking one space in one of the 4 cardinal directions.  We cannot walk outside the grid, or walk into a wall.  If we walk over a key, we pick it up.  We can’t walk over a lock unless we have the corresponding key.<br>For some 1 &lt;= K &lt;= 6, there is exactly one lowercase and one uppercase letter of the first K letters of the English alphabet in the grid.  This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.<br>Return the lowest number of moves to acquire all keys.  If it’s impossible, return -1.</p><blockquote><p>Example 1:<br>Input: [“@.a.#”,”###.#”,”b.A.B”]<br>Output: 8</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: [“@..aA”,”..B#.”,”….b”]<br>Output: 6</p></blockquote><p>Note:</p><ol><li>1 &lt;= grid.length &lt;= 30</li><li>1 &lt;= grid[0].length &lt;= 30</li><li>grid[i][j] contains only ‘.’, ‘#’, ‘@’, ‘a’-‘f’ and ‘A’-‘F’</li><li>The number of keys is in [1, 6].  Each key has a different letter and opens exactly one lock.</li></ol><p><b>分析：</b></p><ol><li>这道题就像我在498题中说的迷宫问题一样，求到达某点的最短路径，显然是用bfs</li><li>那么这和普通的bfs有什么不同呢，现在给出一个具体实例[[@…a],[.###A],[b.BCc]]，你会发现这里要走回头路的，那么如果凭空就可以来回走的话，会是一个死循环，但我们稍微仔细思考一下，我认为想到<code>走回头路的条件是获得一个新key</code>这个点应该不难想到，那么我们只需要将标准bfs写法中的visited中key值变为(i,j,key)即可</li><li>虽然我做出来了，但是我的代码目前比较凌乱（因为经过多次修改），现在借助一位老哥的代码，和我的思路是完全一样的，来看一看具体如何实现</li></ol><p><b>思路：</b></p><ol><li>首先遍历一次数组，记录下起始位置，即‘@’，以及key的数量，即小写字母的数量，记为numOfKey</li><li>队列中的每项元素具有如下结构<code>(i,j,step,key,collectedkey)</code>:<ol><li>i,j表示位置,<code>step</code>代表bfs的深度</li><li><code>key</code>代表目前能走的格子从，初始化为<code>&#39;abcdef.@&#39;</code>，每收集到一个小写字母便将对应的大写字母加入key中</li><li><code>collectedkey</code>代表已经收集的key的数量，如果<code>collectedkey = numOfKey</code>，则代表成功</li></ol></li><li>用visited记录已经走过的状态，避免无限循环，visited中值为(i,j,key)，保证只有在收集到新key之后才能走回头路</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestPathAllKeys</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n, m = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">        numOfKeys = <span class="number">0</span></span><br><span class="line">        direc = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">-1</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">-1</span>,<span class="number">0</span>]]</span><br><span class="line">        visited = set()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">'@'</span>:</span><br><span class="line">                    starti = i</span><br><span class="line">                    startj = j</span><br><span class="line">                <span class="keyword">elif</span> grid[i][j] <span class="keyword">in</span> <span class="string">"abcdef"</span>:</span><br><span class="line">                    numOfKeys += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        deque = collections.deque()</span><br><span class="line">        deque.append([starti, startj, <span class="number">0</span>, <span class="string">".@abcdef"</span>, <span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> deque:</span><br><span class="line">            i, j, steps, keys, collectedKeys = deque.popleft()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> grid[i][j] <span class="keyword">in</span> <span class="string">"abcdef"</span> <span class="keyword">and</span> grid[i][j].upper() <span class="keyword">not</span> <span class="keyword">in</span> keys:</span><br><span class="line">                keys += grid[i][j].upper()</span><br><span class="line">                collectedKeys += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> collectedKeys == numOfKeys:</span><br><span class="line">                <span class="keyword">return</span> steps</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> x, y <span class="keyword">in</span> direc:</span><br><span class="line">                ni = i+x</span><br><span class="line">                nj = j+y</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=ni&lt;n <span class="keyword">and</span> <span class="number">0</span>&lt;=nj&lt;m <span class="keyword">and</span> grid[ni][nj] <span class="keyword">in</span> keys:</span><br><span class="line">                    <span class="keyword">if</span> (ni, nj, keys) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        visited.add((ni,nj,keys))</span><br><span class="line">                        deque.append([ni, nj, steps + <span class="number">1</span>, keys, collectedKeys])</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">35</span> / <span class="number">35</span> test cases passed.</span><br><span class="line">difficulty: hard</span><br><span class="line">Runtime: <span class="number">504</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 513 Find Bottom Left Tree Value</title>
      <link href="/2018/07/07/Leetcode-513-Find-Bottom-Left-Tree-Value/"/>
      <url>/2018/07/07/Leetcode-513-Find-Bottom-Left-Tree-Value/</url>
      <content type="html"><![CDATA[<p><img src="/images/leetcode_513.png" alt=""></p><a id="more"></a><p><b>分析：</b></p><ol><li>这道题是要找最左下的结点，我们可以先找到最低一层，然后找到该层最左边的结点就OK了</li><li>显然bfs可以很好的完成按层查找的功能</li></ol><p><b>思路：</b></p><ol><li>我们使用一个None结点代表一层的遍历结束，用一个<code>lastnode</code>变量记录上一个访问的结点</li><li>如果<code>lastnode = None</code>，说明此时遍历的结点就是该层的第一个结点，即最左边的结点</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findBottomLeftValue</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 标准的bfs写法，一定要烂熟于心！</span></span><br><span class="line">        Q = collections.deque([root,<span class="keyword">None</span>])</span><br><span class="line">        lastnode,res = <span class="keyword">None</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> Q:</span><br><span class="line">            node = Q.popleft()</span><br><span class="line">            <span class="keyword">if</span> lastnode == <span class="keyword">None</span>:</span><br><span class="line">                res = node.val</span><br><span class="line">            lastnode = node</span><br><span class="line">            <span class="comment"># 处理一层结束时的情况</span></span><br><span class="line">            <span class="keyword">if</span> node == <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> Q:</span><br><span class="line">                    <span class="keyword">return</span> res</span><br><span class="line">                Q.append(<span class="keyword">None</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.left: Q.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right: Q.append(node.right)</span><br><span class="line"></span><br><span class="line"><span class="number">74</span> / <span class="number">74</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">36</span> ms,beats <span class="number">100</span>%</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 498 Diagonal Traverse</title>
      <link href="/2018/07/05/Leetcode-498-Diagonal-Traverse/"/>
      <url>/2018/07/05/Leetcode-498-Diagonal-Traverse/</url>
      <content type="html"><![CDATA[<p><img src="/images/leetcode_498_1.png" alt=""><br><a id="more"></a><br><b>分析：</b></p><ol><li>这道题像我们之前做的那种走迷宫的问题，给一个矩阵，0代表可以通信，1代表有障碍，问从左上走到右下最短距离是多少，走不到返回-1，这种就是标准的bfs问题</li><li>这道题中我们按层依次遍历，始终从左下到右上，只要额外判断一下本身该是从右上到左下的层数即可</li></ol><p><img src="/images/leetcode_498_2.png" alt=""></p><p><b>思路：</b></p><ol><li>用visited记录已经遍历过的下标，rec记录每一层的所有元素，level判断奇偶来决定是否要反转rec</li><li>用（-1，-1）作为每一层的终止条件，处理下最后只剩(-1,-1)的情况</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDiagonalOrder</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]: <span class="keyword">return</span> []</span><br><span class="line">        m,n = len(matrix),len(matrix[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        visited = set()</span><br><span class="line">        res,rec,level = [],[],<span class="number">0</span></span><br><span class="line">        Q = collections.deque([(<span class="number">0</span>,<span class="number">0</span>),(<span class="number">-1</span>,<span class="number">-1</span>)])</span><br><span class="line">        <span class="keyword">while</span> Q:</span><br><span class="line">            i,j = Q.popleft()</span><br><span class="line">            <span class="keyword">if</span> i == j == <span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">if</span> level &amp; <span class="number">1</span>: rec = rec[::<span class="number">-1</span>]</span><br><span class="line">                res.extend(rec)</span><br><span class="line">                level += <span class="number">1</span></span><br><span class="line">                rec = []</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> Q: <span class="keyword">break</span></span><br><span class="line">                Q.append((<span class="number">-1</span>,<span class="number">-1</span>))</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i,j) <span class="keyword">in</span> visited: <span class="keyword">continue</span></span><br><span class="line">            visited.add((i,j))</span><br><span class="line">            rec.append(matrix[i][j])</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>&lt;=i+<span class="number">1</span>&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=j&lt;n:</span><br><span class="line">                Q.append((i+<span class="number">1</span>,j))</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>&lt;=i&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=j+<span class="number">1</span>&lt;n:</span><br><span class="line">                Q.append((i,j+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">O(m*n) time, O(m*n) space</span><br><span class="line"><span class="number">32</span> / <span class="number">32</span> test cases passed.</span><br><span class="line">difficluty: medium</span><br><span class="line">Runtime: <span class="number">164</span> ms,beats <span class="number">100</span>%</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 503 Next Greater Element II</title>
      <link href="/2018/07/04/Leetcode-503-Next-Greater-Element-II/"/>
      <url>/2018/07/04/Leetcode-503-Next-Greater-Element-II/</url>
      <content type="html"><![CDATA[<p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p><blockquote><p>示例 1:<br>输入: [1,2,1]<br>输出: [2,-1,2]<br>解释: 第一个 1 的下一个更大的数是 2；<br>数字 2 找不到下一个更大的数；<br>第二个 1 的下一个最大的数需要循环搜索，结果也是 2。<br>注意: 输入数组的长度不会超过 10000。</p></blockquote><a id="more"></a><p><b>分析：</b></p><ol><li>如果你还没解决next Greater Element I，那么建议你先看一下I的解法，具体思路见<a href="https://buptwc.github.io/2018/07/03/Leetcode-496-Next-Greater-Element-I" target="_blank" rel="noopener">Leetcode-496-Next-Greater-Element-I</a>，看完之后本题解法呼之欲出</li><li>我们只需要对给定的nums数组*2即可，如示例1中nums，我们将其改成[1,2,1, 1,2,1]，用I中思想解即可</li><li>对于数组中最大的数，全设为-1即可</li></ol><p><b>思路：</b></p><ol><li>初始化res数组，全为-1，len(res) = len(nums) </li><li>利用栈存储数据和其下标，因为我们将nums长度翻倍了，故需判断一下下标是否小于len(res)</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElements</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> []</span><br><span class="line">        res = [<span class="number">-1</span>] * len(nums)</span><br><span class="line">        </span><br><span class="line">        nums += nums</span><br><span class="line">        stack = [(nums[<span class="number">0</span>],<span class="number">0</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> nums[i] &gt; stack[<span class="number">-1</span>][<span class="number">0</span>]:</span><br><span class="line">                val,index = stack.pop()</span><br><span class="line">                <span class="keyword">if</span> index &lt; len(res):</span><br><span class="line">                    res[index] = nums[i]</span><br><span class="line">            stack.append((nums[i],i))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="number">224</span> / <span class="number">224</span> test cases passed.</span><br><span class="line">diffculty: medium</span><br><span class="line">Runtime: <span class="number">548</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 483 Smallest Good Base</title>
      <link href="/2018/07/04/Leetcode-483-Smallest-Good-Base/"/>
      <url>/2018/07/04/Leetcode-483-Smallest-Good-Base/</url>
      <content type="html"><![CDATA[<p>对于一个正整数n，如果将n化作k进制表示后，n的所有位全是1，我们将k叫做n的一个good base<br>现在给定一个字符串代表n，要求你以字符串的形式返回n的最小good base</p><blockquote><p>Example 1:<br>Input: “13”<br>Output: “3”<br>Explanation: 13 base 3 is 111.</p></blockquote><p><code>这道题超有意思！！！</code><br><a id="more"></a></p><blockquote><p>Example 2:<br>Input: “4681”<br>Output: “8”<br>Explanation: 4681 base 8 is 11111.</p></blockquote><blockquote><p>Example 3:<br>Input: “1000000000000000000”<br>Output: “999999999999999999”<br>Explanation: 1000000000000000000 base 999999999999999999 is 11.</p></blockquote><p>Note:</p><ol><li>n的取值范围为 [3, 10^18]</li><li>给出的代表n的字符串你可以认为是始终合法的，不存在前导0的情况</li></ol><p><b>分析：</b></p><ol><li>对于给定的n，假设我们将其划为<code>k进制数</code>，那么k的可能取值有2，n-1，在n比较大的时候显然这种方法是会超时的</li><li>那么我们需要反向思维一下，对于给定的n，将其划为<code>长度为k</code>的字符串，即<code>&#39;1&#39;*k</code>，那么此时的k的取值最多到60，因为 2^60 &gt; 10^18，我们固定住k，去看能否找到一个x使得<code>1+x+x^2+...+x^(k-1) = n</code>，k从大往小遍历，第一个找到的x就是最小的good base</li><li>截至到上一步都很容易想到，那么关键在对于一个固定k，我们如何去计算这个x呢，根据等比数列的求和公式我们知道上式左边可化为 <code>(x^k-1)/(x-1)</code>，但这个式子是不可直接解的（虽然只有一个未知数），那么这时又需要反向思维一下了</li><li>n = 1 + x + x^2 + … + x^(k-1),对于该式，我们可以得到<ol><li>n &gt; x^(k-1)，显然</li><li>n &lt; (x+1)^(k-1)，将右边式子略作展开，显然，根据discuss中所提，这就是二项式定理</li><li>结合上面两个式子，左右同时开k-1次方，我们不妨记c为n开k-1次方的结果，则有 x &lt; c &lt; x+1</li><li>这里一要注意，3中式子是<code>严格小于</code>和<code>严格大于</code>的，并且c一定不可能是整数（想通这一点很关键，因为c是小数的话，我们只需要用int(c)即可得到x，但如果c是整数，那么x = int(c)-1，因为是严格小于)</li></ol></li><li>根据4中步骤对于每一个k可以得到一个x值，我们接下来只需要判断3中式子是否成立了，即<code>(x^k-1)/(x-1) == n</code></li></ol><p><b>注意：</b></p><ol><li>这道题其实是有漏洞的，因为当n&gt;10^16时，可能是和计算机内部存储数的方式有关，有：<ol><li>n^1.0 = n^1 但 n^1.0 - 1 != n^1 - 1</li></ol></li><li>这也是为什么代码中最后有一个return str(res)</li><li>时间复杂度是O(logn)，因为我确定的k&lt;60，其实就是将n默认最大，然后取2的对数得出来的结果</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallestGoodBase</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = int(n)</span><br><span class="line">        res = n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">60</span>,<span class="number">1</span>,<span class="number">-1</span>):</span><br><span class="line">            c = math.fabs(<span class="number">1.0</span>/(k<span class="number">-1</span>))</span><br><span class="line">            x = int(math.ceil(n**c<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> x &gt; <span class="number">1</span> <span class="keyword">and</span>  (x**k<span class="number">-1</span>) // (x<span class="number">-1</span>) == n:</span><br><span class="line">                <span class="keyword">return</span> str(x)</span><br><span class="line">        <span class="keyword">return</span> str(res)</span><br><span class="line"></span><br><span class="line">O(logn) time, O(<span class="number">1</span>) space</span><br><span class="line"><span class="number">106</span> / <span class="number">106</span> test cases passed.</span><br><span class="line">Status: Accepted</span><br><span class="line">Runtime: <span class="number">42</span> ms,beats <span class="number">65.63</span>%</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 496 Next Greater Element I</title>
      <link href="/2018/07/03/Leetcode-496-Next-Greater-Element-I/"/>
      <url>/2018/07/03/Leetcode-496-Next-Greater-Element-I/</url>
      <content type="html"><![CDATA[<p>给定两个没有重复元素的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。</p><p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出-1。</p><blockquote><p>示例 1:<br>输入: nums1 = [4,1,2], nums2 = [1,3,4,2].<br>输出: [-1,3,-1]<br>解释:<br>   对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。<br>   对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。<br>   对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。</p></blockquote><a id="more"></a><blockquote><p>示例 2:<br>输入: nums1 = [2,4], nums2 = [1,2,3,4].<br>输出: [3,-1]<br>解释:<br>   对于num1中的数字2，第二个数组中的下一个较大数字是3。<br>   对于num1中的数字4，第二个数组中没有下一个更大的数字，因此输出 -1。</p></blockquote><p>注意:</p><ol><li>nums1和nums2中所有元素是唯一的。</li><li>nums1和nums2 的数组大小都不超过1000。</li></ol><p><b>分析：</b></p><ol><li>这道题看英文的时候有点绕，意思是对于nums1中的数，在nums2中找到其对应的位置，然后在对应位置的右侧找到第一个比其值大的数</li><li>数组中没有重复数字且长度都不超过1000，说明这道题数据要求比较低，n^2的方法也可通过</li></ol><p><b>思路：</b></p><ol><li>我们直接将nums2中的所有数对应的greater number找出来，用字典保存，然后遍历nums1，依次输出即可</li><li>使用一个栈来记录数据，如对于示例1中的[1,3,4,2],应按照如下步骤：<ol><li>nums[0] = 1, stack is empty , so stack = [1]</li><li>nums[1] = 3, nums[1] &gt; stack[-1],so d[1] = 3,now stack = [3]</li><li>nums[2] = 4, nums[2] &gt; stack[-1],so d[3] = 4,now stack = [4]</li><li>nums[3] = 2, nums[3] &lt; stack[-1],so stack = [4,2]</li><li>now d = {1:3, 3:4}, for num in nums1, 有key则输出对应值，没key则输出-1</li></ol></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElement</span><span class="params">(self, findNums, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type findNums: List[int]</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>] &lt; num:</span><br><span class="line">                d[stack.pop()] = num</span><br><span class="line">            stack.append(num)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> findNums:</span><br><span class="line">            <span class="keyword">if</span> val <span class="keyword">in</span> d:</span><br><span class="line">                res.append(d[val])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">O(n) time, O(n) space</span><br><span class="line"><span class="number">17</span> / <span class="number">17</span> test cases passed.</span><br><span class="line">diffculty: easy</span><br><span class="line">Runtime: <span class="number">58</span> ms,beats <span class="number">60.10</span>%</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 495 Teemo Attacking</title>
      <link href="/2018/07/03/Leetcode-495-Teemo-Attacking/"/>
      <url>/2018/07/03/Leetcode-495-Teemo-Attacking/</url>
      <content type="html"><![CDATA[<p>在《英雄联盟》的世界中，有一个叫“提莫”的英雄，他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。现在，给出提莫对艾希的攻击时间序列和提莫攻击的中毒持续时间，你需要输出艾希的中毒状态总时长。<br>你可以认为提莫在给定的时间点进行攻击，并立即使艾希处于中毒状态。</p><blockquote><p>示例1:<br>输入: [1,4], 2<br>输出: 4<br>原因: 在第1秒开始时，提莫开始对艾希进行攻击并使其立即中毒。中毒状态会维持2秒钟，直到第2秒钟结束。<br>在第4秒开始时，提莫再次攻击艾希，使得艾希获得另外2秒的中毒时间。<br>所以最终输出4秒。</p></blockquote><a id="more"></a><blockquote><p>示例2:<br>输入: [1,2], 2<br>输出: 3<br>原因: 在第1秒开始时，提莫开始对艾希进行攻击并使其立即中毒。中毒状态会维持2秒钟，直到第2秒钟结束。<br>但是在第2秒开始时，提莫再次攻击了已经处于中毒状态的艾希。<br>由于中毒状态不可叠加，提莫在第2秒开始时的这次攻击会在第3秒钟结束。<br>所以最终输出3。</p></blockquote><p>注意：</p><ol><li>你可以假定时间序列数组的总长度不超过10000。</li><li>你可以假定提莫攻击时间序列中的数字和提莫攻击的中毒持续时间都是非负整数，并且不超过10,000,000。</li></ol><p><b>分析：</b></p><ol><li>上单提莫有什么用？</li><li>艾希600码的手，提莫还上去A呢，不先被艾希射炸？</li><li>@今が最高 我猜你段位不超过青铜，嘻嘻</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPoisonedDuration</span><span class="params">(self, timeSeries, duration)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type timeSeries: List[int]</span></span><br><span class="line"><span class="string">        :type duration: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> timeSeries: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        timeSeries.sort()</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(timeSeries)):</span><br><span class="line">            res += min(duration, timeSeries[i]-timeSeries[i<span class="number">-1</span>])</span><br><span class="line">        <span class="comment"># 上面循环没有计算最后一次中毒</span></span><br><span class="line">        <span class="keyword">return</span> res + duration</span><br><span class="line"></span><br><span class="line">O(nlogn) time, O(<span class="number">1</span>) space</span><br><span class="line"><span class="number">39</span> / <span class="number">39</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">183</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Leetcode 416 Partition Equal Subset Sum</title>
      <link href="/2018/07/03/Leetcode-416-Partition-Equal-Subset-Sum/"/>
      <url>/2018/07/03/Leetcode-416-Partition-Equal-Subset-Sum/</url>
      <content type="html"><![CDATA[<p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>注意:<br>每个数组中的元素不会超过 100<br>数组的大小不会超过 200</p><blockquote><p>示例 1:<br>输入: [1, 5, 11, 5]<br>输出: true<br>解释: 数组可以分割成 [1, 5, 5] 和 [11].</p></blockquote><a id="more"></a><blockquote><p>示例 2:<br>输入: [1, 2, 3, 5]<br>输出: false<br>解释: 数组不能分割成两个元素和相等的子集.</p></blockquote><p><b>分析：</b></p><ol><li>首先，若sum(nums) % 2 != 0，则显然不可分</li><li>题目演变成在数组中找寻是否有若干个数的和为target，target = sum(nums) / 2</li><li>数组大小不超过200，元素不超过100，则target大小不超过20000</li></ol><p><b>思路：</b></p><ol><li>建立dp数组，其中dp[i] = 1表示nums中有若干数的和为i，则最后返回dp[target]即可，初始化dp[0] = 1</li><li>依次对nums中的数进行分析，如示例1中[1,5,11,5]，首先对nums[0]进行分析，则可得出dp[1] = 1(因为dp[0] = 1)，然后对nums[1]进行分析，则可得出dp[5] = 1,dp[6] = 1(因为dp[0] = 1,dp[1] = 1)，依次类推</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        s = sum(nums)</span><br><span class="line">        <span class="keyword">if</span> s &amp; <span class="number">1</span>: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        target = s / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        dp = [<span class="number">0</span>] * (target+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(nums)):</span><br><span class="line">        <span class="comment"># 必须反向遍历，正向遍历会出现错误</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(target,nums[i]<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> dp[j-nums[i]]: dp[j] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">False</span>,<span class="keyword">True</span>][dp[target]]</span><br><span class="line"></span><br><span class="line"><span class="number">104</span> / <span class="number">104</span> test cases passed.</span><br><span class="line">diffculty: medium</span><br><span class="line">Runtime: <span class="number">926</span> ms,beats <span class="number">63.91</span>%</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 494 Target Sum</title>
      <link href="/2018/07/03/Leetcode-494-Target-Sum/"/>
      <url>/2018/07/03/Leetcode-494-Target-Sum/</url>
      <content type="html"><![CDATA[<p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p><p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><blockquote><p>示例 1:<br>输入: nums: [1, 1, 1, 1, 1], S: 3<br>输出: 5<br>解释:<br>-1+1+1+1+1 = 3<br>+1-1+1+1+1 = 3<br>+1+1-1+1+1 = 3<br>+1+1+1-1+1 = 3<br>+1+1+1+1-1 = 3<br>一共有5种方法让最终目标和为3。</p></blockquote><a id="more"></a><p>注意:</p><ol><li>数组的长度不会超过20，并且数组中的值全为正数。</li><li>初始的数组的和不会超过1000。</li><li>保证返回的最终结果为32位整数。</li></ol><p><b>分析：</b></p><ol><li>这道题可以单纯的用暴力法解决，也就是对每个元素分别进行一次正负的累加，复杂度为2^n，因为n不超过20，故也就100w左右，但是在leetcode上同样的解法c++和java可以通过，python是无法通过的</li><li>这里介绍discuss里一位大神提出来的超帅的数学解法，这道题中我们加正负号无非是将nums分为两个子集<code>p</code>,<code>n</code>，p中元素全部加<code>正号</code>，n中元素全部加<code>负号</code>，使得<code>sum(p) - sum(n) = S</code>，而本身又有<code>sum(p) + sum(n) = sum(nums)</code>，故两式相加化简得<code>sum(p) = (sum(nums)+S) / 2</code></li><li>那么这个式子直接给出了一个信息，也就是如果能找到p，则必有<code>sum(nums)+S % 2 == 0</code>这个条件，这个条件可以帮我们快速判断是否有解。</li><li>那么此时题目就变成给定一个数组nums，求有多少组不同的p，使得sum(p) = target，直接dp可解</li></ol><p><b>思路：</b></p><ol><li>建立dp，dp[i] = j代表数组nums中有j组子集的和为i，初始dp[0] = 1</li><li>如nums = [1,1,1,1,1]，按照如下步骤分析<ol><li>对nums[0]分析，则得dp[1] = 1(因为dp[0] = 1)</li><li>对nums[1]分析，则得dp[1] = 2,dp[2] = 1(因为dp[0] = 1,dp[1] = 1)</li><li>对nums[2]分析，则得dp[1] = 3,dp[2] = 2,d[3] = 1,依次类推</li></ol></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span><span class="params">(self, nums, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type S: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> sum(nums) &lt; S: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (sum(nums) + S) &amp; <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        target = (sum(nums) + S) / <span class="number">2</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (target+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">for</span> val <span class="keyword">in</span> range(target, nums[i]<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> dp[val-nums[i]]:</span><br><span class="line">                    dp[val] += dp[val-nums[i]]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">O(n*sum(nums)) time, O(sum(nums)) space</span><br><span class="line"><span class="number">139</span> / <span class="number">139</span> test cases passed.</span><br><span class="line">diffculty: medium</span><br><span class="line">Runtime: <span class="number">91</span> ms,beats <span class="number">95.24</span>%</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dp </tag>
            
            <tag> Backtracking </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 491 Increasing Subsequences</title>
      <link href="/2018/07/03/Leetcode-491-Increasing-Subsequences/"/>
      <url>/2018/07/03/Leetcode-491-Increasing-Subsequences/</url>
      <content type="html"><![CDATA[<p>给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。</p><blockquote><p>示例:<br>输入: [4, 6, 7, 7]<br>输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]</p></blockquote><a id="more"></a><p>说明:</p><ol><li>给定数组的长度不会超过15。</li><li>数组中的整数范围是 [-100,100]。</li><li>给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。</li></ol><p><b>分析：</b></p><ol><li>如果你看出来这道题和最长上升子序列是一模一样的话那么答案做出来也就不难了，这也是为什么我把这道题归入dp类的原因</li><li>我们可以先思考一下LIS问题是怎么处理的，我们使用dp[i]表示前i个数字组成的序列中以nums[i]结尾的最长上升子序列的长度，dp[i] = max([dp[j]+1 for j in range(i) if nums[j] &lt; nums[i]]) </li><li>根据这个思路我们可以想到这道题其实也可以用一样的方法，我们使用一个字典d，d[i]表示以nums[i]结尾的上升子序列，初始化所有的d[i] = [[nums[i]]]</li><li>则可获得递推式 d[i].append(l+nums[i]) for j in range(i) if nums[j] &lt;= nums[i] for l in d[j] </li><li>当然严格来说上式不能算是递推式，我们直接用给出的具体实例来看一下是怎么运作的，初始化d = {0:[[4]],1:[[6]],2:[[7]],3:[[7]]}，我们从1开始分析，nums[1] &gt; nums[0]，所以d[1] = [[6],[4,6]]，依次类推d[2] = [[4,7],[6,7],[4,6,7]]，d[3] = …</li></ol><p><b>思路：</b></p><ol><li>递推式如分析中所示，但考虑到4,6,7,7,7这种情况，计算第三个7的时候会出现重复情况，所以用一个集合来确保答案中没有重复元素，然后又因为list本身不可hash，所以转化成元祖来进行hash即可</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSubsequences</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 初始化字典</span></span><br><span class="line">        d = &#123;i:[[nums[i]]] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt;= nums[j]:</span><br><span class="line">                    <span class="keyword">for</span> l <span class="keyword">in</span> d[j]:</span><br><span class="line">                        d[i].append(l+[nums[i]])</span><br><span class="line">        </span><br><span class="line">        s = set()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> d[i]:</span><br><span class="line">            <span class="comment"># 因为字典中本身存在长度为1的list，需要我们排除</span></span><br><span class="line">                <span class="keyword">if</span> len(l) &lt; <span class="number">2</span>: <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> tuple(l) <span class="keyword">in</span> s: <span class="keyword">continue</span></span><br><span class="line">                s.add(tuple(l))</span><br><span class="line">                res.append(l)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="number">57</span> / <span class="number">57</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">984</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 862 Shortest Subarray with Sum at Least K</title>
      <link href="/2018/07/02/Leetcode-862-Shortest-Subarray-with-Sum-at-Least-K/"/>
      <url>/2018/07/02/Leetcode-862-Shortest-Subarray-with-Sum-at-Least-K/</url>
      <content type="html"><![CDATA[<p>Return the length of the shortest, non-empty, contiguous subarray of A with sum at least K.<br>If there is no non-empty subarray with sum at least K, return -1.</p><blockquote><p>Example 1:<br>Input: A = [1], K = 1<br>Output: 1</p></blockquote><blockquote><p>Example 2:<br>Input: A = [1,2], K = 4<br>Output: -1</p></blockquote><a id="more"></a><blockquote><p>Example 3:<br>Input: A = [2,-1,2], K = 3<br>Output: 3</p></blockquote><p>Note:</p><ol><li>1 &lt;= A.length &lt;= 50000</li><li>-10 ^ 5 &lt;= A[i] &lt;= 10 ^ 5</li><li>1 &lt;= K &lt;= 10 ^ 9</li></ol><p><strong>这题思路来源于@lee215大神，我没想到用队列来保存下标，只想到了哪些数可以不考虑（见分析第2步中提到的假设）</strong></p><p><b>分析：</b></p><ol><li>显然，我们会想到使用dp[i]记录sum(A[:i])，那么这道题就变成了，给定一个数组dp,找到一组i,j，使得dp[j]-dp[i]&gt;=K，且j-i尽量小！</li><li>数据长度达到50000，显然不能使用O(n^2)复杂度的方法，我们得想办法让i,j只走一遍</li><li>用一个简单的示例来分析，设 A = [4,-1,2,3],，K = 5，那么dp = [0,4,3,5,8]，我们从dp数组的第2个数开始分析，（假设来了个-1，那么因为-1比0小，后面任意一个数val如若满足val-0&gt;K,那么val+1也一定大于K，且-1所在的位置i显然能获得更优解，所以0这个位置就失去了意义），现在考虑示例，来了个4，我们发现4-0小于5，我们怎么对4进行处理呢，因为考虑到之后或许会出现一个足够大的数，比如9，那么4相对于0是更优的，但也有可能只来一个8，那么4就没作用了，所以先暂且保留观察。等到来了一个5以上的数，我们依次对保留的数（目前是0，4）进行判断得最优解。</li><li>接下来来了个3，那么根据上面提到的论点，4将会被舍弃，但3比0要大，故此时0，3保留。</li><li>然后来了个5，5-0&gt;=5，故找到一组i,j，记录下来，然后判断 5-3&gt;=5 ?如若确实大于，即再次找到一组i,j，若小于，则5保留（考虑到之后或许来了个10），依次类推</li></ol><p><b>思路：</b></p><ol><li>建立一个队列记录保留数字，初始为0</li><li>依次对dp中的数进行分析，如果dp[i] - dp[Q[0]] &gt;= K，则记录一次i,j</li><li>如果dp[i] &lt; dp[Q[-1]]，则舍弃Q[-1]</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestSubarray</span><span class="params">(self, A, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 如若有比K大的数，则直接返回1</span></span><br><span class="line">        <span class="keyword">if</span> max(A) &gt;= K: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 记录和，dp[i] = sum(A[:i])</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (len(A)+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(dp)):</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + A[i<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        res = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="comment"># 初始化队列</span></span><br><span class="line">        Q = Queue.deque([<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(dp)):</span><br><span class="line">        <span class="comment"># 思路中第2步</span></span><br><span class="line">            <span class="keyword">while</span> Q <span class="keyword">and</span> dp[i]-dp[Q[<span class="number">0</span>]] &gt;= K:</span><br><span class="line">                res = min(res,i-Q.popleft())</span><br><span class="line">            <span class="comment"># 思路中第3步</span></span><br><span class="line">            <span class="keyword">while</span> Q <span class="keyword">and</span> dp[i]&lt;dp[Q[<span class="number">-1</span>]]:</span><br><span class="line">                Q.pop()</span><br><span class="line">            Q.append(i) </span><br><span class="line">        <span class="keyword">return</span> [res,<span class="number">-1</span>][res==float(<span class="string">'inf'</span>)]</span><br><span class="line"></span><br><span class="line">O(n) time, O(n) space</span><br><span class="line"><span class="number">93</span> / <span class="number">93</span> test cases passed.</span><br><span class="line">difficulty: hard</span><br><span class="line">Runtime: <span class="number">693</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
            <tag> two pointers </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 863 All Nodes Distance K in Binary Tree</title>
      <link href="/2018/07/02/Leetcode-863-All-Nodes-Distance-K-in-Binary-Tree/"/>
      <url>/2018/07/02/Leetcode-863-All-Nodes-Distance-K-in-Binary-Tree/</url>
      <content type="html"><![CDATA[<p><img src="/images/leetcode_863_1.png" alt=""><br><a id="more"></a><br><b>这道题思想非常简单，但是可能我代码写得有点复杂（因为我回溯用的不好），先着重看思路把，代码实现方法尽量讲一讲</b></p><p><b>分析：</b></p><ol><li>我们先考虑最简单的情况，如果根结点就是目标节点，那么找离根结点距离为K的结点很容易，使用bfs找到第k层所有结点即可，现在定义getAns(root,K)来处理这种情况！</li><li>如下图，如果我们找到目标结点设为self.root，那么圆圈所圈部分中的结果，可直接用getAns(self.root,K)得到<br><img src="/images/leetcode_863_2.png" alt=""></li><li>那么圆圈外的部分，我们应该怎么得到呢？如果我们能想办法将圆圈外的部分也化为以目标节点为根节点的形式就直接解决了， 这次看一个复杂的情形，我们需要把圆圈内所有箭头（即目标节点至根结点路径中所有箭头）反转，才能构建出我们想要的形式，构建完之后使用getAns(self.root,K)计算结果。<br><img src="/images/leetcode_863_3.png" alt=""></li></ol><p><b>思路：</b><br><b>着重讲下search()函数</b></p><ol><li>当我们找到目标节点后，先计算一次结果，如分析中第2步。然后将其左右孩子全部抹去，将其本身父结点设为其孩子节点。</li><li>而为了尽量不改变父节点本身的结构，如左孩子为目标节点，则将父结点的left先指向None,方便之后再指向父节点的父节点，依次类推。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 别看代码挺长的，其实search()函数里面做的事是重复的，只是分了左右节点而已，思路还是比较明朗</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.res = []</span><br><span class="line">        self.root = <span class="keyword">None</span></span><br><span class="line">        self.visited = set()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distanceK</span><span class="params">(self, root, target, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type target: TreeNode</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> target: <span class="keyword">return</span> self.getAns(root, K)</span><br><span class="line">        self.search(root, target,K)</span><br><span class="line">        self.res += self.getAns(self.root, K)</span><br><span class="line">        <span class="keyword">return</span> list(set(self.res))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 当根节点为目标节点时，使用bfs找到第k层的所有节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getAns</span><span class="params">(self,root,K)</span>:</span></span><br><span class="line">        Q = Queue.deque([(root,<span class="number">0</span>)])</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> Q:</span><br><span class="line">            node,level = Q.popleft()</span><br><span class="line">            <span class="keyword">if</span> level == K:</span><br><span class="line">                res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                Q.append((node.left,level+<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                Q.append((node.right,level+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 找到目标节点并设为根节点，然后转换树结构</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self,root,target,K)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        l = self.search(root.left,target,K)</span><br><span class="line">        r = self.search(root.right, target,K)</span><br><span class="line">        <span class="comment"># 找到目标节点，先进行一次计算，然后转换树结构</span></span><br><span class="line">        <span class="comment"># 将其父节点放入visited，表明这是待转换路径中的节点</span></span><br><span class="line">        <span class="keyword">if</span> l <span class="keyword">is</span> target:</span><br><span class="line">            self.root = l</span><br><span class="line">            self.res = self.getAns(l,K)</span><br><span class="line">            l.left = <span class="keyword">None</span></span><br><span class="line">            l.right = root</span><br><span class="line">            root.left = <span class="keyword">None</span></span><br><span class="line">            self.visited.add(root)</span><br><span class="line">        <span class="keyword">if</span> r <span class="keyword">is</span> target:</span><br><span class="line">            self.root = r</span><br><span class="line">            self.res = self.getAns(r,K)</span><br><span class="line">            r.right = <span class="keyword">None</span></span><br><span class="line">            r.left = root</span><br><span class="line">            root.right = <span class="keyword">None</span></span><br><span class="line">            self.visited.add(root)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 找到待转换路径中的节点，转换树结构，再将父节点加入visited，依次类推</span></span><br><span class="line">        <span class="comment"># 如思路中第2点所说，尽量不改变父节点本身结构，所有需判断一下</span></span><br><span class="line">        <span class="keyword">if</span> l <span class="keyword">in</span> self.visited:</span><br><span class="line">            <span class="keyword">if</span> l.left == <span class="keyword">None</span>:</span><br><span class="line">                l.left = root</span><br><span class="line">            <span class="keyword">elif</span> l.right == <span class="keyword">None</span>:</span><br><span class="line">                l.right = root</span><br><span class="line">            root.left = <span class="keyword">None</span></span><br><span class="line">            self.visited.add(root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> r <span class="keyword">in</span> self.visited:</span><br><span class="line">            <span class="keyword">if</span> r.left == <span class="keyword">None</span>:</span><br><span class="line">                r.left = root</span><br><span class="line">            <span class="keyword">elif</span> r.right == <span class="keyword">None</span>:</span><br><span class="line">                r.right = root</span><br><span class="line">            root.right = <span class="keyword">None</span></span><br><span class="line">            self.visited.add(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">57</span> / <span class="number">57</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">50</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> bfs </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 861 Score After Flipping Matrix</title>
      <link href="/2018/07/02/Leetcode-861-Score-After-Flipping-Matrix/"/>
      <url>/2018/07/02/Leetcode-861-Score-After-Flipping-Matrix/</url>
      <content type="html"><![CDATA[<p>We have a two dimensional matrix A where each value is 0 or 1.<br>A move consists of choosing any row or column, and toggling each value in that row or column: changing all 0s to 1s, and all 1s to 0s.<br>After making any number of moves, every row of this matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers.<br>Return the highest possible score.</p><blockquote><p>Example 1:<br>Input: [[0,0,1,1],[1,0,1,0],[1,1,0,0]]<br>Output: 39<br>Explanation:<br>Toggled to [[1,1,1,1],[1,0,0,1],[1,1,1,1]].<br>0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39</p></blockquote><a id="more"></a><p>Note:</p><ol><li>1 &lt;= A.length &lt;= 20</li><li>1 &lt;= A[0].length &lt;= 20</li><li>A[i][j] is 0 or 1.</li></ol><p><b>分析：</b></p><ol><li>一个二维矩阵A，我们对其进行两种操作，一种是将某一列中的0，1全部反转，一种是将某一行的0，1全部反转</li><li>进行若干次操作后按照每一行的数将其变为二进制数，使得所有行求和最大</li><li>如果我们单分析一行，如例子中第一行，0011，我们知道在四位二进制数中后三位的和为7，第一位就有8，所以可以断定在最优情况下，首位数字必要变成1，所有行同理（贪心）。</li><li>当第一位全为1后，根据贪心我们想使第二位尽量多1，此时只能改列（改行可能使首位数字变动），也就是对于第二列，如果1的数量比0少，那么我们就进行一次列反转，反之就不进行操作，之后每一列以此类推！</li></ol><p>按照上述操作后我们观察示例中矩阵A中元素变换过程，首先先将首位全部变为1，然后：<br>1 1 0 0    — — — — — — — — &gt;    1 1 0 0    — — — — — — — — &gt;    1 1 1 0 — — — — — — — — &gt;    1 1 1 1<br>1 0 1 0 — —第二列1多— — —&gt;    1 0 1 0 — —第三列0多— — —&gt;    1 0 0 0 — —第四列0多— — —&gt;    1 0 0 1<br>1 1 0 0    — — — — — — — — &gt;    1 1 0 0    — — — — — — — — &gt;    1 1 1 0    — — — — — — — — &gt;    1 1 1 1</p><p><b>思路：</b></p><ol><li>先判断每行第一个元素是否为0，若为0则进行一次行变换</li><li>然后对每一列进行0，1数量的判断，若0多，则进行一次列变换，也就是将1，0的个数对调</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">matrixScore</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m,n = len(A),len(A[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 行变换</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> A[i][<span class="number">0</span>] == <span class="number">1</span>: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                A[i][j] = <span class="number">1</span> - A[i][j]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 列变换</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> rows <span class="keyword">in</span> zip(*A):</span><br><span class="line">        <span class="comment"># 始终使1的个数是更大的</span></span><br><span class="line">            cnt1 = max(rows.count(<span class="number">1</span>), rows.count(<span class="number">0</span>))</span><br><span class="line">            res += cnt1 * <span class="number">2</span>**(n<span class="number">-1</span>)</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">O(m*n) time, O(m*n) space (because of zip(*A))</span><br><span class="line"><span class="number">80</span> / <span class="number">80</span> test cases passed.</span><br><span class="line">diffculty: medium</span><br><span class="line">Runtime: <span class="number">37</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
            <tag> greedy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 860 Lemonade Change</title>
      <link href="/2018/07/01/Leetcode-860-Lemonade-Change/"/>
      <url>/2018/07/01/Leetcode-860-Lemonade-Change/</url>
      <content type="html"><![CDATA[<p>At a lemonade stand, each lemonade costs $5.<br>Customers are standing in a queue to buy from you, and order one at a time (in the order specified by bills).<br>Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill.  You must provide the correct change to each customer, so that the net transaction is that the customer pays $5.<br>Note that you don’t have any change in hand at first.<br>Return true if and only if you can provide every customer with correct change.</p><blockquote><p>Example 1:<br>Input: [5,5,5,10,20]<br>Output: true<br>Explanation:<br>From the first 3 customers, we collect three $5 bills in order.<br>From the fourth customer, we collect a $10 bill and give back a $5.<br>From the fifth customer, we give a $10 bill and a $5 bill.<br>Since all customers got correct change, we output true.</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: [5,5,10]<br>Output: true</p></blockquote><blockquote><p>Example 3:<br>Input: [10,10]<br>Output: false</p></blockquote><blockquote><p>Example 4:<br>Input: [5,5,10,10,20]<br>Output: false<br>Explanation:<br>From the first two customers in order, we collect two $5 bills.<br>For the next two customers in order, we collect a $10 bill and give back a $5 bill.<br>For the last customer, we can’t give change of $15 back because we only have two $10 bills.<br>Since not every customer received correct change, the answer is false.</p></blockquote><p><strong>Note:</strong></p><ol><li>0 &lt;= bills.length &lt;= 10000</li><li>bills[i] will be either 5, 10, or 20.</li></ol><p><b>分析：</b></p><ol><li>一个物品5美元，每个人依次来买，且只买一个</li><li>你初始没钱，要保证每个顾客你都能立即完成找钱操作</li><li>顾客给的钱只会是5,10,20，数据长度达到10000，说明O(n^2)复杂度不可行</li></ol><p><b>思路：</b></p><ol><li>如果顾客给的是5元，那么不用做任何操作，直接收下即可</li><li>如果顾客给的是10元，那么需要找一个5元</li><li>如果顾客给的是20元，那么我们有两种选择，一种是找一个5元和一个10元，一种是找三个5元，那么显然因为5元更加灵活（可以用来应对10元情况），所以我们应当优先用第一种找钱方法。</li><li>用一个字典记录5元，10元的个数，当剩余钱数不够找即return False!</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lemonadeChange</span><span class="params">(self, bills)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type bills: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        d = &#123;<span class="number">5</span>:<span class="number">0</span>,<span class="number">10</span>:<span class="number">0</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> bills:</span><br><span class="line">            <span class="comment"># 5元情况</span></span><br><span class="line">            <span class="keyword">if</span> val == <span class="number">5</span>:</span><br><span class="line">                d[<span class="number">5</span>] += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 10元情况，找一个5元</span></span><br><span class="line">            <span class="keyword">elif</span> val == <span class="number">10</span>:</span><br><span class="line">                <span class="keyword">if</span> d[<span class="number">5</span>]:</span><br><span class="line">                    d[<span class="number">5</span>] -= <span class="number">1</span></span><br><span class="line">                    d[<span class="number">10</span>] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="comment"># 20元情况，优先用一个10元和一个5元找钱</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> d[<span class="number">10</span>] <span class="keyword">and</span> d[<span class="number">5</span>]:</span><br><span class="line">                    d[<span class="number">10</span>] -= <span class="number">1</span></span><br><span class="line">                    d[<span class="number">5</span>] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> d[<span class="number">5</span>] &gt;= <span class="number">3</span>:</span><br><span class="line">                    d[<span class="number">5</span>] -= <span class="number">3</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="number">45</span> / <span class="number">45</span> test cases passed.</span><br><span class="line">difficulty: easy</span><br><span class="line">Runtime: <span class="number">99</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 526 Beautiful Arrangement</title>
      <link href="/2018/06/29/Leetcode-526-Beautiful-Arrangement/"/>
      <url>/2018/06/29/Leetcode-526-Beautiful-Arrangement/</url>
      <content type="html"><![CDATA[<p>假设有从 1 到 N 的 N 个整数，如果从这 N 个数字中成功构造出一个数组，使得数组的第 i 位 (1 &lt;= i &lt;= N) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列。条件：<br>第 i 位的数字能被 i 整除<br>i 能被第 i 位上的数字整除<br>现在给定一个整数 N，请问可以构造多少个优美的排列？</p><blockquote><p>示例1:<br>输入: 2<br>输出: 2<br>解释:<br>第 1 个优美的排列是 [1, 2]:<br> 第 1 个位置（i=1）上的数字是1，1能被 i（i=1）整除<br> 第 2 个位置（i=2）上的数字是2，2能被 i（i=2）整除<br>第 2 个优美的排列是 [2, 1]:<br> 第 1 个位置（i=1）上的数字是2，2能被 i（i=1）整除<br> 第 2 个位置（i=2）上的数字是1，i（i=2）能被 1 整除</p></blockquote><a id="more"></a><blockquote><p>说明:<br>N 是一个正整数，并且不会超过15。</p></blockquote><p><b>分析：</b></p><ol><li>当你看到N不超过15的时候，你可以在leetcode上把这个15个数的答案都测出来然后返回就完事了，当然这是开玩笑的！</li><li>这道题是标准的回溯，相当于有N个位置，我们依次往每个位置上放置数字，要满足 nums[i] % i == 0 or i % nums[i] == 0.（和N皇后问题一样，只是限制条件不同）</li><li>不妨假设N=15，那么对于第一个位置我们有15种可能，取其中一种记录（之后放置时不能使用重复数字），第二个位置我们有14种可能，第三个位置13种，依次类推。我们发现如果这样重复迭代的话计算量非常之大，因为相当于我们要遍历15!种情况，虽然因为有限制条件剪枝，但仍然太多了（N=15时会超时）</li><li>那么我们需要想到，其实对于第i个位置我们并不用遍历所有的15个数，而只要事先记录15个数中能放在i位置上的数有哪些，只遍历这一部分数（一般只有4个左右）即可，大大减少了运行时间（可以通过）</li></ol><p><b>思路：</b></p><ol><li>字典d[i]记录能放在i位置上的所有数</li><li>从第1个位置开始，依次分析，如若能到第N+1个位置（说明N个位置全部放置完毕），res += 1</li></ol><p>这里给出我写的两种方法，一种是没优化，直接回溯，一种是优化解法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 暴力方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self,N,index,visited=set<span class="params">()</span>)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> index == N+<span class="number">1</span>:</span><br><span class="line">            self.res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> visited <span class="keyword">and</span> (i%index==<span class="number">0</span> <span class="keyword">or</span> index % i == <span class="number">0</span>):</span><br><span class="line">                self.helper(N,index+<span class="number">1</span>,visited | set([i]))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countArrangement</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 这里我耍赖了，在自己程序中跑出15的结果，花了2s，确实会超时</span></span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">15</span>: <span class="keyword">return</span> <span class="number">24679</span></span><br><span class="line">        self.helper(N,<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line"><span class="number">15</span> / <span class="number">15</span> test cases passed.</span><br><span class="line">Difficulty:Medium</span><br><span class="line">Runtime: <span class="number">414</span> ms</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 优化解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self,N,index,d,visited=set<span class="params">()</span>)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> index == N+<span class="number">1</span>:</span><br><span class="line">            self.res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> d[index]:</span><br><span class="line">            <span class="keyword">if</span> val <span class="keyword">in</span> visited: <span class="keyword">continue</span></span><br><span class="line">            self.helper(N,index+<span class="number">1</span>,d,visited|set([val]))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countArrangement</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        d = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,N+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i%j == <span class="number">0</span> <span class="keyword">or</span> j%i == <span class="number">0</span>:</span><br><span class="line">                    d[i].append(j)</span><br><span class="line">        self.helper(N,<span class="number">1</span>,d)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">15</span> / <span class="number">15</span> test cases passed.</span><br><span class="line">Difficulty:Medium</span><br><span class="line">Runtime: <span class="number">1394</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> Backtracking </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 131 Palindrome Partitioning</title>
      <link href="/2018/06/29/Leetcode-131-Palindrome-Partitioning/"/>
      <url>/2018/06/29/Leetcode-131-Palindrome-Partitioning/</url>
      <content type="html"><![CDATA[<p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。<br>返回 s 所有可能的分割方案。</p><blockquote><p>示例:<br>输入: “aab”<br>输出:<br>[<br> [“aa”,”b”],<br> [“a”,”a”,”b”]<br>]</p></blockquote><a id="more"></a><p><b>分析：</b></p><ol><li>这种题其实都是有固定解法的，显然partition(s)定义为s所能组成的回文字符串列表</li><li>那么我们依次截取s的前i个字符，判断其是否为回文字符串。若是，则显然 s[:i] + l for l in partition(s[i:])，就为最后的答案</li><li>例如aab,先判断第一个’a’为回文,则剩余的partition(‘ab’)会返回[[‘a’,’b’]]，然后用第一个’a’分别加上返回的值变为[[‘a’,’a’,’b’]]</li><li>然后判断前两个’aa’为回文，剩余的partition(‘b’)会返回[[‘b’]],加上变为[[‘aa’,’b’]]</li></ol><p><b>思路：</b></p><ol><li>定义函数isPalin(s)判断s是否为回文字符串</li><li>设定递归终止条件</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isPalin</span><span class="params">(s)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> s == s[::<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># 只要终止条件设定好，递推式一写答案自然就出来，还是有点神奇的</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">1</span>: <span class="keyword">return</span> [[s]]</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(s)):</span><br><span class="line">            <span class="keyword">if</span> isPalin(s[:i]):</span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> self.partition(s[i:]):</span><br><span class="line">                    res.append([s[:i]] + l)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 上面的递归过程没有将s本身考虑进去，因为i遍历到最后时s[i:]已经没有东西了，不存在l的话，res也就没有append操作了</span></span><br><span class="line">        <span class="keyword">if</span> isPalin(s): res.append([s])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">22</span> / <span class="number">22</span> test cases passed.</span><br><span class="line">Difficulty: Medium</span><br><span class="line">Runtime: <span class="number">196</span> ms,beats <span class="number">34.78</span>%</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> Backtracking </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 140 Word Break II</title>
      <link href="/2018/06/29/Leetcode-140-Word-Break-II/"/>
      <url>/2018/06/29/Leetcode-140-Word-Break-II/</url>
      <content type="html"><![CDATA[<p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。<br>说明：<br>分隔时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。</p><blockquote><p>示例 1：<br>输入:<br>s = “catsanddog”<br>wordDict = [“cat”, “cats”, “and”, “sand”, “dog”]<br>输出:<br>[<br> “cats and dog”,<br> “cat sand dog”<br>]</p></blockquote><a id="more"></a><blockquote><p>示例 2：<br>输入:<br>s = “pineapplepenapple”<br>wordDict = [“apple”, “pen”, “applepen”, “pine”, “pineapple”]<br>输出:<br>[<br> “pine apple pen apple”,<br> “pineapple pen apple”,<br> “pine applepen apple”<br>]<br>解释: 注意你可以重复使用字典中的单词。</p></blockquote><blockquote><p>示例 3：<br>输入:<br>s = “catsandog”<br>wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br>输出:<br>[]</p></blockquote><p><b>分析：</b></p><ol><li>标准的回溯思想，我们先从暴力法开始分析，直接遍历wordDict中的每个字符串word，看是否满足s.startwith(word)，若满足再重新开始遍历，这样的话时间复杂度应该是O(kn^2)，其中n为wordDict长度，k为word平均长度。这样显然复杂度太高。</li><li>那么我们容易想到，使用一个字典根据每个单词的首字母来存储，这样我们可以只遍历以s[0]开头的word，这样平均复杂度能够到O(kn)，但若wordDict中大量单词是以同一字母开头，复杂度在最坏情况下仍会是O(kn^2)。但单就这道题来说，这样优化之后是可以通过的。</li><li>在这道题中还有一点无法处理，那就是在上述最坏情况下，s实际上并不能用wordDict构建，这种情况也会导致TLE，故在开始时先判断s是否能有wordDict表示(借鉴于discuss)</li></ol><p><b>思路：</b></p><ol><li>定义breakable函数判断s是否可分</li><li>建立字典根据首字母存储wordDict中单词及长度(用来分片)</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s, wordDict)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type wordDict: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 回溯很简单，关键在于判断这个字符串本身是否可分，如若不能，会有大量重复计算，避免这一点就不会TLE</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">breakable</span><span class="params">()</span>:</span></span><br><span class="line">            rightmosts = [<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s) + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> last_index <span class="keyword">in</span> rightmosts:</span><br><span class="line">                    <span class="keyword">if</span> s[last_index:i] <span class="keyword">in</span> words:</span><br><span class="line">                        rightmosts.append(i)</span><br><span class="line">                        <span class="keyword">if</span> i == len(s): </span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        words = set(wordDict)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> breakable(): <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        d = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> wordDict:</span><br><span class="line">            d[word[<span class="number">0</span>]].append((word,len(word)))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 标准回溯代码写法</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(s,rec=<span class="string">''</span>,res=[])</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="comment"># rec右边多一个空格</span></span><br><span class="line">                res.append(rec.rstrip())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> word,c <span class="keyword">in</span> d[s[<span class="number">0</span>]]:</span><br><span class="line">                <span class="keyword">if</span> s.startswith(word):</span><br><span class="line">                    helper(s[c:],rec+word+<span class="string">' '</span>,res)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        helper(s,<span class="string">''</span>,res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="number">39</span> / <span class="number">39</span> test cases passed.</span><br><span class="line">difficulty: hard</span><br><span class="line">Runtime: <span class="number">52</span> ms,beats <span class="number">94.64</span>%</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> Backtracking </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python 运算符优先级顺序</title>
      <link href="/2018/06/29/python-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E9%A1%BA%E5%BA%8F/"/>
      <url>/2018/06/29/python-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E9%A1%BA%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p>最近看到几个小例子，发现自己对这块有点不是很清楚，遂记录一下。<br>以下运算符，从下至上，优先级顺序依次递增。<br><a id="more"></a></p><blockquote><p>Lambda<br>逻辑运算符: or<br>逻辑运算符: and<br>逻辑运算符:not<br>成员测试: in, not in<br>同一性测试: is, is not<br>比较: &lt;,&lt;=,&gt;,&gt;=,!=,==<br>按位或: |<br>按位异或: ^<br>按位与: &amp;<br>移位: &lt;&lt; ,&gt;&gt;<br>加法与减法: + ,-<br>乘法、除法与取余: *, / ,%<br>正负号: +x,-x</p></blockquote><p>举个例子：</p><ol><li><p><strong>+- 加减法优先级大于逻辑运算符</strong><br>>>> 2 - 2 and 1<br>0<br>>>> 2 and 1<br>1<br>>>> 0 and 1<br>0</p></li><li><p><strong>说起逻辑运算符这里就顺便提下里面的一些小细节，假若给定a,b； a&gt;0 and b&gt;0，则有：</strong><br>a and b = b<br>a or b = a<br>>>> 3 or 4<br>3<br>>>> 4 or 3<br>4<br>>>> 3 and 4<br>4<br>>>> 4 and 3<br>3</p></li></ol>]]></content>
      
      
        <tags>
            
            <tag> 知识积累 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 486 Predict the Winner</title>
      <link href="/2018/06/27/Leetcode-486-Predict-the-Winner/"/>
      <url>/2018/06/27/Leetcode-486-Predict-the-Winner/</url>
      <content type="html"><![CDATA[<p>给定一个表示分数的非负整数数组。 玩家1从数组任意一端拿取一个分数，随后玩家2继续从剩余数组任意一端拿取分数，然后玩家1拿，……。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。<br>给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。</p><blockquote><p>示例 1:<br>输入: [1, 5, 2]<br>输出: False<br>解释: 一开始，玩家1可以从1和2中进行选择。<br>如果他选择2（或者1），那么玩家2可以从1（或者2）和5中进行选择。如果玩家2选择了5，那么玩家1则只剩下1（或者2）可选。<br>所以，玩家1的最终分数为 1 + 2 = 3，而玩家2为 5。<br>因此，玩家1永远不会成为赢家，返回 False。</p></blockquote><blockquote><p>示例 2:<br>输入: [1, 5, 233, 7]<br>输出: True<br>解释: 玩家1一开始选择1。然后玩家2必须从5和7中进行选择。无论玩家2选择了哪个，玩家1都可以选择233。<br>最终，玩家1（234分）比玩家2（12分）获得更多的分数，所以返回 True，表示玩家1可以成为赢家。</p></blockquote><a id="more"></a><p>注意:</p><ol><li>1 &lt;= 给定的数组长度 &lt;= 20.</li><li>数组里所有分数都为非负数且不会大于10000000。</li><li>如果最终两个玩家的分数相等，那么玩家1仍为赢家。</li></ol><p><b>分析：</b></p><ol><li>显然，第一个人要么拿第1个要么拿最后1个，具体拿哪个取决于哪种拿法能拿的分数更大。</li><li>此时，我们不妨定义score(nums)代表在剩余数组为nums时，先拿的人能获得的最大分数。</li><li>故第一个人能拿到的最大分数就为score(nums)，第二个人能拿到的分数自然是sum(nums)-score(nums)。因总和不变，所以第二个人的策略是使第一个人能得到的分数尽量小！</li></ol><p><b>思路：</b></p><ol><li>对于score(nums)，如果len(nums) &lt;= 2，则score(nums) = max(nums)</li><li>如果len(nums)&gt;3，先拿的人可以拿nums[0]，也可以拿nums[-1]，不妨设拿的nums[0]，则此时该第二个人在nums[1:]数组先拿</li><li>第二个人可能拿nums[1]或者nums[-1]，拿哪个取决于让第一个人在剩余数组能获得的最大分数最小，即min(score(nums[2:]),score(nums[1:-1]))</li><li>依次类推，注意中间有大量重复计算，即使nums.len &lt;= 20，我们最好还是用记忆化的形式来计算，又因为list是不可哈希对象，所以先转换成tuple记录</li></ol><p><b>补充：</b><br>这种记忆化的递归就是dp，转换成dp更容易想清楚，这里我就不写dp方法了。<br>时间复杂度的分析很简单，观察字典d即可，我们是每递归一次就有一个新的d[nums[i:j]]，i处于(0,n-1),j处于(i+1,n-1)，故为n^2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PredictTheWinner</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(nums)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> tuple(nums) <span class="keyword">in</span> d: <span class="keyword">return</span> d[tuple(nums)]</span><br><span class="line">            <span class="keyword">if</span> len(nums) == <span class="number">1</span>: <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> len(nums) == <span class="number">2</span>: <span class="keyword">return</span> max(nums)</span><br><span class="line">            res = max(nums[<span class="number">0</span>] + min(score(nums[<span class="number">2</span>:]),score(nums[<span class="number">1</span>:<span class="number">-1</span>])), nums[<span class="number">-1</span>] + min(score(nums[<span class="number">1</span>:<span class="number">-1</span>]), score(nums[:<span class="number">-2</span>])))</span><br><span class="line">            d[tuple(nums)] = res</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        s1 = score(nums)</span><br><span class="line">        s2 = sum(nums) - s1</span><br><span class="line">        <span class="keyword">return</span> s1 &gt;= s2</span><br><span class="line"></span><br><span class="line">O(n^<span class="number">2</span>) time, O(n^<span class="number">2</span>) space</span><br><span class="line"><span class="number">61</span> / <span class="number">61</span> test cases passed.</span><br><span class="line">Difficulty: medium</span><br><span class="line">Runtime: <span class="number">40</span> ms, beats <span class="number">73.5</span>%</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 859 Buddy Strings</title>
      <link href="/2018/06/26/Leetcode-859-Buddy-Strings/"/>
      <url>/2018/06/26/Leetcode-859-Buddy-Strings/</url>
      <content type="html"><![CDATA[<p>Given two strings A and B of lowercase letters, return true if and only if we can swap two letters in A so that the result equals B.</p><blockquote><p>Example 1:<br>Input: A = “ab”, B = “ba”<br>Output: true</p></blockquote><blockquote><p>Example 2:<br>Input: A = “ab”, B = “ab”<br>Output: false</p></blockquote><blockquote><p>Example 3:<br>Input: A = “aa”, B = “aa”<br>Output: true</p></blockquote><a id="more"></a><blockquote><p>Example 4:<br>Input: A = “aaaaaaabc”, B = “aaaaaaacb”<br>Output: true</p></blockquote><blockquote><p>Example 5:<br>Input: A = “”, B = “aa”<br>Output: false</p></blockquote><p>Note:</p><ol><li>0 &lt;= A.length &lt;= 20000</li><li>0 &lt;= B.length &lt;= 20000</li><li>A and B consist only of lowercase letters.</li></ol><p><b>分析：</b></p><ol><li>先判断是不是组成相同</li><li>在判断不同的个数是2还是0</li><li>如果是0，判断A中有没有相同字符</li></ol><p><b>思路：</b><br>如果仔细写应该能写优美一点把，但是瑞了，不想写了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buddyStrings</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: str</span></span><br><span class="line"><span class="string">        :type B: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> collections.Counter(A) != collections.Counter(B):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            <span class="keyword">if</span> A[i] != B[i]:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> cnt &gt; <span class="number">2</span>: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> cnt == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> len(set(A)) != len(A)</span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">O(n) time, O(n) space</span><br><span class="line"><span class="number">20</span> / <span class="number">20</span> test cases passed.</span><br><span class="line">difficulty: easy</span><br><span class="line">Runtime: <span class="number">78</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 858 Mirror Reflection</title>
      <link href="/2018/06/26/Leetcode-858-Mirror-Reflection/"/>
      <url>/2018/06/26/Leetcode-858-Mirror-Reflection/</url>
      <content type="html"><![CDATA[<p><img src="/images/leetcode_858_1.png" alt="题目描述"></p><p><font color="#660000">这道题超有意思！</font><br><br><a id="more"></a></p><p><b>分析：</b></p><ol><li>我们首先需要知道镜面反射的一些小技巧，如下图，也就是我们可以作延长线来判断反射之后的线将会落于何处。<br><img src="/images/leetcode_858_2.jpg" alt="示例图1"></li><li>题目既然保证一定会碰到012中的某一个点，那么我只要疯狂做延长线，总会交于某个角</li><li>再来举个例子，如下图，p = 4,q = 3，最后落于点2处,<strong>图中虚线和实线根据标号一一对应，且保证了两线方向一致</strong><br><img src="/images/leetcode_858_3.jpg" alt="示例图2"></li><li>延长线每次交于边界点记作A,B,C,…,显然若A的横坐标为x，则B的横坐标为2x，C的横坐标为3x，依次类推，我们只需要找到某个点其横坐标恰好是p的倍数即可</li></ol><p><b>思路：</b></p><ol><li>显然若横坐标是x的偶数倍，说明相交点在下边界线，也就是0处！返回0即可</li><li>若横坐标是x的奇数倍，说明相交点在上边界线，或许是2，或许是1</li><li>那么显然，此时若横坐标是p的偶数倍，如示例1和示例2，最后会落于2处！</li><li>else: 落于1处！</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorReflection</span><span class="params">(self, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type p: int</span></span><br><span class="line"><span class="string">        :type q: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 先找到第一个横坐标为p的倍数的点</span></span><br><span class="line">        k = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p*k % q != <span class="number">0</span>: k += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 若为x的偶数倍</span></span><br><span class="line">        <span class="keyword">if</span> k  % <span class="number">2</span> == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 分别判断p的奇数倍和偶数倍</span></span><br><span class="line">            r = p*k / q</span><br><span class="line">            <span class="keyword">if</span> r % <span class="number">2</span> == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> r % <span class="number">2</span> == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">69</span> / <span class="number">69</span> test cases passed.</span><br><span class="line">diffculty: medium</span><br><span class="line">Runtime: <span class="number">30</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 857 Minimum Cost to Hire K Workers</title>
      <link href="/2018/06/26/Leetcode-857-Minimum-Cost-to-Hire-K-Workers/"/>
      <url>/2018/06/26/Leetcode-857-Minimum-Cost-to-Hire-K-Workers/</url>
      <content type="html"><![CDATA[<p>There are N workers.  The i-th worker has a quality[i] and a minimum wage expectation wage[i].<br>Now we want to hire exactly K workers to form a paid group.  When hiring a group of K workers, we must pay them according to the following rules:<br>Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group.<br>Every worker in the paid group must be paid at least their minimum wage expectation.<br>Return the least amount of money needed to form a paid group satisfying the above conditions.</p><blockquote><p>Example 1:<br>Input: quality = [10,20,5], wage = [70,50,30], K = 2<br>Output: 105.00000<br>Explanation: We pay 70 to 0-th worker and 35 to 2-th worker.</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: quality = [3,1,10,10,1], wage = [4,8,2,2,7], K = 3<br>Output: 30.66667<br>Explanation: We pay 4 to 0-th worker, 13.33333 to 2-th and 3-th workers seperately. </p></blockquote><p>Note:</p><ol><li>1 &lt;= K &lt;= N &lt;= 10000, where N = quality.length = wage.length</li><li>1 &lt;= quality[i] &lt;= 10000</li><li>1 &lt;= wage[i] &lt;= 10000</li><li>Answers within 10^-5 of the correct answer will be considered correct.</li></ol><p><b>分析：</b></p><ol><li>这道题有点意思，要雇佣K个人，使得所花钱最少，雇佣需满足两个条件，一是最后给的钱必须成比例，二是不能低于最小值</li><li>我们不妨设最后雇佣时给第i个人的钱为p[i]，则对于被选上的K个人来说，都有相同的比例 p[i] / quality[i]（根据条件1）</li><li>也就是说一旦我们选定了比例 r，那么最后选的K个人一定都满足 r * quality[i] &gt; wage[i]（因为已经被选上了自然满足条件2）</li><li>上式逆推为 r &gt; (wage/quality),故我们将所有人按照 wage/quality 的大小排序，依次作为r 来判断最后的总价格。</li><li>注意N,K都达到了10000，O(n^2)的方法显然不行（绝大部分情况下）</li></ol><p><b>思路：</b></p><ol><li>按照wage/quality排序，若选定第i个人的比例r作为标准，那么还需从0到i-1中的人选k-1个人</li><li>对于0到i-1个人，他们每个人的价格就是quality*r，r是固定的，所以quality越小越好，所以我们用最大堆将quality大的丢弃</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mincostToHireWorkers</span><span class="params">(self, quality, wage, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type quality: List[int]</span></span><br><span class="line"><span class="string">        :type wage: List[int]</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 按比例排序,nlogn</span></span><br><span class="line">        workers = sorted([float(wage[i])/quality[i], quality[i]] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(quality)))</span><br><span class="line">        res,qsum = float(<span class="string">'inf'</span>),<span class="number">0</span></span><br><span class="line">        heap = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(workers)):</span><br><span class="line">        <span class="comment"># 选定比例 r</span></span><br><span class="line">            r,q = workers[i]</span><br><span class="line">            heapq.heappush(heap,-q)</span><br><span class="line">            <span class="comment"># qsum始终记录k个人的quality之和，乘以r即为最后结果</span></span><br><span class="line">            qsum += q</span><br><span class="line">            <span class="keyword">if</span> len(heap) &gt; K:</span><br><span class="line">            <span class="comment"># 始终丢弃quality最大的人</span></span><br><span class="line">                qsum += heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">if</span> len(heap) == K:</span><br><span class="line">                res = min(res, qsum * r)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">O(nlogn) time,O(n) space</span><br><span class="line"><span class="number">46</span> / <span class="number">46</span> test cases passed.</span><br><span class="line">difficulty: hard</span><br><span class="line">Runtime: <span class="number">320</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 856 Score of Parentheses</title>
      <link href="/2018/06/26/Leetcode-856-Score-of-Parentheses/"/>
      <url>/2018/06/26/Leetcode-856-Score-of-Parentheses/</url>
      <content type="html"><![CDATA[<p>Given a balanced parentheses string S, compute the score of the string based on the following rule:<br>() has score 1<br>AB has score A + B, where A and B are balanced parentheses strings.<br>(A) has score 2 * A, where A is a balanced parentheses string.</p><blockquote><p>Example 1:<br>Input: “()”<br>Output: 1</p></blockquote><blockquote><p>Example 2:<br>Input: “(())”<br>Output: 2</p></blockquote><a id="more"></a><blockquote><p>Example 3:<br>Input: “()()”<br>Output: 2</p></blockquote><blockquote><p>Example 4:<br>Input: “(()(()))”<br>Output: 6</p></blockquote><p>Note:</p><ol><li>S is a balanced parentheses string, containing only ( and ).</li><li>2 &lt;= S.length &lt;= 50</li></ol><p><b>分析：</b><br>1.一个基础()得1分，被括起来是两倍，保证了S一定合法，且S的长度小于50，那么显然随意递归都OK</p><p><b>思路：</b><br>S的第一位一定是左括号，找到与之对应的右括号，然后递归即可<br>即形如 (s1)s2，可写成 func(s1)*2 + func(s2)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scoreOfParentheses</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 设置终止条件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> S: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(S)):</span><br><span class="line">            <span class="keyword">if</span> S[i] == <span class="string">'('</span>:</span><br><span class="line">                stack.append(S[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.pop()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                    index = i</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 当已经是最基本的()时，直接返回1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> S[<span class="number">1</span>:index]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + self.scoreOfParentheses(S[index+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> self.scoreOfParentheses(S[<span class="number">1</span>:index]) * <span class="number">2</span> + self.scoreOfParentheses(S[index+<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">85</span> / <span class="number">85</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">34</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 853 Car Fleet</title>
      <link href="/2018/06/20/Leetcode-853-Car-Fleet/"/>
      <url>/2018/06/20/Leetcode-853-Car-Fleet/</url>
      <content type="html"><![CDATA[<p>N cars are going to the same destination along a one lane road.  The destination is target miles away.<br>Each car i has a constant speed speed[i]  (in miles per hour), and initial position position[i] miles towards the target along the road.</p><p>A car can never pass another car ahead of it, but it can catch up to it, and drive bumper to bumper at the same speed.</p><p>The distance between these two cars is ignored - they are assumed to have the same position.</p><p>A car fleet is some non-empty set of cars driving at the same position and same speed.  Note that a single car is also a car fleet.</p><p>If a car catches up to a car fleet right at the destination point, it will still be considered as one car fleet.<br><a id="more"></a></p><blockquote><p>Example 1:<br>Input: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]<br>Output: 3<br>Explanation:<br>The cars starting at 10 and 8 become a fleet, meeting each other at 12.<br>The car starting at 0 doesn’t catch up to any other car, so it is a fleet by itself.<br>The cars starting at 5 and 3 become a fleet, meeting each other at 6.<br>Note that no other cars meet these fleets before the destination, so the answer is 3.</p></blockquote><blockquote><p>Note:<br>0 &lt;= N &lt;= 10 ^ 4<br>0 &lt; target &lt;= 10 ^ 6<br>0 &lt; speed[i] &lt;= 10 ^ 6<br>0 &lt;= position[i] &lt; target<br>All initial positions are different.</p></blockquote><p><b>分析：</b></p><ol><li>这道题还有点意思，在不同的点有一系列的车，每辆车有不同的速度，都朝同一个target前进</li><li>无法超车，也就是初始位置在前面的车永远在前面</li><li>若追赶上前面的车则认为这些车属于一个集群，问到达终点后有多少个集群</li></ol><p><b>思路：</b></p><ol><li>显然我们先根据车的位置进行排序，从前面的车开始分析，如有A,B,C,D,E 5辆车，p[a] &gt; p[b] &gt; p[c] &gt;…</li><li>我们先判断A到达终点前是否能被B追上，若追不上显然A自身是一个集群，再从B开始判断，若能追上，则判断C能不能追上，依次类推</li><li>假设B,C都能追上A，D追不上，那么显然D也不可能追上C，我们就把D当做此时最前面的车开始分析就行了，所以是O(n),one pass，不会重复计算，但是排序本身是O(nlogn)</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">carFleet</span><span class="params">(target, p, s)</span>:</span></span><br><span class="line"><span class="comment"># 做的时候还没有note的第5条，所以处理了下初始position相同的情况</span></span><br><span class="line"><span class="comment"># d = collections.defaultdict(lambda: 10**6)</span></span><br><span class="line">n = len(p)</span><br><span class="line"><span class="comment"># for i in range(n):</span></span><br><span class="line"><span class="comment"># d[p[i]] = min(d[p[i]],s[i])</span></span><br><span class="line"><span class="comment"># 有第5条之后直接这样既可</span></span><br><span class="line">d = &#123;a:b <span class="keyword">for</span> a,b <span class="keyword">in</span> zip(p,s)&#125;</span><br><span class="line">p.sort(reverse=<span class="keyword">True</span>)</span><br><span class="line">res = n</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i + <span class="number">1</span> &lt; n:</span><br><span class="line">j = i+<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> j &lt; n <span class="keyword">and</span> (target - p[i]) / float(d[p[i]]) * d[p[j]] + p[j] &gt;= target:</span><br><span class="line">j += <span class="number">1</span></span><br><span class="line">res -= <span class="number">1</span></span><br><span class="line">i = j</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">O(nlogn) time, O(n) space</span><br><span class="line"><span class="number">44</span> / <span class="number">44</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">174</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 852 Peak Index in a Mountain Array</title>
      <link href="/2018/06/20/Leetcode-852-Peak-Index-in-a-Mountain-Array/"/>
      <url>/2018/06/20/Leetcode-852-Peak-Index-in-a-Mountain-Array/</url>
      <content type="html"><![CDATA[<p>Let’s call an array A a mountain if the following properties hold:<br>A.length &gt;= 3<br>There exists some 0 &lt; i &lt; A.length - 1 such that A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1]<br>Given an array that is definitely a mountain, return any i such that A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1].</p><blockquote><p>Example 1:<br>Input: [0,1,0]<br>Output: 1</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: [0,2,1,0]<br>Output: 1</p></blockquote><blockquote><p>Note:<br>3 &lt;= A.length &lt;= 10000<br>0 &lt;= A[i] &lt;= 10^6<br>A is a mountain, as defined above.</p></blockquote><p><b>分析:</b><br>最近的easy题越来越弱智了，A是一个山，而山的定义是存在i满足 A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1]<br>所以显然A[i]就是A中最大值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peakIndexInMountainArray</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> A.index(max(A))</span><br><span class="line"></span><br><span class="line">O(n) time, O(<span class="number">1</span>) space</span><br><span class="line"><span class="number">32</span> / <span class="number">32</span> test cases passed.</span><br><span class="line">difficulty: easy</span><br><span class="line">Runtime: <span class="number">61</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 481 Magical String</title>
      <link href="/2018/06/14/Leetcode-481-Magical-String/"/>
      <url>/2018/06/14/Leetcode-481-Magical-String/</url>
      <content type="html"><![CDATA[<p>A magical string S consists of only ‘1’ and ‘2’ and obeys the following rules:</p><p>The string S is magical because concatenating the number of contiguous occurrences of characters ‘1’ and ‘2’ generates the string S itself.</p><p>The first few elements of string S is the following: S = “1221121221221121122……”</p><p>If we group the consecutive ‘1’s and ‘2’s in S, it will be:<br>1 22 11 2 1 22 1 22 11 2 11 22 ……<br>and the occurrences of ‘1’s or ‘2’s in each group are:<br>1 2    2 1 1 2 1 2 2 1 2 2 ……</p><p><strong>You can see that the occurrence sequence above is the S itself.</strong><br>Given an integer N as input, return the number of ‘1’s in the first N number in the magical string S.<br><a id="more"></a></p><blockquote><p>Note: N will not exceed 100,000.</p></blockquote><blockquote><p>Example 1:<br>Input: 6<br>Output: 3<br>Explanation: The first 6 elements of magical string S is “12211” and it contains three 1’s, so return 3.</p></blockquote><p><b>分析：</b><br>龟龟!第二次在leetcode上写题解，beats 100%太骚了，而且血虐之后的<br><a href="https://leetcode.com/problems/magical-string/discuss/139180/python-solution-78ms-beats-100" target="_blank" rel="noopener">https://leetcode.com/problems/magical-string/discuss/139180/python-solution-78ms-beats-100%</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">s = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">index = <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> len(s) &lt; <span class="number">100000</span>:</span><br><span class="line"><span class="comment"># according to the last element, we decide the value of 'val'</span></span><br><span class="line">val = <span class="number">3</span> - s[<span class="number">-1</span>]</span><br><span class="line">s.extend([val]*s[index])</span><br><span class="line">index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">magicalString</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> s[:n].count(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">O(n) time, O(n) space</span><br><span class="line"><span class="number">65</span> / <span class="number">65</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">78</span> ms, beats <span class="number">100</span>%</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 482 License Key Formatting</title>
      <link href="/2018/06/14/Leetcode-482-License-Key-Formatting/"/>
      <url>/2018/06/14/Leetcode-482-License-Key-Formatting/</url>
      <content type="html"><![CDATA[<p>You are given a license key represented as a string S which consists only alphanumeric character and dashes. The string is separated into N+1 groups by N dashes.</p><p>Given a number K, we would want to reformat the strings such that each group contains exactly K characters, except for the first group which could be shorter than K, but still must contain at least one character. Furthermore, there must be a dash inserted between two groups and all lowercase letters should be converted to uppercase.</p><p>Given a non-empty string S and a number K, format the string according to the rules described above.<br><a id="more"></a></p><blockquote><p>Example 1:<br>Input: S = “5F3Z-2e-9-w”, K = 4<br>Output: “5F3Z-2E9W”<br>Explanation: The string S has been split into two parts, each part has 4 characters.<br>Note that the two extra dashes are not needed and can be removed.</p></blockquote><blockquote><p>Example 2:<br>Input: S = “2-5g-3-J”, K = 2<br>Output: “2-5G-3J”<br>Explanation: The string S has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above.</p></blockquote><blockquote><p>Note:<br>The length of string S will not exceed 12,000, and K is a positive integer.<br>String S consists only of alphanumerical characters (a-z and/or A-Z and/or 0-9) and dashes(-).<br>String S is non-empty.</p></blockquote><p><b>分析：</b></p><ol><li>题目写得挺长，实际上是将一个字符串（由’-‘连接）重新均分成若干份，每份长度为K（第一份可不够），然后用’-‘将每份连接</li><li>注意S长度不超过12000，代表这道题可以闭着眼睛写都不会超时</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 借用到python里的upper()函数直接将字符串全部大写，说实话有点耍赖了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="comment"># 弱智方法1，倒叙遍历，每遍历K个就存一下，最后连接，在出循环的时候判断一下是不是有多余的字段没存就存一下。</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">licenseKeyFormatting1</span><span class="params">(self, S, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(S)</span><br><span class="line">        rec,res = <span class="string">''</span>,[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> S[i] != <span class="string">'-'</span>:</span><br><span class="line">                rec += S[i]</span><br><span class="line">                <span class="keyword">if</span> len(rec) == K:</span><br><span class="line">                    rec = rec.upper()</span><br><span class="line">                    res.append(rec[::<span class="number">-1</span>])</span><br><span class="line">                    rec = <span class="string">''</span></span><br><span class="line">        <span class="keyword">if</span> rec: res.append(rec.upper()[::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'-'</span>.join(res[::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 好一点的方法，我直接用replace()和upper()处理字符串，然后直接连接就完事了</span></span><br><span class="line">    <span class="comment"># 如'5F3Z-2e-9-w' 直接变成 'W92EZ3F5'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">licenseKeyFormatting2</span><span class="params">(self,S,K)</span>:</span></span><br><span class="line">    S = S.replace(<span class="string">'-'</span>,<span class="string">''</span>).upper()[::<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'-'</span>.join([S[i:i+K][::<span class="number">-1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(S))[::K]][::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">Solution <span class="number">1</span>:</span><br><span class="line">O(n) time, O(n) space</span><br><span class="line"><span class="number">38</span> / <span class="number">38</span> test cases passed.</span><br><span class="line">difficulty: easy</span><br><span class="line">Runtime: <span class="number">149</span> ms,beats <span class="number">49</span>%</span><br><span class="line"></span><br><span class="line">Solution <span class="number">2</span>:</span><br><span class="line">O(n) time, O(n) space</span><br><span class="line"><span class="number">38</span> / <span class="number">38</span> test cases passed.</span><br><span class="line">difficulty: easy</span><br><span class="line">Runtime: <span class="number">46</span> ms,beats <span class="number">90</span>%</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 477 Total Hamming Distance</title>
      <link href="/2018/06/11/Leetcode-477-Total-Hamming-Distance/"/>
      <url>/2018/06/11/Leetcode-477-Total-Hamming-Distance/</url>
      <content type="html"><![CDATA[<p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.<br>Now your job is to find the total Hamming distance between all pairs of the given numbers.</p><blockquote><p>Example:<br>Input: 4, 14, 2<br>Output: 6<br>Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just<br>showing the four bits relevant in this case). So the answer will be:<br>HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.</p></blockquote><a id="more"></a><blockquote><p>Note:</p><ol><li>Elements of the given array are in the range of 0 to 10^9</li><li>Length of the array will not exceed 10^4.</li></ol></blockquote><p><b>分析：</b><br>在leetcode 461中有如何计算海明距离的方法，这里数据长度不超过10^4，讲道理n^2可行，但是还涉及到数据本身长度（虽然长度很短，不超过32），所以还是会tle<br>所以仔细想想，发现是可以用O(n)的方法来做的</p><p><b>思路：</b><br>分别观察每一位，比如所有数的最后一位，假设有m个1，n个0， 那么这一位产生的海明距离之和应该为 m * n（易证）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">totalHammingDistance</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">        <span class="comment"># 从最后一位开始</span></span><br><span class="line">            cnt, mask = <span class="number">0</span>, <span class="number">1</span> &lt;&lt; i</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="comment"># count the number of '1'</span></span><br><span class="line">                cnt += num &amp; mask != <span class="number">0</span></span><br><span class="line">            <span class="comment"># cnt '1' and (n-cnt) '0', the distance is the product!</span></span><br><span class="line">            res += cnt * (len(nums)-cnt)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># O(n) time, O(1) space</span></span><br><span class="line"><span class="number">47</span> / <span class="number">47</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">337</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> bit </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 371 Sum of Two Integer</title>
      <link href="/2018/06/11/Leetcode-371-Sum-of-Two-Integer/"/>
      <url>/2018/06/11/Leetcode-371-Sum-of-Two-Integer/</url>
      <content type="html"><![CDATA[<p>Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.</p><p>Example:<br>Given a = 1 and b = 2, return 3.<br><a id="more"></a></p><p><b>分析：</b><br>摆明着要用位运算，那么很容易想到只有在这种情况下 101 ^ 010 = 111（即a&amp;b=0），^操作符等价于+操作符<br>那么就把a拆开，分为 和b一样的部分和 以及 和b完全不一样的部分</p><p><b>思路：</b><br>用&amp;操作符取出相同部分，而相同部分相加等价于左移操作符，用^直接把不同部分的结果加出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getSum</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type a: int</span></span><br><span class="line"><span class="string">        :type b: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> a <span class="keyword">if</span> <span class="keyword">not</span> b <span class="keyword">else</span> self.getSum(a^b,(a&amp;b)&lt;&lt;<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># O(1) time O(1) space </span></span><br><span class="line"><span class="number">13</span> / <span class="number">13</span> test cases passed.</span><br><span class="line">difficulty: easy</span><br><span class="line">Runtime: <span class="number">30</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> bit </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 318 Maximum Product of Word Lengths</title>
      <link href="/2018/06/11/Leetcode-318-Maximum-Product-of-Word-Lengths/"/>
      <url>/2018/06/11/Leetcode-318-Maximum-Product-of-Word-Lengths/</url>
      <content type="html"><![CDATA[<p>Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0.</p><blockquote><p>Example 1:<br>Input: [“abcw”,”baz”,”foo”,”bar”,”xtfn”,”abcdef”]<br>Output: 16<br>Explanation: The two words can be “abcw”, “xtfn”.</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: [“a”,”ab”,”abc”,”d”,”cd”,”bcd”,”abcd”]<br>Output: 4<br>Explanation: The two words can be “ab”, “cd”.</p></blockquote><blockquote><p>Example 3:<br>Input: [“a”,”aa”,”aaa”,”aaaa”]<br>Output: 0<br>Explanation: No such pair of words.</p></blockquote><p><b>题意分析：</b><br>在列表中找两个字符串使得这两个字符串的长度乘积最大，这两个字符串必须满足没有相同字符。<br>算乘积一个n^2即可，关键在于限制条件，我们固然可以用set来记录字符串然后用 &amp;操作符判断，但是就有点小蠢，空间也相对花费较大<br>因为只有26个英文字母，我们完全可以用26位长的数字来表示，1代表有，0代表没有，&amp;操作也方便<br>这种用数字表示字母的思想是一种很经典的思路，已经不止见到过一次了，得记住！</p><p><b>思路：</b><br>用一个数组记录长度，用一个数组记录位表示，n^2复杂度解决</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(words)</span><br><span class="line">        l = [<span class="number">0</span>] * n</span><br><span class="line">        mask = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            l[i] = len(words[i])</span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> words[i]:</span><br><span class="line">                mask[i] |= <span class="number">1</span> &lt;&lt; (ord(c)-ord(<span class="string">'a'</span>))</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> mask[i] &amp; mask[j]:</span><br><span class="line">                    res = max(res,l[i] * l[j])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># O(n^2) time, O(n) space</span></span><br><span class="line"><span class="number">174</span> / <span class="number">174</span> test cases passed.</span><br><span class="line">dfficulty: medium</span><br><span class="line">Runtime: <span class="number">409</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> bit </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 476 Number Complement</title>
      <link href="/2018/06/11/Leetcode-476-Number-Complement/"/>
      <url>/2018/06/11/Leetcode-476-Number-Complement/</url>
      <content type="html"><![CDATA[<p>Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.<br><strong>Note:</strong><br>The given integer is guaranteed to fit within the range of a 32-bit signed integer.<br>You could assume no leading zero bit in the integer’s binary representation.<br><a id="more"></a></p><blockquote><p>Example 1:<br>Input: 5<br>Output: 2<br>Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.</p></blockquote><blockquote><p>Example 2:<br>Input: 1<br>Output: 0<br>Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.</p></blockquote><p><b>分析：</b><br>就是求一个数的反码，还保证了是32bit的数</p><p><b>思路：</b><br>这里介绍两种方法：</p><ol><li>用Python内置的bin()函数获得Num的二进制表示形式，然后’0’ ‘1’互换即可</li><li>101 -&gt; 010， 我们可以发现其实就是找0的位置，想到用全1的数来进行异或操作, 即101 ^ 111 = 010</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串转换</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findComplement</span><span class="params">(num)</span>:</span></span><br><span class="line">s = bin(nums)</span><br><span class="line">res = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> s[<span class="number">2</span>:]:</span><br><span class="line">res += str(<span class="number">1</span>-int(e))</span><br><span class="line"><span class="keyword">return</span> int(res,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 异或操作</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findComplement</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> num ^ ((<span class="number">1</span>&lt;&lt;num.bit_length())<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">149</span> / <span class="number">149</span> test cases passed.</span><br><span class="line">dfficulty: easy</span><br><span class="line">Runtime: <span class="number">35</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 851 Loud and Rich</title>
      <link href="/2018/06/11/Leetcode-851-Loud-and-Rich/"/>
      <url>/2018/06/11/Leetcode-851-Loud-and-Rich/</url>
      <content type="html"><![CDATA[<p>In a group of N people (labelled 0, 1, 2, …, N-1), each person has different amounts of money, and different levels of quietness.<br>For convenience, we’ll call the person with label x, simply “person x”.<br>We’ll say that richer[i] = [x, y] if person x definitely has more money than person y.  Note that richer may only be a subset of valid observations.<br>Also, we’ll say quiet[x] = q if person x has quietness q.<br>Now, return answer, where answer[x] = y if y is the least quiet person (that is, the person y with the smallest value of quiet[y]), among all people who definitely have equal to or more money than person x.<br><a id="more"></a></p><blockquote><p>Example 1:<br>Input: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]<br>Output: [5,5,2,5,4,5,6,7]<br>Explanation:<br>answer[0] = 5.<br>Person 5 has more money than 3, which has more money than 1, which has more money than 0.<br>The only person who is quieter (has lower quiet[x]) is person 7, but<br>it isn’t clear if they have more money than person 0.<br>answer[7] = 7.<br>Among all people that definitely have equal to or more money than person 7<br>(which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet[x])<br>is person 7.<br>The other answers can be filled out with similar reasoning.</p></blockquote><blockquote><p>Note:<br>1 &lt;= quiet.length = N &lt;= 500<br>0 &lt;= quiet[i] &lt; N, all quiet[i] are different.<br>0 &lt;= richer.length &lt;= N * (N-1) / 2<br>0 &lt;= richer[i][j] &lt; N<br>richer[i][0] != richer[i][1]<br>richer[i]’s are all different.<br>The observations in richer are all logically consistent.</p></blockquote><p><b>分析：</b></p><ol><li>人的编号从0到n-1，每个人有一定的钱和度，并且都不相同</li><li>返回ans，ans[i]代表比i这个人钱多的人中，度最小的人的编号</li><li>数据（节点）长度500，边长度不超过250000，故显然对边分析时，n^2复杂度不可行</li></ol><p><b>思路：</b><br>对于每个人可以直接用dfs找，但是也得用dp存一下。topsort也是一样，都得用dp。由于我对dfs还是运用不到位，这里先写下topsort方法吧。<br>对于example中的例子，关系如图：<br><img src="/images/leetcode_851.jpg" alt=""><br>可以看到2，4，5，6入度为0，即没有比他们更多钱的人，那么对于这种节点 ,ans[i] = i<br>对于3,则要从指向他的节点（4，5，6）以及他自身中找到quiet值最小的点index,ans[3] = min(3,4,5,6,key=lambda x: quiet[ans[x]]) ,依次类推即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections,Queue</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loudAndRich</span><span class="params">(richer, quiet)</span>:</span></span><br><span class="line"><span class="comment"># 存储形式 节点： 指向该节点的节点</span></span><br><span class="line">d = collections.defaultdict(list)</span><br><span class="line"><span class="comment"># 存储形式 节点： 该节点指向的节点</span></span><br><span class="line">d1 = collections.defaultdict(list)</span><br><span class="line"><span class="comment"># 记录入度</span></span><br><span class="line">count = [<span class="number">0</span>] * len(quiet)</span><br><span class="line">ans = [float(<span class="string">'inf'</span>)] * len(quiet)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x,y <span class="keyword">in</span> richer:</span><br><span class="line">count[y] += <span class="number">1</span></span><br><span class="line">d[y].append(x)</span><br><span class="line">d1[x].append(y)</span><br><span class="line"><span class="comment"># 取入度为0的点</span></span><br><span class="line">Q = Queue.deque([i <span class="keyword">for</span> i <span class="keyword">in</span> range(len(quiet)) <span class="keyword">if</span> count[i] == <span class="number">0</span>])</span><br><span class="line"><span class="keyword">while</span> Q:</span><br><span class="line">node = Q.popleft()</span><br><span class="line"><span class="comment"># 先默认结果为自身，然后和指向自身的节点依次比较</span></span><br><span class="line">res = node</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> d[node]:</span><br><span class="line"><span class="keyword">if</span> quiet[ans[e]] &lt; quiet[res]:</span><br><span class="line">res = ans[e]</span><br><span class="line">ans[node] = res</span><br><span class="line"><span class="comment"># 修改入度，将入度变为0的节点加入队列</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> d1[node]:</span><br><span class="line">count[i] -= <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> count[i] == <span class="number">0</span>:</span><br><span class="line">Q.append(i)</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">86</span> / <span class="number">86</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">256</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dp </tag>
            
            <tag> dfs </tag>
            
            <tag> topsort </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 849 Maximize Distance to Closest Person</title>
      <link href="/2018/06/10/Leetcode-849-Maximize-Distance-to-Closest-Person/"/>
      <url>/2018/06/10/Leetcode-849-Maximize-Distance-to-Closest-Person/</url>
      <content type="html"><![CDATA[<p>In a row of seats, 1 represents a person sitting in that seat, and 0 represents that the seat is empty.<br>There is at least one empty seat, and at least one person sitting.<br>Alex wants to sit in the seat such that the distance between him and the closest person to him is maximized.<br>Return that maximum distance to closest person.</p><blockquote><p>Example 1:<br>Input: [1,0,0,0,1,0,1]<br>Output: 2<br>Explanation:<br>If Alex sits in the second open seat (seats[2]), then the closest person has distance 2.<br>If Alex sits in any other open seat, the closest person has distance 1.<br>Thus, the maximum distance to the closest person is 2.</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: [1,0,0,0]<br>Output: 3<br>Explanation:<br>If Alex sits in the last seat, the closest person is 3 seats away.<br>This is the maximum distance possible, so the answer is 3.</p></blockquote><blockquote><p>Note:<br>1 &lt;= seats.length &lt;= 20000<br>seats contains only 0s or 1s, at least one 0, and at least one 1.</p></blockquote><p><b>分析：</b></p><ol><li>题目用一个列表代表一系列座位，1代表有人，0代表没人，现在要你找一个座位使得离你最近的人尽量远。</li><li>数据长度达到20000，显然n^2方法不行，不过这道题怎么想都想不到n^2上去吧。。</li></ol><p><b>思路：</b><br>用一个列表记录下那些位置有人坐，如[1,0,0,0,1,0,1]则记录[0,4,6]，分别作差判断能得到的最远距离是多少，最后处理一下边界问题即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxDistToClosest</span><span class="params">(seats)</span>:</span></span><br><span class="line">rec = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(seats)):</span><br><span class="line"><span class="keyword">if</span> seats[i] == <span class="number">1</span>:</span><br><span class="line">rec.append(i)</span><br><span class="line"><span class="comment"># 处理边界情况</span></span><br><span class="line">left = rec[<span class="number">0</span>]</span><br><span class="line">right = len(seats)<span class="number">-1</span> - rec[<span class="number">-1</span>]</span><br><span class="line">res = max(left, right)</span><br><span class="line"><span class="comment"># 依次作差 除2得最远距离</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(rec)):</span><br><span class="line">dis = (rec[i] - rec[i<span class="number">-1</span>]) // <span class="number">2</span></span><br><span class="line">res = max(res,dis)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="number">79</span> / <span class="number">79</span> test cases passed.</span><br><span class="line">difficulty: easy</span><br><span class="line">Runtime: <span class="number">65</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 848 Shifting Letters</title>
      <link href="/2018/06/10/Leetcode-848-Shifting-Letters/"/>
      <url>/2018/06/10/Leetcode-848-Shifting-Letters/</url>
      <content type="html"><![CDATA[<p>We have a string S of lowercase letters, and an integer array shifts.<br>Call the shift of a letter, the next letter in the alphabet, (wrapping around so that ‘z’ becomes ‘a’).<br>For example, shift(‘a’) = ‘b’, shift(‘t’) = ‘u’, and shift(‘z’) = ‘a’.<br>Now for each shifts[i] = x, we want to shift the first i+1 letters of S, x times.<br>Return the final string after all such shifts to S are applied.</p><blockquote><p>Example 1:<br>Input: S = “abc”, shifts = [3,5,9]<br>Output: “rpl”<br>Explanation:<br>We start with “abc”.<br>After shifting the first 1 letters of S by 3, we have “dbc”.<br>After shifting the first 2 letters of S by 5, we have “igc”.<br>After shifting the first 3 letters of S by 9, we have “rpl”, the answer.<br>Note:<br>1 &lt;= S.length = shifts.length &lt;= 20000<br>0 &lt;= shifts[i] &lt;= 10 ^ 9</p></blockquote><a id="more"></a><p><b>分析：</b></p><ol><li>题目定义了一个shift函数，将字母按照字母表顺序转换到下一个字母，’z’后又是’a’；题目给了一个shift数组，shift[i]代表要对前i+1个字母作shift[i]次shift函数操作。</li><li>注意数据长度达到20000，显然n^2的方法不可行，数据本身大小达到10^9，说明处理必须一步到位。</li></ol><p><b>思路：</b><br>建立一个字典使0到25和zabc…xy互相对应，那么我们分析一个字符的时候便可以转换成数字来处理，处理结束后又可转换成字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">index = <span class="number">0</span></span><br><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> <span class="string">'zabcdefghijklmnopqrstuvwxy'</span>:</span><br><span class="line">d[s] = index</span><br><span class="line">d[index] = s</span><br><span class="line">index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shiftingLetters</span><span class="params">(S, shifts)</span>:</span></span><br><span class="line"><span class="comment"># 因为每次都是对前i+1个字符进行操作，所以实际第一个字符被处理了sum(shift)，依次类推</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(shifts)<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">shifts[i] += shifts[i+<span class="number">1</span>]</span><br><span class="line">res = []</span><br><span class="line"><span class="comment"># S.length = shifts.length</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(S)):</span><br><span class="line">index = (d[S[i]] + shifts[i]) % <span class="number">26</span></span><br><span class="line">res.append(d[index])</span><br><span class="line"><span class="keyword">return</span> <span class="string">''</span>.join(res)</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>美团2018CodeM初赛A轮</title>
      <link href="/2018/06/09/%E7%BE%8E%E5%9B%A22018CodeM%E5%88%9D%E8%B5%9BA%E8%BD%AE/"/>
      <url>/2018/06/09/%E7%BE%8E%E5%9B%A22018CodeM%E5%88%9D%E8%B5%9BA%E8%BD%AE/</url>
      <content type="html"><![CDATA[<p>共6道，2道AC，1道TLE，剩下放弃，呜呜呜，还差的太远了</p><a id="more"></a><h1 id="遥控按键"><a href="#遥控按键" class="headerlink" title="遥控按键"></a>遥控按键</h1><p>小美想要在电视上看电影，我们知道在电视上搜索电影可以通过搜索电影名字首字母缩写得到，通过首字母搜索电影的界面由一个九宫格组成，如下图：</p><p>@!:     ABC     DEF</p><p>GHI     JKL     MNO</p><p>PQRS    TUV     WXYZ</p><p>光标初始在这个九宫格的左上方，也就是在 “@!:”的位置，每次小美想要输入一个字母，需要通过不断地按上下左右四个方向键(并且只能按方向键），把光标从当前所在的格子移动到目标的格子(也就是待输入的字母所在的格子)，然后在目标的格子上通过其他的按键来输入字母。小美觉得频繁地按方向键是十分烦人的事情，所以她想设计一种移动光标方案使得方向键按的次数最少。问最少要几次?<br>小美想看 T 部电影，所以她会问你 T 个电影名字的缩写分别需要多少次输入。<br>注意在一个电影名字输入完以后，光标会回到左上角，期间按的方向键不会计入答案。</p><blockquote><p>输入描述:<br>第一行一个T(T ≤ 10)，表示小美想看的电影数。<br>接下来 T 行，每行一个长度不超过100,000的字符串，表示一部电影名字的缩写，保证缩写的每个字符都是大写英文字母。<br>输出描述:<br>对于每个电影名字缩写，输出输入这个名字的最小按方向键的次数。<br>示例1<br>输入<br>2<br>AA<br>AT<br>输出<br>1<br>3</p></blockquote><h1 id="下棋"><a href="#下棋" class="headerlink" title="下棋"></a>下棋</h1><p> 有一个1*n的棋盘，上面有若干个棋子，一个格子上可能有多个棋子。<br>你每次操作是先选择一个棋子，然后选择以下两个操作中的一个：<br>(1) 若该棋子不在 (1,1)，让这个棋子往左走一格，即从 (1,x) 走到 (1,x-1)；<br>(2) 若该棋子不在 (1,n)，且这个棋子曾经到达过(1,1)，让这个棋子往右走一格，即从 (1,x) 走到 (1,x+1)。<br>给定一开始每个格子上有几个棋子，再给定目标局面每个格子上需要几个棋子，求最少需要多少次操作。</p><blockquote><p>输入描述:<br>第一行一个正整数n表示棋盘大小。<br>第二行n个非负整数a_1, a_2, …, a_n 表示一开始 (1,i) 上有几个棋子。<br>第三行n个非负整数b_1, b_2, …, b_n 表示目标局面里 (1,i) 上有几个棋子。<br>保证 1 ≤ n ≤ 100,000，<br>输出描述:<br>输出一个非负整数，表示最少需要几次操作。<br>示例1<br>输入<br>5<br>0 0 1 1 0<br>1 0 0 0 1<br>输出<br>9<br>说明<br>先把(1,3)上的棋子走到(1,1)，花费了2次操作。<br>然后把(1,4)上的棋子走到(1,1)，再往右走到(1,5)，花费了3+4=7次操作。<br>所以一共花了9次操作。</p></blockquote><h1 id="旅游"><a href="#旅游" class="headerlink" title="旅游"></a>旅游</h1><p>在点点和评评的世界里有一个城市，城市是一个树形结构，由n个节点组成，有n-1条双向边把这些节点连在了一起（即在任意两个节点AB之间都存在从A到B的路径）。每条边都有一个边权，表示通过这条边需要的时间。<br>现在点点和评评想要从他们所在的S点到T点参加会议，他们想要在过程中体会旅途的乐趣，即好好欣赏每条边上的风景。详细地说，对于每条边，都有一个值l，l表示在从S点到T点的过程中，最少需要经过这条边的次数。因为会期将至，所以点点和评评想要在看够风景的情况下，花费尽可能少的时间。<br>点点和评评一共想询问m组这样的S和T，每组询问单独考虑，对于某一组特定的询问，他们想知道最少需要花费的时间。</p><blockquote><p>输入描述:<br>第一行一个整数n(1 ≤ n ≤ 100,000)表示点数。<br>接下来n-1行，每行四个整数x, y, z, l(1 ≤ x, y ≤ n, 1 ≤ z, l ≤ 1,000,000,000)，表示从x到y之间有一条边权为z的边，并且这条边至少要经过l次。<br>数据保证没有重边和自环。<br>接下来一个整数m(1 ≤ m ≤ 100,000)表示询问组数。<br>接下来m行，每行两个整数S, T(1 ≤ S, T ≤ n)表示一组询问。<br>输出描述:<br>输出m行，每行一个整数表示答案，因为答案可能很大，请输出答案 mod 1,000,000,007的值。<br>示例1<br>输入<br>3<br>1 2 10 1<br>2 3 20 2<br>2<br>1 3<br>3 2<br>输出<br>70<br>80<br>说明<br>  路径为：<br>  1-&gt;2-&gt;3-&gt;2-&gt;3<br>  3-&gt;2-&gt;1-&gt;2-&gt;3-&gt;2</p></blockquote><h1 id="迷宫"><a href="#迷宫" class="headerlink" title="迷宫"></a>迷宫</h1><p>给定一个n*m的迷宫，其中任意两个相邻单元之间可能存在墙，定义从单元S到单元T的路径为从S出发，通过向上、下、左、右四个方向上的移动组合，在不通过墙的前提下，最终到达T的轨迹。数据保证迷宫中的任意两点之间存在合法的路径。现在考虑一张有k个顶点的完全图G, 其中每个顶点对应迷宫中的某个单元，并且任意两个顶点之间连边的长度为其所对应迷宫单元之间的最短路径的长度。求G的最小生成树的边权和。</p><blockquote><p>输入描述:<br>第一行三个正整数n, m, k (2 ≤ n, m ≤ 2,000, k ≤ 100,000)。<br>接下来n行，每行m-1个 0/1。其中i行第j个数描述单元(i, j)和(i, j+1)之间是否存在墙。(1表示有墙，0表示没墙)<br>接下来n-1行，每行m个 0/1。其中i行第j个数描述单元(i, j)和(i+1, j)之间是否存在墙。(1表示有墙，0表示没墙)<br>接下来k行，每行两个正整数x, y，描述G中一个顶点所对应的单元，其中x代表行号，y代表列号。保证这k个顶点所对应的单元两两不同。<br>输出描述:<br>输出一行一个整数，描述最小生成树的边权和。<br>示例1<br>输入<br>5 5 3<br>0111<br>0010<br>0101<br>0110<br>0111<br>10000<br>10000<br>10001<br>10000<br>1 4<br>4 3<br>4 2<br>输出<br>9</p></blockquote><h1 id="塔防"><a href="#塔防" class="headerlink" title="塔防"></a>塔防</h1><p>袋鼠先生最近迷上了玩塔防游戏。塔防游戏中有若干座防御塔。一些防御塔能覆盖的范围为这里面任意三个防御塔形成的三角形区域的并集。注意这里的三角形包括边界，且如果三角形退化那么就相当于一条线段。换句话说，三个或以上的防御塔所能覆盖的范围为这些点形成的凸包，小于三个的防御塔没有任何功能。<br>    袋鼠先生发现有些防御塔和其他防御塔不同，如果拆除这个防御塔会导致防御的区域缩小那么我们称这个防御塔为关键的防御塔。这里区域缩小包括区域的面积减小，线段变短，或者从有到无。<br>    袋鼠先生在建造某些防御塔上面氪了很多金币，所以袋鼠先生希望能通过拆除其他的防御塔使得他氪过金币的防御塔全部成为关键的防御塔。还有一点，袋鼠先生希望剩下的防御塔能覆盖的面积是正的。<br>    袋鼠先生想知道有多少种这样的方案，答案可能很大，所以要对1,000,000,007取模。</p><blockquote><p>输入描述:<br>第一行一个整数n (1 ≤ n ≤ 200)。<br>接下来n行每行三个整数X_i, Y_i, W_i(0 ≤ |X_i|, |Y_i| ≤ 1,000,000,000, W_i ∈ {0,1})。(X_i, Y_i)表示每个塔的坐标。W_i表示每个塔的属性，如果W_i = 0表示这个塔可以拆除，否则表示这个塔不可拆除。<br>数据保证没有重点。<br>输出描述:<br>输出一行表示答案，即有多少种方案。</p></blockquote><blockquote><p>示例1<br>输入<br>5<br>0 0 0<br>0 2 0<br>2 0 0<br>2 2 0<br>1 1 1<br>输出<br>4</p></blockquote><blockquote><p>示例2<br>输入<br>8<br>0 0 0<br>0 1 1<br>0 2 0<br>1 2 1<br>2 2 0<br>2 1 1<br>2 0 0<br>1 0 1<br>输出<br>7</p></blockquote><blockquote><p>示例3<br>输入<br>6<br>0 0 0<br>0 4 0<br>4 0 0<br>4 4 0<br>2 2 1<br>2 1 0<br>输出<br>11</p></blockquote><h1 id="加解密"><a href="#加解密" class="headerlink" title="加解密"></a>加解密</h1><p>小团在美团旅行的安全部门实习研究加密算法，他提出了一个加密算法。现在小团把解密算法告诉你，希望你对数据进行解密。</p><p>加密数据包有两部分构成，一对数字a, b和一个字符串S。解密的方式S串最早在a/b的小数部分出现的位置k，k即为解密信息。小数点后从1开始计数。如果a/b不是一个无限循环小数，则在认为后面有无穷多个0，如5/4=1.2500000000…。<br>如果S不在a/b的小数部分出现，则无法解密输出-1。</p><blockquote><p>输入描述:<br>第一行两个正整数a, b (1 ≤ a, b ≤ 1,000,000,000)。第二行一个数字串S(1 ≤ |S| ≤100,000)。<br>输出描述:<br>输出一行k表示答案。</p></blockquote><blockquote><p>示例1<br>输入<br>1 2<br>500000000000<br>输出<br>1</p></blockquote><blockquote><p>示例2<br>输入<br>1234 5678<br>4579<br>输出<br>8</p></blockquote><blockquote><p>示例3<br>输入<br>233 999<br>333<br>输出<br>-1</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> 思维提升 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>美团2018CodeM资格赛</title>
      <link href="/2018/06/08/%E7%BE%8E%E5%9B%A22018CodeM%E8%B5%84%E6%A0%BC%E8%B5%9B/"/>
      <url>/2018/06/08/%E7%BE%8E%E5%9B%A22018CodeM%E8%B5%84%E6%A0%BC%E8%B5%9B/</url>
      <content type="html"><![CDATA[<p>共6道，3道AC，1道WA，2道放弃，还差的好远啊呜呜呜~</p><a id="more"></a><h1 id="下单"><a href="#下单" class="headerlink" title="下单"></a>下单</h1><p>美团在吃喝玩乐等很多方面都给大家提供了便利。最近又增加了一项新业务：小象生鲜。这是新零售超市，你既可以在线下超市门店选购生鲜食品，也可以在手机App上下单，最快30分钟就配送到家。<br>新店开张免不了大优惠。我们要在小象生鲜超市里采购n个物品，每个物品价格为ai，有一些物品可以选择八折优惠（称为特价优惠）。<br>有m种满减优惠方式，满减优惠方式只有在所有物品都不选择特价优惠时才能使用，且最多只可以选择最多一款。<br>每种满减优惠描述为(bi,ci)，即满bi减ci（当消费&gt;=bi时优惠ci）。<br>求要买齐这n个物品（必须一单买齐），至少需要多少钱（保留两位小数）。</p><p><strong>输入描述:</strong></p><blockquote><p>第一行，两个整数n,m。<br>接下来n行，每行一个正整数ai，以及一个0/1表示是否可以选择特价优惠（1表示可以）。<br>接下来m行，每行两个正整数bi,ci，描述一款满减优惠。</p></blockquote><blockquote><p>1 &lt;= n,m &lt;=10<br>1 &lt;= ai &lt;= 100<br>1 &lt;= ci &lt; bi &lt;= 1000</p></blockquote><p><strong>输出描述:</strong></p><blockquote><p>一行一个实数，表示至少需要消耗的钱数（保留恰好两位小数）。<br>示例1<br>输入<br>2 1<br>6 1<br>10 1<br>12 2<br>输出<br>12.80<br>示例2<br>输入<br>2 2<br>6 1<br>10 1<br>5 1<br>16 6<br>输出<br>10.00</p></blockquote><p><strong>分析：只能说幸好把，这第一题比较简单，否则一道都做不出来是真的尴尬，要么全价买然后享受满减优惠，要么直接特价买，最后比较大小即可，取值范围都宽松，怎么写都行</strong></p><p><strong>思路：用一个变量totalcost记录全价,decost记录特价（8折）,然后totalcost和满减政策依次比较取最优</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n,m = map(int,raw_input().split())</span><br><span class="line">        totalcost = <span class="number">0</span></span><br><span class="line">        decost = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            val,flag = map(int,raw_input().split())</span><br><span class="line">            totalcost += val</span><br><span class="line">            <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">                decost += val * <span class="number">0.8</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                decost += val</span><br><span class="line">        res = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            b,c = map(int,raw_input().split())</span><br><span class="line">            <span class="keyword">if</span> totalcost &gt;= b:</span><br><span class="line">                res = min(res,totalcost-c)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'%.2f'</span> % min(decost,res)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h1 id="可乐"><a href="#可乐" class="headerlink" title="可乐"></a>可乐</h1><p>小美和小团最近沉迷可乐。可供TA们选择的可乐共有k种，比如可口可乐、零度可乐等等，每种可乐会带给小美和小团不同的快乐程度。<br>TA们一共要买n瓶可乐，每种可乐可以买无限多瓶，小美会随机挑选其中的m瓶喝，剩下的n-m瓶小团喝。<br>请问应该如何购买可乐，使得小美和小团得到的快乐程度的和的期望值最大？<br>现在请求出购买可乐的方案。</p><p>输入描述:</p><blockquote><p>第一行三个整数n，m，k分别表示要买的可乐数、小美喝的可乐数以及可供选择的可乐种数。<br>接下来k行，每行两个整数a，b分别表示某种可乐分别给予小美和小团的快乐程度。<br>对于所有数据，1 &lt;= n &lt;= 10,000, 0 &lt;= m &lt;= n, 1 &lt;= k &lt;= 10,000, -10,000 &lt;= a, b &lt;= 10,000<br>输出描述:<br>一行k个整数，第i个整数表示购买第i种可乐的数目。<br>如果有多解，请输出字典序最小的那个。<br>对于两个序列 a1, a2, …, ak, b1, b2, …, bk，a的字典序小于b，当且仅当存在一个位置i &lt;= k满足：<br>ai &lt; bi且对于所有的位置 j &lt; i，aj = bj；<br>示例1<br>输入<br>2 1 2<br>1 2<br>3 1<br>输出<br>0 2<br><strong>说明</strong><br>一共有三种购买方案：</p><pre><code>1. 买2瓶第一类可乐，小美和小团各喝一瓶，期望得到的快乐程度和为1+2=3；2. 买1瓶第一类可乐和1瓶第二类可乐，小美和小团各有二分之一的概率喝到第一类可乐，另有二分之一的概率喝到第二类可乐，期望得到的快乐程度和为1*0.5+3*0.5+2*0.5+1*0.5=3.5；3. 买2瓶第二类可乐，小美和小团各喝一瓶，期望得到的快乐程度和为3+1=4。</code></pre></blockquote><p><strong>分析：</strong><br>这道题要注意是<strong>算期望之和最大</strong>，对于某一瓶可乐，假若提供的快乐度分别为x,y，我们来计算这瓶可乐能提供的快乐度，首先对于小美，选择到可乐的概率为m/n，则度为m/n * x,小团则为(n-m)/n * y。即对于若干组x,y，求ax+by的最大值，其中a+b=1。<br>如果能想到这一步，应该就不难了，因为x,y都有确定的值，在这么多组中x,y总有一个使得ax+by最大，所以就只买这一个就可以了。</p><p><strong>思路：</strong><br>依次读取数据进行比较，注意要按照字典序最小输出,（00002 02000）则输出00002</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n,m,k = map(int,raw_input().split())</span><br><span class="line">        index,res = <span class="number">0</span>,-float(<span class="string">'inf'</span>)</span><br><span class="line">        a,b = float(m)/n,float(n-m)/n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            x,y = map(int,raw_input().split())</span><br><span class="line">            <span class="keyword">if</span> a*x + b*y &gt;= res: </span><br><span class="line">                index = i</span><br><span class="line">                res = a*x + b*y</span><br><span class="line">        ans = [<span class="number">0</span>] * k</span><br><span class="line">        ans[index] = n</span><br><span class="line">        <span class="keyword">print</span> <span class="string">' '</span>.join(map(str,ans))</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h1 id="世界杯"><a href="#世界杯" class="headerlink" title="世界杯"></a>世界杯</h1><p>世界杯就要开始啦！真真正正的战斗从淘汰赛开始，现在我们给出球队之间的胜负概率，来预测每支球队夺冠的可能性。<br>在接下来的篇幅中，我们将简单介绍淘汰赛阶段的规则。<br>淘汰赛阶段的90分钟常规时间内（含补时阶段）进球多的球队取胜，如果参赛双方在90分钟内（含补时阶段）无法决出胜负，将进行上下半场各15分钟的加时赛。加时赛阶段，如果两队仍未分出胜负，则通过点球大战决出胜者。也就是说，每场比赛，有且仅有一个队能够晋级到下一轮。<br>淘汰赛共有16支球队参加（小组赛阶段共分8个小组，每组前两名晋级），对阵安排如下。</p><p>1/8决赛<br>A组第一对阵B组第二=胜者1<br>B组第一对阵A组第二=胜者2<br>C组第一对阵D组第二=胜者3<br>D组第一对阵C组第二=胜者4<br>E组第一对阵F组第二=胜者5<br>F组第一对阵E组第二=胜者6<br>G组第一对阵H组第二=胜者7<br>H组第一对阵G组第二=胜者8<br>获胜的8个队进入1/4决赛，即所谓“8强”<br>1/4决赛<br>胜者1对阵胜者3=胜者A<br>胜者2对阵胜者4=胜者B<br>胜者5对阵胜者7=胜者C<br>胜者6对阵胜者8=胜者D<br>1/4决赛的4个获胜队进入“4强”<br>半决赛<br>胜者A对阵胜者C<br>胜者B对阵胜者D<br>半决赛获胜两队进入决赛，失利的两队争夺三名<br>决赛获胜的队伍就是最后的冠军！</p><p>输入描述:</p><blockquote><p>球队会被以1..16进行标号，其分别表示：<br>1 A组第一；<br>2 B组第二；<br>3 C组第一；<br>4 D组第二；<br>5 E组第一；<br>6 F组第二；<br>7 G组第一；<br>8 H组第二；<br>9 B组第一；<br>10 A组第二；<br>11 D组第一；<br>12 C组第二；<br>13 F组第一；<br>14 E组第二；<br>15 H组第一；<br>16 G组第二。</p></blockquote><blockquote><p>数据共有16行，每行16个浮点数，第i行第j列的数Fi,j表示i和j进行比赛时i获胜（包括常规时间获胜、加时赛获胜以及点球大战获胜）的概率。<br>对于1 &lt;= i, j &lt;= 16 且 i != j, 满足0 &lt;= Fi,j &lt;= 1, Fi,j + Fj,i = 1；<br>对于1 &lt;= i &lt;= 16, 满足 Fi,i = 0。</p></blockquote><p>输出描述:</p><blockquote><p>输出一行16个浮点数，用空格隔开，分别表示每只球队获得世界杯的概率，结尾无空格。<br>绝对误差或相对误差在1e-5之内的解会被判为正确。</p></blockquote><p><strong>分析：</strong><br>本题从思维难度上来讲不高，但就是要仔细分析，认真写出哪几个队进行比赛，求概率乘积即可</p><p>12(胜者1)  34(胜者3)·····决出胜者A<br>···································进入决赛<br>56(胜者5)  78(胜者7)·····决出胜者C<br>··············································最终冠军<br>910(胜者2)  1112(胜者4)··决出胜者B<br>···································进入决赛<br>1314(胜者6) 1516(胜者8)··决出胜者D</p><p><strong>思路：</strong><br>分别用矩阵讲每轮的概率存储,例如first存储每个队进8强的概率,second存储4强的概率,依次类推。每次计算思路一样，是可以用函数写的，比如 helper(turn,list1,list2)两个list代表i，j遍历的数据，turn表示轮数，当计算third的时候就写second，那样写代码应该会好看很多，但是我心态已经不太好了，就这样把。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p = [[<span class="number">0.0</span>]*<span class="number">16</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">16</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">            p[i] = map(float,raw_input().split())</span><br><span class="line">        <span class="comment"># 8强概率</span></span><br><span class="line">        first = [<span class="number">0.0</span>] * <span class="number">16</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>]:</span><br><span class="line">            first[i] = p[i][i+<span class="number">1</span>]</span><br><span class="line">            first[i+<span class="number">1</span>] = p[i+<span class="number">1</span>][i]</span><br><span class="line">        <span class="comment"># 4强概率</span></span><br><span class="line">        second = [<span class="number">0.0</span>] * <span class="number">16</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>]:</span><br><span class="line">            second[i] = first[i] * (first[i+<span class="number">2</span>]*p[i][i+<span class="number">2</span>] + first[i+<span class="number">3</span>]*p[i][i+<span class="number">3</span>])</span><br><span class="line">            second[i+<span class="number">1</span>] = first[i+<span class="number">1</span>] * (first[i+<span class="number">2</span>]*p[i+<span class="number">1</span>][i+<span class="number">2</span>] + first[i+<span class="number">3</span>]*p[i+<span class="number">1</span>][i+<span class="number">3</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">2</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">14</span>]:</span><br><span class="line">            second[i] = first[i] * (first[i<span class="number">-2</span>]*p[i][i<span class="number">-2</span>] + first[i<span class="number">-1</span>]*p[i][i<span class="number">-1</span>])</span><br><span class="line">            second[i+<span class="number">1</span>] = first[i+<span class="number">1</span>] * (first[i<span class="number">-2</span>]*p[i+<span class="number">1</span>][i<span class="number">-2</span>] + first[i<span class="number">-1</span>]*p[i+<span class="number">1</span>][i<span class="number">-1</span>])</span><br><span class="line">        <span class="comment"># 决赛概率,写到这里才发现应该可以用函数写，龟龟，心态都蹦了</span></span><br><span class="line">        third = [<span class="number">0.0</span>] * <span class="number">16</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]:</span><br><span class="line">            P = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]:</span><br><span class="line">                P  += second[j]*p[i][j]</span><br><span class="line">            third[i] = second[i] * P</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]:</span><br><span class="line">            P = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]:</span><br><span class="line">                P  += second[j]*p[i][j]</span><br><span class="line">            third[i] = second[i] * P</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>]:</span><br><span class="line">            P = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> [<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>]:</span><br><span class="line">                P  += second[j]*p[i][j]</span><br><span class="line">            third[i] = second[i] * P</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>]:</span><br><span class="line">            P = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> [<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>]:</span><br><span class="line">                P  += second[j]*p[i][j]</span><br><span class="line">            third[i] = second[i] * P</span><br><span class="line">        <span class="comment"># 夺冠</span></span><br><span class="line">        final = [<span class="number">0.0</span>] * <span class="number">16</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> [<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>]:</span><br><span class="line">                final[i] += third[j]*p[i][j]</span><br><span class="line">            final[i] *= third[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>]:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]:</span><br><span class="line">                final[i] += third[j]*p[i][j]</span><br><span class="line">            final[i] *= third[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">print</span> <span class="string">' '</span>.join(map(str,final))</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h1 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h1><p>小胖参加了人生中最重要的比赛——MedoC资格赛。MedoC的资格赛由m轮构成，使用常见的“加权标准分”的规则。每位选手需要参加所有的m轮的比赛。在一轮中，能取得的分数为自己的成绩除掉最高分的成绩。每个选手的总分为每一轮获得的分数乘上这一轮比赛占得比重。如果在某一轮比赛中所有人获得了零分，那么所有选手在这一轮获得的分数都为0分。<br>比如说，资格赛一共3轮，三轮的权重分别为30%, 30%, 40%。在第一轮中，小胖获得了300分，最高分也为300分。在第二轮中，小胖获得了0分，最高分也为0分。在第三轮中，小胖获得了150分，最高分为300分，那么小胖的总分为(300/300)*30%+0*30%+(150/300)*40%=0.5。<br>一共有n位选手参加了比赛，其中成绩最高的k位选手能够晋级到初赛。如果有多人在分数线上同分，那么系统会随机在这些同分的人中选取，选满k个晋级为止。<br>小胖现在知道了每个选手每场比赛的成绩，但是由于他的疏忽，其中的某个人某场比赛的成绩消失了。所以更多人出线的情况变得未知起来。现在只知道成绩一定是0到C之间的一个整数（包含0和C）。<br>小胖想知道对于每个人的出线情况是怎么样的，也就是一定能出线，一定不能出线还是有可能出线。</p><p>输入描述:</p><blockquote><p>第一行四个正整数n,m,k,C (m &lt;= 6, k &lt;= n &lt;= 500, C &lt;= 500)。<br>接下来一行m个整数w1, w2, …, wm，表示每场比赛的权重，第i场比赛的权重为wi/(w1+w2+…+wm)，保证wi &gt;= 0且1 &lt;= w1 + w2 + … + wm &lt;= 1000。<br>接下来n行每行m个整数，第i个整数表示这个选手在第i场比赛中获得的成绩。如果这个数字为-1表示这个数据丢失，保证恰好有一个-1。</p></blockquote><p>输出描述:</p><blockquote><p>n行每行输出一个1到3之间的整数。1表示一定出线，2表示一定不出线，3表示可能出线。</p></blockquote><p>示例1<br>输入</p><blockquote><p>4 2 2 100<br>1 1<br>100 99<br>70 70<br>40 -1<br>100 39</p></blockquote><p>输出</p><blockquote><p>1<br>3<br>3<br>2</p></blockquote><p><strong>分析：</strong><br>其它分数全部固定只有这个-1会变（从0到C），不妨设本身这一轮比赛的最大分值为M<br>首先分数从0开始涨到M，这一过程其它人分数不变，这个人分数在上升，或许能挤掉一些人<br>然后分数从M开始涨到C，这一过程这个人分数不变，其他人分数在下降(对这轮分高的不利，排名可能会下降)，或许又能挤掉一些人<br>那么我想0，C这两个点应该是极端情况才对，应该只考虑这两种情况就行了吧，难道要考虑M的情况？<br>这道题还没搞懂是哪里想错了，就pass 3.7%（或许就过了测试样例吧），这里先写下两种思路吧</p><p><strong>思路：</strong><br>方法1： 假设没有这个-1，有谁可以肯定出线或者有概率出线（同分情况）是可以计算出来的，我们写一个函数来计算，返回一个列表，1代表肯定能出现，3代表有概率出线，0代表不能出线。然后我们找到这个-1，将它改成0计算一次结果，改成C计算一次结果，比较这两次结果即可。(pass 3.7%)</p><p>方法2： 先不考虑有-1的那一轮，将其他的分数全部计算，指针先指着第K个人，然后从0到C遍历，分别计算分数，但是这样感觉特别麻烦，比如 分数3 3 3 3 2，晋级4个，那么当2涨到3的时候，所有人状态全混了，代码上也没法简洁处理的样子，但是感觉这种办法肯定万无一失，毕竟全算了，而且C&lt;500，应该也不会超时。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n,m,k,C = map(int,raw_input().split())</span><br><span class="line">        w = map(int,raw_input().split())</span><br><span class="line">        S= sum(w)</span><br><span class="line">        w = [float(w[i])/S <span class="keyword">for</span> i <span class="keyword">in</span> range(m)]</span><br><span class="line"></span><br><span class="line">        score = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            score[i] = map(int,raw_input().split())</span><br><span class="line">        <span class="comment"># 计算函数</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">herlper</span><span class="params">(score)</span>:</span></span><br><span class="line">            rec = zip(*score)</span><br><span class="line">            res = [<span class="number">0</span>] * n</span><br><span class="line">            ans = [<span class="number">0</span>] * n</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">                M = float(max(rec[i]))</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                    res[j] += rec[i][j]/M * w[i]</span><br><span class="line">            heap = [(res[i],i) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">            heap.sort(key= <span class="keyword">lambda</span> x:x[<span class="number">0</span>],reverse=<span class="keyword">True</span>)</span><br><span class="line">            <span class="comment"># 处理同分情况</span></span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; k:</span><br><span class="line">                j = i+<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> heap[j][<span class="number">0</span>] == heap[j<span class="number">-1</span>][<span class="number">0</span>]:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> j &gt; k:</span><br><span class="line">                    ans[i:j] = [<span class="number">3</span>] * (j-i)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans[i:j] = [<span class="number">1</span>] * (j-i)</span><br><span class="line">                i = j</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        <span class="comment"># 找-1修改</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> score[i][j] == <span class="number">-1</span>:</span><br><span class="line">                    score[i][j] = <span class="number">0</span></span><br><span class="line">                    res1 = herlper(score)</span><br><span class="line">                    score[i][j] = C</span><br><span class="line">                    res2 = herlper(score)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> res1[i] == res2[i] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">print</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> res1[i] != res2[i]:</span><br><span class="line">                <span class="keyword">print</span> <span class="number">3</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">print</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h1 id="你的城市"><a href="#你的城市" class="headerlink" title="你的城市"></a>你的城市</h1><p>2018年第一季度，美团旅行的酒店业务以5770万的订单总量，成为行业第一名。<br>与此同时，美团旅行也提供机票、火车票、船票等各种服务，不断开辟新的目的旅游城市。最近新开的目的地，就包括对小A有特殊意义的偏僻小城C。<br>“我来到 你的城市 熟悉的那一条街。”小A哼着歌，从北京出发，要去C城。这对他非常重要，必须当天到达，虽然交通并不是非常方便。<br>但是，错过火车并不是一个小概率事件。为了保险起见，小A决定选择一个即使错过火车也存在补救措施的交通方案。（即假使未赶上原方案中的任何一班火车，依然可以改乘其他的车次能够在当天到达C城，但同时小A是一个乐观主义者，所以他认为改乘以后的所有车次都不会延误。）当然了，在满足上述条件的情况下，小A希望花费的钱越少越好（只考虑计划中的，不考虑发生意外时换乘带来的代价）。<br>城市及交通网可以看做一张n个点m条边的有向图。每个点代表一个城市（1号点代表北京，n号点代表C城）。每条边由一个五元组&lt; x, y, c, ts, td &gt;组成，表示存在一个车次，由ts时刻从城市x出发，在td时刻到达城市y，且花费为c元。<br>为了简化问题，ts，td均为以半小时为基本单位（具体格式见样例及Hint）。并假设每次中转最少需要花费半个小时，且中转只能发生在同一城市（即到达一个城市距离再次从这个城市出发至少需要间隔半个小时），注意，小 A 如果因为没赶上车次需要改乘，也需要半个小时的时间。<br>问小A到达C城最少需要花费多少钱（行程必须在这一天内完成，可以在0:00上车，也可以在24:00到达）。</p><p><strong>输入描述:</strong></p><blockquote><p>第一行，两个正整数n, m。n表示城市数量，m表示当天不同班次的火车数量。<br>接下来m行，每行3个整数x, y, c加两个字符串ts, td，均以空格作为分隔，表示当天的某一班火车。其中x, y, c, ts, td的含义如前描述。<br>所有的车次都是当天的，没有隔夜的票。<br>2 &lt;= n &lt;= 500, m &lt;= 15000, c &lt;= 1000, ts &lt; td，所有数均为正整数。<br>车次保证不过夜，时间范围0:00, 0:30, 1:00, … , 23:00, 23:30, 24:00，可能存在重复车次。</p></blockquote><p><strong>输出描述:</strong></p><blockquote><p>一个整数，表示存在补救措施的前提下，小A到达C城的最小花费。如果不存在这样的路径，则输出-1。<br>示例1<br>输入<br>    3 5<br>    1 3 800 18:00 21:00<br>    1 2 650 13:30 14:00<br>    2 3 100 14:00 18:00<br>    2 3 300 14:30 19:00<br>    2 3 200 15:00 19:30<br>输出<br>    950<br>说明<br>    选择第二个和第四个车次。<br>    第三个车次由于中转时间太短无法选择。第五个车次由于没有可改乘的航班无法选择。<br>    如果错过第二个车次，可以改乘第一个车次。如果错过第四个车次，可以改乘第五个车次。<br>示例2<br>输入<br>    3 5<br>    1 2 1000 0:00 12:00<br>    1 2 100 0:30 14:00<br>    1 2 100 0:30 15:00<br>    2 3 300 16:00 24:00<br>    2 3 200 16:30 24:00<br>输出<br>    1300<br>说明<br>    选择第一个和第四个车次。<br>    不能选择第二个车次是因为，如果错过了0:30的车次2，那么同样在0:30出发的车次3也是来不及改乘的。<br>示例3<br>输入<br>    3 4<br>    1 2 100 0:30 14:00<br>    1 2 200 0:30 15:00<br>    2 3 300 16:00 24:00<br>    2 3 200 16:30 24:00<br>输出<br>    -1<br>说明<br>    和样例二类似，但是缺少了原先的车次一，所以没有换乘方案。<br>示例4<br>输入<br>    3 4<br>    1 2 100 0:30 14:00<br>    1 2 200 1:00 16:00<br>    2 3 300 16:00 24:00<br>    2 3 200 16:30 24:00<br>输出<br>    400<br>说明<br>    选择第一个和第三个车次。<br>示例5<br>输入<br>    3 4<br>    1 2 100 0:30 14:00<br>    1 2 200 1:00 16:30<br>    2 3 300 16:00 24:00<br>    2 3 200 16:30 24:00<br>输出<br>    -1<br>说明<br>    和样例四类似，但假如错过了第一个车次，改乘车次二在16:30到达城市2是不足以赶上16:30出发的车次四的。</p></blockquote><h1 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h1><p>美团外卖日订单已经超过2000万，背后有一个非常复杂的智能调度系统。<br>我们考虑一个简化的情形，有n个外卖小哥要去 n 家商店取货，第 i 个外卖小哥到达商店 j 需要时间 e[i][j] 。现在有 m 对外卖小哥和商店的合作关系。假定每个外卖小哥只能取到一个货物，每个商店只需要一位外卖小哥取货。<br>询问最少多少时间，能有 k 位外卖小哥到达 k 个商店取到货物？对于每个 k ，都输出一个数表示最少使用时间，如果无解输出 -1。</p><p>输入描述:</p><blockquote><p>第一行输入两个整数 n , m （1 &lt;= n &lt;= 1000 , 1 &lt;= m &lt;= 100000）。<br>接下来 m 行，每行输入 3 个整数 i , j , e[i][j] (1 &lt;= i, j &lt;= n , 0 &lt;= e[i][j] &lt;= 10^9)，定义如题所述。<br>注：本题测试用例较多，请耐心等待判题结果，也可以去排行榜刷新查看自己的提交结果。</p></blockquote><p>输出描述:</p><blockquote><p>输出一行n个整数，第 i 个整数，表示当 k=i 时，需要的最少时间，如果无解输出-1，结尾无空格。<br>示例1<br>输入<br>    3 7<br>    1 3 5<br>    2 3 2<br>    3 1 7<br>    1 2 0<br>    2 3 2<br>    3 2 0<br>    2 1 5<br>输出<br>    0 2 5</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> 思维提升 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 453 Minimum Moves to Equal Array Elements</title>
      <link href="/2018/06/05/Leetcode-453-Minimum-Moves-to-Equal-Array-Elements/"/>
      <url>/2018/06/05/Leetcode-453-Minimum-Moves-to-Equal-Array-Elements/</url>
      <content type="html"><![CDATA[<p>Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1.</p><blockquote><p>Example:<br>Input:<br>[1,2,3]<br>Output:<br>3<br>Explanation:<br>Only three moves are needed (remember each move increments two elements):<br>[1,2,3]  =&gt;  [2,3,3]  =&gt;  [3,4,3]  =&gt;  [4,4,4]</p></blockquote><a id="more"></a><p><b>分析：</b><br>每次对n-1个数同时提升1，问提升多少次才能使所有数相同，做这种题就一定要动笔写下来</p><p><b>思路：</b><br>我们首先来对一个简单点的任意有序数组进行分析，如[a,b,c]，如何使它最后全变成相等呢，首先要明白最后相等的那个数是一定不可能小于c的，所以我们不妨先将a,变成c，即提升c-a次，此时数组为 [c,b+c-a,c],那么显然此时只要将0，2两个位置同时提升b-a即可，故最后答案为b+c-2a</p><p>如果是4个数呢？<br>[a,b,c,d]                         先提升d-a，<br>[d,b+d-a,c+d-a,d]                提升b-a<br>[d+b-a,b+d-a,c+b+d-2a,d+b-a]    提升c-a即可<br>故最后答案为 b+c+d-3a = a+b+c+d - 4a<br>综合这些规律我们可以发现答案就为 sum(nums) - min(nums) * len(nums)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minMoves</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> sum(nums) - min(nums)*len(nums)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">84</span> / <span class="number">84</span> test cases passed.</span><br><span class="line">difficulty: easy</span><br><span class="line">Runtime: <span class="number">68</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 462 Minumum Moves to Equal Array Elements II</title>
      <link href="/2018/06/05/Leetcode-462-Minumum-Moves-to-Equal-Array-Elements-II/"/>
      <url>/2018/06/05/Leetcode-462-Minumum-Moves-to-Equal-Array-Elements-II/</url>
      <content type="html"><![CDATA[<p>Given a non-empty integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1.<br>You may assume the array’s length is at most 10,000.</p><blockquote><p>Example:<br>Input:<br>[1,2,3]<br>Output:<br>2<br>Explanation:<br>Only two moves are needed (remember each move increments or decrements one element):<br>[1,2,3]  =&gt;  [2,2,3]  =&gt;  [2,2,2]</p></blockquote><a id="more"></a><p><b>分析：</b><br>也就是将所有数变成同一个数的花费，数组长度不超过10000，说明n^2的方法不行</p><p><b>思路：</b><br>我们先作几个简答的分析，比如一个有序数组，根据长度不同我们来依次分析<br> 1.长度为3，[a,b,c]，那么显然都往b靠花费最小（这个很容易证）<br>     cost = c-b + b-a = c-a<br> 2.长度为4，[a,b,c,d],先分析往b靠好还是往c靠好<br>     cost_b = d-b + c-b + b-a = d+c - (a+b)<br>     cost_c = d-c + c-b + c-a = d+c - (a+b)<br> 3.长度为5，[a,b,c,d,e]，显然是往c靠<br>     cost = e-c + d-c + c-b + c-a = d+e - (a+b)<br> 依次类推，我们发现花费就应该是数组的后半段减去数组的前半段，分奇偶判断一下即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minMoves2</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        index = len(nums)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> sum(nums[index+<span class="number">1</span>:]) - sum(nums[:index])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> sum(nums[index:]) - sum(nums[:index])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">29</span> / <span class="number">29</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">61</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 461 Hamming Distance</title>
      <link href="/2018/06/05/Leetcode-461-Hamming-Distance/"/>
      <url>/2018/06/05/Leetcode-461-Hamming-Distance/</url>
      <content type="html"><![CDATA[<p><img src="/images/leetcode_461.png" alt=""><br><a id="more"></a><br><b>分析：</b><br>或许这就是弱智题吧</p><p><b>思路：</b><br>既然要找位不同的地方，自然就会想到异或操作，异或的结果二进制中1的个数便是答案</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingDistance</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :type y: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> bin(x^y).count(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">149</span> / <span class="number">149</span> test cases passed.</span><br><span class="line">difficulty: easy</span><br><span class="line">Runtime: <span class="number">41</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> bit </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 839 Similar String Groups</title>
      <link href="/2018/06/05/Leetcode-839-Similar-String-Groups/"/>
      <url>/2018/06/05/Leetcode-839-Similar-String-Groups/</url>
      <content type="html"><![CDATA[<p><img src="/images/leetcode_839.png" alt=""><br><a id="more"></a></p><p><b>分析：</b><br>在A中所有字符串都是由相同的字符组成的，但顺序不一样，如果两个字符串只有两个字符位置不同，那么我们把这两个字符串归为一组，求共有多少组。<br>注意：len(A)*len(A[i]) &lt; 20000,保证了n^2*m或者m^2*n的复杂度是可行的</p><p><b>思路：</b><br>这是一道典型的union find题，是在prim算法还是在kruskal算法中这个思想被用到了。这里我介绍两种方法，一种是union find，一种是dfs</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSimilarGroups</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 判断两个字符串是否是一个组</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isSimilar</span><span class="params">(s1,s2)</span>:</span></span><br><span class="line">            cnt = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s1)):</span><br><span class="line">                <span class="keyword">if</span> s1[i] != s2[i]:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> cnt &gt; <span class="number">2</span>: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 标准的union find思路，也就是将所有在一个组内字符串用同一个字符串记录</span></span><br><span class="line">        <span class="comment"># 如 arts:arts, rats: arts, tars: arts, star: star</span></span><br><span class="line">        d = &#123;u:u <span class="keyword">for</span> u <span class="keyword">in</span> A&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(u)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> u != d[u]:</span><br><span class="line">                d[u] = find(d[u])</span><br><span class="line">            <span class="keyword">return</span> d[u]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#设初始组数为n，每找到一个该在同一组的总组数就减1</span></span><br><span class="line">        self.n = len(A)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(x,y)</span>:</span></span><br><span class="line">            x,y = find(x),find(y)</span><br><span class="line">            <span class="keyword">if</span> x != y:</span><br><span class="line">                d[y] = x</span><br><span class="line">                self.n -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> range(x+<span class="number">1</span>,len(A)):</span><br><span class="line">                <span class="keyword">if</span> isSimilar(A[x],A[y]): </span><br><span class="line">                    union(A[x],A[y])</span><br><span class="line">        <span class="keyword">return</span> self.n</span><br><span class="line"></span><br><span class="line">O(m*n^<span class="number">2</span>) time 其中n为A的长度，m为A[i]的长度</span><br></pre></td></tr></table></figure><p><strong>再介绍一种dfs方法，我们把每个字符串看做一个节点，如果两个字符串是同一个组则将它们相连接，最后构成一个图，在这个图中用dfs方法找有多少个连通分量</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSimilarGroups</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        Graph = collections.defaultdict(list)</span><br><span class="line">        <span class="comment"># 判断两个字符串是否是在一个组</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isSimilar</span><span class="params">(x,y)</span>:</span></span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(x)):</span><br><span class="line">                <span class="keyword">if</span> x[i] != y[i]:</span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> res &gt; <span class="number">2</span>: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">return</span> res == <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构建图，O(m*n^2) time</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(A)):</span><br><span class="line">                <span class="keyword">if</span> isSimilar(A[i],A[j]):</span><br><span class="line">                    Graph[i].append(j)</span><br><span class="line">                    Graph[j].append(i)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 用一个数组判断节点是否已被访问</span></span><br><span class="line">        visited = [<span class="number">0</span>] * len(A)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(u)</span>:</span></span><br><span class="line">            visited[u] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> Graph[u]:</span><br><span class="line">                <span class="keyword">if</span> visited[v]: <span class="keyword">continue</span></span><br><span class="line">                dfs(v)</span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            <span class="keyword">if</span> visited[i]: <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 一次dfs得到一个连通分量</span></span><br><span class="line">            dfs(i)</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>这道题还挺可惜的，这两种方法用python写都tle了，但是用java,c++都完全ok，就学下思路吧~</p>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dfs </tag>
            
            <tag> union find </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 846 Hand of Straights</title>
      <link href="/2018/06/04/Leetcode-846-Hand-of-Straights/"/>
      <url>/2018/06/04/Leetcode-846-Hand-of-Straights/</url>
      <content type="html"><![CDATA[<p>Alice has a hand of cards, given as an array of integers.<br>Now she wants to rearrange the cards into groups so that each group is size W, and consists of W consecutive cards.<br>Return true if and only if she can.</p><blockquote><p>Example 1:<br>Input: hand = [1,2,3,6,2,3,4,7,8], W = 3<br>Output: true<br>Explanation: Alice’s hand can be rearranged as [1,2,3],[2,3,4],[6,7,8].</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: hand = [1,2,3,4,5], W = 4<br>Output: false<br>Explanation: Alice’s hand can’t be rearranged into groups of 4.</p></blockquote><p>Note:<br>    1 &lt;= hand.length &lt;= 10000<br>    0 &lt;= hand[i] &lt;= 10^9<br>    1 &lt;= W &lt;= hand.length</p><p><b>分析：</b><br>将一组数据分为若干组，每组大小都是W，并且是W个连续数(我一开始看错题目了，以为是分成W组，并每组都是W大小，搞得提交错了好几次)</p><p><b>思路：</b><br>先判断能不能均分，不能直接False，然后用字典将数组存起来，每次用最小的数开始分析，判断连续W个数是不是都存在，直至字典为空</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNStraightHand</span><span class="params">(self, hand, W)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type hand: List[int]</span></span><br><span class="line"><span class="string">        :type W: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 判断是否能均分</span></span><br><span class="line">        n = len(hand)</span><br><span class="line">        <span class="keyword">if</span> n % W != <span class="number">0</span>: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        d = collections.Counter(hand)</span><br><span class="line">        <span class="keyword">while</span> d:</span><br><span class="line">            m = min(d.keys())</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(W):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> d[m+i]: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                d[m+i] -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 如果数字用光了则删除key值</span></span><br><span class="line">                <span class="keyword">if</span> d[m+i] == <span class="number">0</span>: <span class="keyword">del</span> d[m+i]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="number">65</span> / <span class="number">65</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">1156</span> ms</span><br></pre></td></tr></table></figure><p>因为每次都要取最小值，其实这个复杂度达到了n^2/W,也是测试数据给面子吧，讲道理这个复杂度应该是不行的<br>当然要修改很简单，我们直接对d.keys()从小到大遍历，如果d[i]&gt;0我们才进行操作，否则跳过</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isNStraightHand</span><span class="params">(hand,W)</span>:</span></span><br><span class="line">n = len(hand)</span><br><span class="line"><span class="keyword">if</span> n % W != <span class="number">0</span>: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">d = collections.Counter(hand)</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> sorted(d.keys()):</span><br><span class="line"><span class="keyword">if</span> d[e] &gt; <span class="number">0</span>:</span><br><span class="line"><span class="comment"># 这里倒序遍历是因为要保证d[e]的值最后才变</span></span><br><span class="line"><span class="keyword">for</span> step <span class="keyword">in</span> range(W)[::<span class="number">-1</span>]:</span><br><span class="line">d[e+step] -= d[e]</span><br><span class="line"><span class="keyword">if</span> d[e+step] &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="number">65</span> / <span class="number">65</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">194</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 845 Longest Mountain in Array</title>
      <link href="/2018/06/04/Leetcode-845-Longest-Mountain-in-Array/"/>
      <url>/2018/06/04/Leetcode-845-Longest-Mountain-in-Array/</url>
      <content type="html"><![CDATA[<p>Let’s call any contiguous subarray B (of A) a mountain if the following properties hold:<br>    B.length &gt;= 3<br>    There exists some 0 &lt; i &lt; B.length - 1 such that B[0] &lt; B[1] &lt; … B[i-1] &lt; B[i] &gt; B[i+1] &gt; … &gt; B[B.length - 1]</p><p>(Note that B could be any subarray of A, including the entire array A.)<br>Given an array A of integers, return the length of the longest mountain.<br>Return 0 if there is no mountain.</p><blockquote><p>Example 1:<br>Input: [2,1,4,7,3,2,5]<br>Output: 5<br>Explanation: The largest mountain is [1,4,7,3,2] which has length 5.</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: [2,2,2]<br>Output: 0<br>Explanation: There is no mountain.</p></blockquote><p>Note:<br>    0 &lt;= A.length &lt;= 10000<br>    0 &lt;= A[i] &lt;= 10000</p><p><b>分析：</b><br>在一个数组中找最长的先严格上升后严格下降的连续序列，注意A.length达到10000，n^2方法显然不行</p><p><b>思路：</b><br>直接遍历一遍，找到一个上升点然后开始遍历，处理一些小情况即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestMountain</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># O(n) time, O(1) space</span></span><br><span class="line">        i,n = <span class="number">0</span>,len(A)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n<span class="number">-1</span>:</span><br><span class="line">        <span class="comment">#找到一个上升点</span></span><br><span class="line">            <span class="keyword">if</span> A[i] &lt; A[i+<span class="number">1</span>]:</span><br><span class="line">            <span class="comment"># 先找上升序列</span></span><br><span class="line">                j = i+<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> j &lt; n <span class="keyword">and</span> A[j] &gt; A[j<span class="number">-1</span>]: j += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 如若遍历到数组末尾直接返回结果</span></span><br><span class="line">                <span class="keyword">if</span> j == n: <span class="keyword">return</span> res</span><br><span class="line">                <span class="comment"># 这个判断语句处理[1,2,2,0]这种情况</span></span><br><span class="line">                <span class="keyword">if</span> A[j] != A[j<span class="number">-1</span>]: </span><br><span class="line">                    <span class="keyword">while</span> j &lt; n <span class="keyword">and</span> A[j] &lt; A[j<span class="number">-1</span>]: j += <span class="number">1</span></span><br><span class="line">                    res = max(res,j-i)</span><br><span class="line">                    i = j<span class="number">-2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    i = j<span class="number">-1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">O(n) time, O(<span class="number">1</span>) space</span><br><span class="line"><span class="number">72</span> / <span class="number">72</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">73</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 844 Backspace String Compare</title>
      <link href="/2018/06/04/Leetcode-844-Backspace-String-Compare/"/>
      <url>/2018/06/04/Leetcode-844-Backspace-String-Compare/</url>
      <content type="html"><![CDATA[<p>Given two strings S and T, return if they are equal when both are typed into empty text editors. # means a backspace character.</p><blockquote><p>Example 1:<br>Input: S = “ab#c”, T = “ad#c”<br>Output: true<br>Explanation: Both S and T become “ac”.</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: S = “ab##”, T = “c#d#”<br>Output: true<br>Explanation: Both S and T become “”.</p></blockquote><blockquote><p>Example 3:<br>Input: S = “a##c”, T = “#a#c”<br>Output: true<br>Explanation: Both S and T become “c”.</p></blockquote><blockquote><p>Example 4:<br>Input: S = “a#c”, T = “b”<br>Output: false<br>Explanation: S becomes “c” while T becomes “b”.</p></blockquote><p>Note:<br>    1 &lt;= S.length &lt;= 200<br>    1 &lt;= T.length &lt;= 200<br>    S and T only contain lowercase letters and ‘#’ characters.</p><p><b>分析：</b><br>无非就是一个带取消键情况的判断输入是否相等的简单题目</p><p><b>思路：</b><br>说实话我第一时间还没反应过来这道题应该用栈这么显而易见的思想，果然还是对这些数据结构太不敏感了，还远远不行啊</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backspaceCompare</span><span class="params">(self, S, T)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :type T: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(s)</span>:</span></span><br><span class="line">            stack = []</span><br><span class="line">            <span class="keyword">for</span> e <span class="keyword">in</span> s:</span><br><span class="line">                <span class="keyword">if</span> e == <span class="string">'#'</span>:</span><br><span class="line">                    <span class="keyword">if</span> stack:</span><br><span class="line">                        stack.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack.append(e)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span>.join(stack)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper(S) == helper(T)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">104</span> / <span class="number">104</span> test cases passed.</span><br><span class="line">difficulty: easy</span><br><span class="line">Runtime: <span class="number">38</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> stack </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 841 Keys and Rooms</title>
      <link href="/2018/05/28/Leetcode-841-Keys-and-Rooms/"/>
      <url>/2018/05/28/Leetcode-841-Keys-and-Rooms/</url>
      <content type="html"><![CDATA[<p>There are N rooms and you start in room 0.  Each room has a distinct number in 0, 1, 2, …, N-1, and each room may have some keys to access the next room. </p><p>Formally, each room i has a list of keys rooms[i], and each key rooms[i][j] is an integer in [0, 1, …, N-1] where N = rooms.length.  A key rooms[i][j] = v opens the room with number v.</p><p>Initially, all the rooms start locked (except for room 0).<br>You can walk back and forth between rooms freely.<br>Return true if and only if you can enter every room.<br><a id="more"></a></p><blockquote><p>Example 1:<br>Input: [[1],[2],[3],[]]<br>Output: true<br>Explanation:<br>We start in room 0, and pick up key 1.<br>We then go to room 1, and pick up key 2.<br>We then go to room 2, and pick up key 3.<br>We then go to room 3.  Since we were able to go to every room, we return true.</p></blockquote><blockquote><p>Example 2:<br>Input: [[1,3],[3,0,1],[2],[0]]<br>Output: false<br>Explanation: We can’t enter the room with number 2.</p></blockquote><p><strong>Note:</strong></p><pre><code>1. 1 &lt;= rooms.length &lt;= 10002. 0 &lt;= rooms[i].length &lt;= 10003. The number of keys in all rooms combined is at most 3000.</code></pre><p><b>分析：</b><br>初始在房间0，每个房间有钥匙，钥匙打开对应的门，可以在打开的门之间任意走动，问能不能打开所有的门，房间数不超过1000，每个房间内钥匙不超过1000</p><p><b>思路：</b><br>显然是dfs，用一个visited集合来记录走过了哪些房间，最后判断visied的长度是不是等于房间的长度即可,我觉得这道题不配是medium，应该是easy</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canVisitAllRoom</span><span class="params">(rooms)</span>:</span></span><br><span class="line">n = len(rooms)</span><br><span class="line">visited = set()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(u)</span>:</span></span><br><span class="line"><span class="keyword">if</span> u <span class="keyword">in</span> visited: <span class="keyword">return</span></span><br><span class="line">visited.add(u)</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> rooms[u]:</span><br><span class="line">dfs(v)</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> len(visited) == n</span><br><span class="line"></span><br><span class="line"><span class="number">66</span> / <span class="number">66</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">39</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 840 Magic Squares In Grid</title>
      <link href="/2018/05/28/Leetcode-840-Magic-Squares-In-Grid/"/>
      <url>/2018/05/28/Leetcode-840-Magic-Squares-In-Grid/</url>
      <content type="html"><![CDATA[<p>A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum.</p><p>Given an grid of integers, how many 3 x 3 “magic square” subgrids are there?  (Each subgrid is contiguous).<br><a id="more"></a></p><blockquote><p><strong>Example 1:</strong><br><strong>Input</strong>:<br>[[4,3,8,4],<br>[9,5,1,9],<br> 2,7,6,2]]<br><strong>Output:</strong> 1<br><strong>Explanation:</strong><br>The following subgrid is a 3 x 3 magic square:<br>438<br>951<br>276<br>while this one is not:<br>384<br>519<br>762<br>In total, there is only one magic square inside the given grid.</p></blockquote><p>Note:<br>    1 &lt;= grid.length &lt;= 10<br>    1 &lt;= grid[0].length &lt;= 10<br>    0 &lt;= grid[i][j] &lt;= 15</p><p><b>分析：</b><br>题目定义了一个概念，3x3的矩阵，元素从1到9，横纵对角线之和相等，把这个称为”magic square”，给定一个二维列表，找有多少个magic square，数据长度不超过10 x 10，说明这道题随便写都不会超时</p><p><b>思路：</b><br>从1到9取值，那么最中间的数必是5，至于为什么，想不通的我建议你放弃，只要从1，1到n-1,n-1遍历，如果满足值为5就进行判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numMagicSquaresInside</span><span class="params">(grid)</span>:</span></span><br><span class="line">m,n = len(grid),len(grid[<span class="number">0</span>])</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isMagic</span><span class="params">(i,j)</span>:</span></span><br><span class="line"><span class="keyword">for</span> x,y <span class="keyword">in</span> [(<span class="number">-1</span>,<span class="number">-1</span>),(<span class="number">-1</span>,<span class="number">0</span>),(<span class="number">-1</span>,<span class="number">1</span>),(<span class="number">0</span>,<span class="number">-1</span>),(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">1</span>,<span class="number">-1</span>),(<span class="number">1</span>,<span class="number">1</span>)]:</span><br><span class="line"><span class="keyword">if</span> grid[i+x][j+y] &gt; <span class="number">9</span> <span class="keyword">or</span> grid[i+x][j+y] &lt; <span class="number">1</span>: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">return</span> grid[i<span class="number">-1</span>][j<span class="number">-1</span>]+grid[i+<span class="number">1</span>][j+<span class="number">1</span>] == grid[i+<span class="number">1</span>][j<span class="number">-1</span>]+grid[i<span class="number">-1</span>][j+<span class="number">1</span>] == grid[i][j<span class="number">-1</span>]+grid[i][j+<span class="number">1</span>] == grid[i+<span class="number">1</span>][j]+grid[i<span class="number">-1</span>][j] </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m<span class="number">-1</span>):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n<span class="number">-1</span>):</span><br><span class="line"><span class="keyword">if</span> grid[i][j] == <span class="number">5</span> <span class="keyword">and</span> isMagic(i,j): res += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">87</span> / <span class="number">87</span> test cases passed.</span><br><span class="line">difficulty: easy</span><br><span class="line">Runtime: <span class="number">33</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 611 Valid Triangle Number</title>
      <link href="/2018/05/28/Leetcode-611-Valid-Triangle-Number/"/>
      <url>/2018/05/28/Leetcode-611-Valid-Triangle-Number/</url>
      <content type="html"><![CDATA[<h1 id="Valid-Triangle-Number"><a href="#Valid-Triangle-Number" class="headerlink" title="Valid Triangle Number"></a>Valid Triangle Number</h1><p>Given an array consists of non-negative integers, your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.</p><blockquote><p>Example 1:<br>Input: [2,2,3,4]<br>Output: 3<br>Explanation:<br>Valid combinations are:<br>2,3,4 (using the first 2)<br>2,3,4 (using the second 2)<br>2,2,3</p></blockquote><a id="more"></a><p><strong>Note:</strong><br>    The length of the given array won’t exceed 1000.<br>    The integers in the given array are in the range of [0, 1000].</p><p><b>分析：</b><br>这道题就是在一个数组内找有多少个三元组满足三个值能构成一个三角形，（大于两边之差，小于两边之和）。 注意，数据长度不超过1000，n^2的方法可行</p><p><b>思路：</b><br>先将数组排序，固定前两个值，遍历第三个值，但是不用重复，比如4，5，6，7，8，9，12；第一次固定4，5，第三个值遍历到9结束，然后5变成6，从9遍历到12，中间一定满足故不用重新遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">triangleNumber</span><span class="params">(nums)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">:type nums: List[int]</span></span><br><span class="line"><span class="string">:rtype: int</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">n = len(nums)</span><br><span class="line">nums.sort()</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>):</span><br><span class="line">k = i+<span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,n<span class="number">-1</span>):</span><br><span class="line"><span class="keyword">if</span> k == j: k += <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> k &lt; n <span class="keyword">and</span> nums[k] &lt; nums[i] + nums[j]: </span><br><span class="line">k += <span class="number">1</span></span><br><span class="line">res += k - (j+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"220 / 220 test cases passed.</span></span><br><span class="line"><span class="string">difficulty: medium</span></span><br><span class="line"><span class="string">Runtime: 534 ms"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 802 Find Eventual Safe States</title>
      <link href="/2018/05/22/Leetcode-802-Find-Eventual-Safe-States/"/>
      <url>/2018/05/22/Leetcode-802-Find-Eventual-Safe-States/</url>
      <content type="html"><![CDATA[<p><img src="/images/leetcode_802.png" alt="description"><br><a id="more"></a><br><b>分析：</b><br>这道题是要在一个图里找不在环路中的节点，显然，dfs遍历即可，不过这里用拓扑排序方法也可以做，因为dfs这个方法我掌握得还不太熟练，老出各种小错误，等我钻研更深之后再补上dfs方法</p><p><b>思路：</b><br>记录下每个节点的出度，如果出度为0那必然是环路外的节点，然后将该点以及指向该点的边删除，继续寻找出度为0的点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eventualSafeNodes</span><span class="params">(self, graph)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type graph: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> graph: <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        n = len(graph)</span><br><span class="line">        <span class="comment"># 用字段存储每个节点的父节点</span></span><br><span class="line">        d = &#123;u:[] <span class="keyword">for</span> u <span class="keyword">in</span> range(n)&#125;</span><br><span class="line">        degree = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> u <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> graph[u]:</span><br><span class="line">                d[v].append(u)</span><br><span class="line">            degree[u] = len(graph[u])</span><br><span class="line"></span><br><span class="line">        Q = [u <span class="keyword">for</span> u <span class="keyword">in</span> range(n) <span class="keyword">if</span> degree[u]==<span class="number">0</span>]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> Q:</span><br><span class="line">            node = Q.pop()</span><br><span class="line">            res.append(node)</span><br><span class="line">            <span class="keyword">for</span> nodes <span class="keyword">in</span> d[node]:</span><br><span class="line">                degree[nodes] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> degree[nodes] == <span class="number">0</span>:</span><br><span class="line">                    Q.append(nodes)</span><br><span class="line">        <span class="keyword">return</span> sorted(res)</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dfs </tag>
            
            <tag> topsort </tag>
            
            <tag> graph </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 838 Push Dominoes</title>
      <link href="/2018/05/22/Leetcode-838-Push-Dominoes/"/>
      <url>/2018/05/22/Leetcode-838-Push-Dominoes/</url>
      <content type="html"><![CDATA[<p><img src="/images/leetcode_838_1.png" alt="图1"><br><a id="more"></a><br><img src="/images/leetcode_838_2.png" alt="图2"></p><p><b>分析：</b><br>就是一个超简单的推木板游戏，我是搞不懂为什么discuss里面那么多人还tle呢，直接遍历一遍就可以出结果，one pass solution,O(1) space, 要不是英文不太好就去发攻略了罒ω罒</p><p><b>思路：</b><br>用res存储最后的结果，遍历整个字符串，’.’直接跳过，当遍历到’L’时，看上一个出现的是’L’还是’R’,如果是’L’，全往左边倒，如果是’R’，计算距离一半R一半L；遍历到’R’同理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pushDominoes</span><span class="params">(self, dominoes)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type dominoes: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 上一个出现的关键点用last表示，初始为None，处理左边界情况</span></span><br><span class="line">        last = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(dominoes):</span><br><span class="line">            j = i</span><br><span class="line">            <span class="comment"># 遍历到'.'就不管，一直到找到一个'R或L'为止</span></span><br><span class="line">            <span class="keyword">while</span> j+<span class="number">1</span> &lt; len(dominoes) <span class="keyword">and</span> dominoes[j] == <span class="string">'.'</span>: j += <span class="number">1</span> </span><br><span class="line">            <span class="comment"># 找到L的情况</span></span><br><span class="line">            <span class="keyword">if</span> dominoes[j] == <span class="string">'L'</span>:</span><br><span class="line">                <span class="keyword">if</span> last == <span class="string">'R'</span>:</span><br><span class="line">                    res += (j-i)/<span class="number">2</span> * <span class="string">'R'</span> + (j-i)%<span class="number">2</span> * <span class="string">'.'</span> + (j-i)/<span class="number">2</span> * <span class="string">'L'</span> + <span class="string">'L'</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res += <span class="string">'L'</span> * (j-i+<span class="number">1</span>)</span><br><span class="line">                last = <span class="string">'L'</span></span><br><span class="line">            <span class="comment"># 找到R的情况</span></span><br><span class="line">            <span class="keyword">elif</span> dominoes[j] == <span class="string">'R'</span>:</span><br><span class="line">                <span class="keyword">if</span> last == <span class="string">'R'</span>:</span><br><span class="line">                    res += (j-i+<span class="number">1</span>) * <span class="string">'R'</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res += (j-i) * <span class="string">'.'</span> + <span class="string">'R'</span></span><br><span class="line">                last = <span class="string">'R'</span></span><br><span class="line">            i = j + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 出来之后，处理右边界情况</span></span><br><span class="line">        <span class="keyword">if</span> last == <span class="string">'R'</span>:</span><br><span class="line">            res += <span class="string">'R'</span> * (len(dominoes)-len(res))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res += <span class="string">'.'</span> * (len(dominoes)-len(res))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">36</span> / <span class="number">36</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">244</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 836 Rectangle Overlap</title>
      <link href="/2018/05/22/Leetcode-836-Rectangle-Overlap/"/>
      <url>/2018/05/22/Leetcode-836-Rectangle-Overlap/</url>
      <content type="html"><![CDATA[<p>A rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) are the coordinates of its bottom-left corner, and (x2, y2) are the coordinates of its top-right corner.</p><p>Two rectangles overlap if the area of their intersection is positive.  To be clear, two rectangles that only touch at the corner or edges do not overlap.</p><p>Given two rectangles, return whether they overlap.<br><a id="more"></a></p><blockquote><p>Example 1:<br>Input: rec1 = [0,0,2,2], rec2 = [1,1,3,3]<br>Output: true</p></blockquote><blockquote><p>Example 2:<br>Input: rec1 = [0,0,1,1], rec2 = [1,0,2,1]<br>Output: false</p></blockquote><p><strong>Notes:</strong><br>    1.Both rectangles rec1 and rec2 are lists of 4 integers.<br>    2.All coordinates in rectangles will be between -10^9 and 10^9.</p><p><b>分析：</b><br>常见的矩阵题型，由左下和右上两个点确定一个矩形，判断两个矩形是否有重叠部分，这和之前有一道题非常的相似，那道题是直接求重叠面积</p><p><b>思路：</b><br>记住下面这个固定公式，很有用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isRectangleOverlap</span><span class="params">(rec1, rec2)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type rec1: List[int]</span></span><br><span class="line"><span class="string">    :type rec2: List[int]</span></span><br><span class="line"><span class="string">    :rtype: bool</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    a,b,c,d = rec1</span><br><span class="line">    e,f,g,h = rec2</span><br><span class="line">    <span class="keyword">return</span> max(<span class="number">0</span>,min(c,g)-max(e,a)) * max(<span class="number">0</span>,min(d,h)-max(f,b)) != <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">43</span> / <span class="number">43</span> test cases passed.</span><br><span class="line">difficulty: easy</span><br><span class="line">Runtime: <span class="number">31</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 837 New 21 Game</title>
      <link href="/2018/05/22/Leetcode-837-New-21-Game/"/>
      <url>/2018/05/22/Leetcode-837-New-21-Game/</url>
      <content type="html"><![CDATA[<p>Alice plays the following game, loosely based on the card game “21”.</p><p>Alice starts with 0 points, and draws numbers while she has less than K points.  During each draw, she gains an integer number of points randomly from the range [1, W], where W is an integer.  Each draw is independent and the outcomes have equal probabilities.</p><p>Alice stops drawing numbers when she gets K or more points.  What is the probability that she has N or less points?</p><blockquote><p>Example 1:<br>Input: N = 10, K = 1, W = 10<br>Output: 1.00000<br>Explanation:  Alice gets a single card, then stops.</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: N = 6, K = 1, W = 10<br>Output: 0.60000<br>Explanation:  Alice gets a single card, then stops.<br>In 6 out of W = 10 possibilities, she is at or below N = 6 points.</p></blockquote><blockquote><p>Example 3:<br>Input: N = 21, K = 17, W = 10<br>Output: 0.73278</p></blockquote><p><strong>Note:</strong><br>    1.0 &lt;= K &lt;= N &lt;= 10000<br>    2.1 &lt;= W &lt;= 10000<br>    3.Answers will be accepted as correct if they are within 10^-5 of the correct answer.<br>    4.The judging time limit has been reduced for this question.</p><p><b>分析：</b><br>这道题是在求概率，在已有点数不超过K的情况下从1至w中选数，之后和不超过N,注意K,N,W可以取到10000,所以N^2是肯定不行的，并且递归也会超出最大深度(即使使用记忆化也不行)。</p><p><b>思路：</b><br>使用动态规划，dp[i]表示点数和为i的概率，那么最后结果应该是dp[k]+dp[k+1]+…+dp[n]<br>其中，dp[i]又应该为前w个的dp的平均值<br>例如W=10，那么dp[20] = 1/10 * (dp[10]+dp[11]+…+dp[19])</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new21Game</span><span class="params">(N, K, W)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> K == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    dp = [<span class="number">1.0</span>] + [<span class="number">0.0</span>] * N</span><br><span class="line">    <span class="comment"># 用Wsum 记录前w个dp之和</span></span><br><span class="line">    Wsum = <span class="number">1.0000</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N + <span class="number">1</span>):</span><br><span class="line">        dp[i] = Wsum / W</span><br><span class="line">        <span class="keyword">if</span> i &lt; K: Wsum += dp[i]</span><br><span class="line">        <span class="comment"># 假设K = 15，那么上面的例子d[20] = 1/10 * (dp[10]+...+dp[14]),因为拿到15之后就不能拿了，所以不存在从15拿5拿到20的情况</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= i - W &lt; K: Wsum -= dp[i - W]</span><br><span class="line">    <span class="keyword">return</span> sum(dp[K:])</span><br><span class="line"></span><br><span class="line"><span class="number">146</span> / <span class="number">146</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">122</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 459 Repeated Substring Pattern</title>
      <link href="/2018/05/19/Leetcode-459-Repeated-Substring-Pattern/"/>
      <url>/2018/05/19/Leetcode-459-Repeated-Substring-Pattern/</url>
      <content type="html"><![CDATA[<p>Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.</p><blockquote><p>Example 1:<br>Input: “abab”<br>Output: True<br>Explanation: It’s the substring “ab” twice.&gt;</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: “aba”<br>Output: False&gt;</p></blockquote><blockquote><p>Example 3:<br>Input: “abcabcabcabc”<br>Output: True<br>Explanation: It’s the substring “abc” four times. (And the substring “abcabc” twice.)</p></blockquote><p><b>分析：</b><br>这道题是判断一个字符串是不是某个字符串重复若干次的问题</p><p><b>思路：</b><br>写在这里就是想秀一下我的一行代码，嗨呀，是真滴骚！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repeatSubstringPattern</span><span class="params">(s)</span>:</span></span><br><span class="line"><span class="keyword">return</span> any(s[:i]*(len(s)//i)==s <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(s)) <span class="keyword">if</span> s[i] == s[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="number">107</span> / <span class="number">107</span> test cases passed.</span><br><span class="line">difficulty: easy</span><br><span class="line">Runtime: <span class="number">330</span> ms</span><br></pre></td></tr></table></figure><p>感叹：我还是急了，这道题要是仔细想一下肯定不会这样的,这个解法还是有点东西的，用反证法很容易证<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repeatSubstringPattern</span><span class="params">(s)</span>:</span></span><br><span class="line"><span class="keyword">return</span> s <span class="keyword">in</span> (s+s)[<span class="number">1</span>:<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 821 Shortest Distance to a Character</title>
      <link href="/2018/05/11/Leetcode-821-Shortest-Distance-to-a-Character/"/>
      <url>/2018/05/11/Leetcode-821-Shortest-Distance-to-a-Character/</url>
      <content type="html"><![CDATA[<p>Given a string S and a character C, return an array of integers representing the shortest distance from the character C in the string.</p><blockquote><p><strong>Example 1:</strong><br>Input: S = “loveleetcode”, C = ‘e’<br>Output: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]</p></blockquote><a id="more"></a><p><strong>Note:</strong><br>    S string length is in [1, 10000].<br>    C is a single character, and guaranteed to be in string S.<br>    All letters in S and C are lowercase.</p><p><b>分析：</b><br>找S中所有元素距离给定C的最小距离，注意数据长度10000，说明n^2不行</p><p><b>思路：</b><br>先将S中所有的C的位置找出来，然后以这些位置两两为一段，对这一段中的元素判断离那边端点更近就OK，-1处和len(s)处默认有一个，这两个边界问题注意处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestToChar</span><span class="params">(S, C)</span>:</span></span><br><span class="line">    res = [<span class="number">-1</span>] * len(S)</span><br><span class="line">    <span class="comment"># 找到所有的C的位置</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(S)):</span><br><span class="line">        <span class="keyword">if</span> S[i] == C: res[i] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 左边界定为-1</span></span><br><span class="line">    i = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(S):</span><br><span class="line">        j = i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; len(S) <span class="keyword">and</span> res[j] != <span class="number">0</span>: j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> xrange(i+<span class="number">1</span>,j):</span><br><span class="line">        <span class="comment"># 如果在左边界</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">-1</span>:</span><br><span class="line">                res[k] = j-k</span><br><span class="line">            <span class="comment"># 如果到达右边界</span></span><br><span class="line">            <span class="keyword">elif</span> j == len(S):</span><br><span class="line">                res[k] = k-i</span><br><span class="line">            <span class="comment"># 在中间</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[k] = min(j-k,k-i)</span><br><span class="line">        i = j</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 822 Card Flipping Game</title>
      <link href="/2018/05/11/Leetcode-822-Card-Flipping-Game/"/>
      <url>/2018/05/11/Leetcode-822-Card-Flipping-Game/</url>
      <content type="html"><![CDATA[<p>On a table are N cards, with a positive integer printed on the front and back of each card (possibly different).</p><p>We flip any number of cards, and after we choose one card. </p><p>If the number X on the back of the chosen card is not on the front of any card, then this number X is good.</p><p>What is the smallest number that is good?  If no number is good, output 0.<br><a id="more"></a><br>Here, fronts[i] and backs[i] represent the number on the front and back of card i. </p><p>A flip swaps the front and back numbers, so the value on the front is now on the back and vice versa.</p><p><strong>Example:</strong><br>Input: fronts = [1,2,4,4,7], backs = [1,3,4,1,3]<br>Output: 2<br>Explanation: If we flip the second card, the fronts are [1,3,4,4,7] and the backs are [1,2,4,1,3].<br>We choose the second card, which has number 2 on the back, and it isn’t on the front of any card, so 2 is good.</p><p><strong>Note:</strong><br>    1 &lt;= fronts.length == backs.length &lt;= 1000.<br>    1 &lt;= fronts[i] &lt;= 2000.<br>    1 &lt;= backs[i] &lt;= 2000.</p><p><b>分析：</b><br>如果我们从fronts和backs中最小的数开始考虑，在example中就是1,那么1对应着两张卡，分别是 1，1 和 1，4，对于1，1我们无论如何翻转1都会在正面出现，所以1不可能是good number；对于2来说，2对应着2，3一张卡，那么只要将3朝上，fronts中就没了2,(关键就是只要一个数不是同时出现在一张卡的正反两面，我们通过一定的翻转就一定可以使这个数成为good number)，因为我们是从小到大遍历，所以此时2就是最后答案。注意数据长度不超过1000，数据值不超过2000，说明n^2的方案是可行的</p><p><b>思路：</b><br>我们将fronts和backs里面出现的数对应的另一面的数字记录下来，比如对于1这个数字，记录他对应着1，4着两个数，然后从小到大遍历，第一个没出现相同对应数字的数就是答案</p><p><b>总结：</b><br>这道题稍微想一下并不难，但是在leetcode上踩的人有丶多，说明大家对单纯的逻辑题的解法还是不太熟。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flipgame</span><span class="params">(fronts, backs)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> collections</span><br><span class="line">    n = len(fronts)</span><br><span class="line">    d = collections.defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">        d[fronts[i]].append(backs[i])</span><br><span class="line">        d[backs[i]].append(fronts[i])</span><br><span class="line"></span><br><span class="line">    rec = fronts + backs</span><br><span class="line">    rec.sort()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> rec:</span><br><span class="line">        <span class="keyword">if</span> e <span class="keyword">not</span> <span class="keyword">in</span> d[e]:</span><br><span class="line">            <span class="keyword">return</span> e</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">time: O(n)</span><br><span class="line">space: O(n)</span><br><span class="line">difficulty: medium</span><br><span class="line"><span class="number">169</span> / <span class="number">169</span> test cases passed</span><br><span class="line">runtime: <span class="number">85</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 823 Binary Trees With Factors</title>
      <link href="/2018/05/11/Leetcode-823-Binary-Trees-With-Factors/"/>
      <url>/2018/05/11/Leetcode-823-Binary-Trees-With-Factors/</url>
      <content type="html"><![CDATA[<p>Given an array of unique integers, each integer is strictly greater than 1.</p><p>We make a binary tree using these integers and each number may be used for any number of times.</p><p>Each non-leaf node’s value should be equal to the product of the values of it’s children.</p><p>How many binary trees can we make?  Return the answer modulo 10 ** 9 + 7.<br><a id="more"></a><br><strong>Example 1:</strong><br>Input: A = [2, 4]<br>Output: 3<br>Explanation: We can make these trees: [2], [4], [4, 2, 2]</p><p><strong>Example 2:</strong><br>Input: A = [2, 4, 5, 10]<br>Output: 7<br>Explanation: We can make these trees: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].</p><p><strong>Note:</strong><br>    1 &lt;= A.length &lt;= 1000.<br>    2 &lt;= A[i] &lt;= 10 ^ 9.</p><p><b>分析：</b><br>构建一个所有父节点的值等于其子节点的值的乘积的树，问有多少种构建方法，注意数据长度小于1000，说明n^2复杂度是可行的</p><p><b>思路：</b><br>比如[2,5,10,20],对于20由2和10组成，10又可以由2和5组成，所以组成20的方法应该是组成2的方法数乘以组成10的方法数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numFactoredBinaryTrees</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> collections</span><br><span class="line">    A.sort()</span><br><span class="line">    d = collections.Counter(A)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(A)):</span><br><span class="line">    <span class="comment">#从比他小的数里遍历，找到因子然后进行判断！</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i):</span><br><span class="line">            <span class="keyword">if</span> A[i] % A[j] == <span class="number">0</span> <span class="keyword">and</span> A[i]/A[j] <span class="keyword">in</span> d:</span><br><span class="line">                d[A[i]] += d[A[j]] * d[A[i]/A[j]]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum(d.values()) % (<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dp </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 824 Goat Latin</title>
      <link href="/2018/05/11/Leetcode-824-Goat-Latin/"/>
      <url>/2018/05/11/Leetcode-824-Goat-Latin/</url>
      <content type="html"><![CDATA[<p><img src="/images/leetcode_824_1.png" alt="图1"></p><p><img src="/images/leetcode_824_2.png" alt="图2"><br><a id="more"></a><br><b>分析：</b><br>这道题是真的弱智</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">toGoatLatin</span><span class="params">(S)</span>:</span></span><br><span class="line">    res = S.split()</span><br><span class="line">    <span class="keyword">for</span> i,s <span class="keyword">in</span> enumerate(res):</span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] <span class="keyword">in</span> <span class="string">'aeiouAEIOU'</span>:</span><br><span class="line">            res[i] = s + <span class="string">'ma'</span> + <span class="string">'a'</span>*(i+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res[i] = s[<span class="number">1</span>:]+s[<span class="number">0</span>] + <span class="string">'ma'</span> + <span class="string">'a'</span>*(i+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">' '</span>.join(res)</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode_825_Friends_Of_Appropriate_Ages</title>
      <link href="/2018/05/11/Leetcode-825-Friends-Of-Appropriate-Ages/"/>
      <url>/2018/05/11/Leetcode-825-Friends-Of-Appropriate-Ages/</url>
      <content type="html"><![CDATA[<p>Some people will make friend requests. The list of their ages is given and ages[i] is the age of the ith person. </p><p>Person A will NOT friend request person B (B != A) if any of the following conditions are true:</p><p>1.age[B] &lt;= 0.5 * age[A] + 7<br>2.age[B] &gt; age[A]<br>3.age[B] &gt; 100 &amp;&amp; age[A] &lt; 100<br>Otherwise, A will friend request B.</p><p>Note that if A requests B, B does not necessarily request A.  Also, people will not friend request themselves.</p><p>How many total friend requests are made?<br><a id="more"></a><br><strong>Example 1:</strong><br>Input: [16,16]<br>Output: 2<br>Explanation: 2 people friend request each other.</p><p><strong>Example 2:</strong><br>Input: [16,17,18]<br>Output: 2<br>Explanation: Friend requests are made 17 -&gt; 16, 18 -&gt; 17.</p><p><strong>Example 3:</strong><br>Input: [20,30,100,110,120]<br>Output: 3<br>Explanation: Friend requests are made 110 -&gt; 100, 120 -&gt; 110, 120 -&gt; 100.</p><p><strong>Notes:</strong><br>    1 &lt;= ages.length &lt;= 20000.<br>    1 &lt;= ages[i] &lt;= 120.</p><p><b>分析：</b><br>对于A这个人交朋友来说，根据条件2比他年级大的一概排除，比他年级小的要满足条件1，条件3没用，不知道这个出题的人在想什么，注意数据长度达到20000，所以复杂度n^2是不行的</p><p><b>思路：</b><br>首先将ages数组从大到小排序，然后用两个指针遍历即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numFriendRequests</span><span class="params">(ages)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(ages) == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    ages.sort(reverse=<span class="keyword">True</span>)</span><br><span class="line">    i,j = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(ages):</span><br><span class="line">        <span class="keyword">while</span> j &lt; len(ages) <span class="keyword">and</span> ages[j] &gt; <span class="number">0.5</span>*ages[i] + <span class="number">7</span>:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果对于age[0]来说,age[1,2,3,4,5]他都可以交朋友</span></span><br><span class="line">        <span class="comment"># 那么对于age[1]来说,age[2,3,4,5]也是必可以的，所以只用遍历一遍就可以了</span></span><br><span class="line">        res += j - i - <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; len(ages) <span class="keyword">and</span> ages[i] &gt; <span class="number">14</span>:</span><br><span class="line">            <span class="keyword">if</span> ages[i] == ages[i<span class="number">-1</span>]: res += cnt + <span class="number">1</span>;cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= j: j = i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="string">"difficulty: medium</span></span><br><span class="line"><span class="string">83 / 83 test cases passed</span></span><br><span class="line"><span class="string">runtime: 305 ms"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode_826_Most_Profit_Assigning_Work</title>
      <link href="/2018/05/11/Leetcode-826-Most-Profit-Assigning-Work/"/>
      <url>/2018/05/11/Leetcode-826-Most-Profit-Assigning-Work/</url>
      <content type="html"><![CDATA[<p>We have jobs: difficulty[i] is the difficulty of the ith job, and profit[i] is the profit of the ith job. </p><p>Now we have some workers. worker[i] is the ability of the ith worker, which means that this worker can only complete a job with difficulty at most worker[i]. </p><p>Every worker can be assigned at most one job, but one job can be completed multiple times.</p><p>For example, if 3 people attempt the same job that pays $1, then the total profit will be $3.  If a worker cannot complete any job, his profit is $0.</p><p>What is the most profit we can make?<br><a id="more"></a></p><blockquote><p><strong>Example 1:</strong><br>Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]<br>Output: 100<br>Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get profit of [20,20,30,30] seperately.</p></blockquote><p><strong>Notes:</strong><br>    1 &lt;= difficulty.length = profit.length &lt;= 10000<br>    1 &lt;= worker.length &lt;= 10000<br>    difficulty[i], profit[i], worker[i]  are in range [1, 10^5]</p><p><b>分析：</b><br>每个人有一个能力值，只能做难度低于自身能力值的工作，每个工作有报酬，设计一个方法让报酬最大，注意数据长度为10000，数据值不超过100000，这说明复杂度n^2是不行的</p><p><b>思路：</b><br>用动态规划思想，dp[i]表示能力值为i的工人最多能拿多少报酬，i最多不超过100000，所以空间不会超出，那么结果就是sum(dp[i] for i in worker)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfitAssignment</span><span class="params">(difficulty, profit, worker)</span>:</span></span><br><span class="line">    d = collections.defaultdict(int)</span><br><span class="line">    key = set(difficulty)</span><br><span class="line">    dp = [<span class="number">0</span>] * (max(worker)+<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 可能存在相同困难度的工作有不同的报酬，这里只将最高的报酬记录</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(difficulty)):</span><br><span class="line">        d[difficulty[i]] = max(d[difficulty[i]], profit[i])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(dp)):</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> key:</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-1</span>],d[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(worker)):</span><br><span class="line">        res += dp[worker[i]]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="string">"difficulty: medium</span></span><br><span class="line"><span class="string">57 / 57 test cases passed</span></span><br><span class="line"><span class="string">runtime: 559 ms"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode_827_Making_A_Large_Island</title>
      <link href="/2018/05/11/Leetcode-827-Making-A-Large-Island/"/>
      <url>/2018/05/11/Leetcode-827-Making-A-Large-Island/</url>
      <content type="html"><![CDATA[<p>In a 2D grid of 0s and 1s, we change at most one 0 to a 1.</p><p>After, what is the size of the largest island? (An island is a 4-directionally connected group of 1s).</p><blockquote><p>Example 1:<br>Input: [[1, 0], [0, 1]]<br>Output: 3<br>Explanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3.</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: [[1, 1], [1, 0]]<br>Output: 4<br>Explanation: Change the 0 to 1 and make the island bigger, only one island with area = 1.</p></blockquote><blockquote><p>Example 3:<br>Input: [[1,1],[1,1]]<br>Output: 4<br>Explanation: 4</p></blockquote><p>Notes:<br>    1 &lt;= grid.length = grid[0].length &lt;= 50.<br>    0 &lt;= grid[i][j] &lt;= 1.</p><p><b>分析：</b><br>这道题意思就是把连续的1认为是一块地,现在可以将某个0改成1，使连续的1最多，并求出对应的数量。<br>先看一下变量的取值，长宽都是50，则最多2500个元素，这告诉我们n^2复杂度是可以的</p><p><b>思路：</b><br>我们给每块地进行编号，然后记录下这块地的大小，最后找0的时候将0周边不同地的面积相加最大的就是结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largestIsland</span><span class="params">(grid)</span>:</span></span><br><span class="line">    directions = ((<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">-1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">-1</span>))</span><br><span class="line">    area = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">    index = <span class="number">2</span> <span class="comment"># grid中包含0，1，所以地的编号从2开始必不会重复</span></span><br><span class="line">    n = len(grid)</span><br><span class="line">    <span class="comment"># 用dfs计算一块地的面积，并修改grid</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i,j,index)</span>:</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        grid[i][j] = index</span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> directions:</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>&lt;=i+x&lt;n <span class="keyword">and</span> <span class="number">0</span>&lt;=j+y&lt;n:</span><br><span class="line">                <span class="keyword">if</span> grid[i+x][j+y] == <span class="number">1</span>:</span><br><span class="line">                    res += dfs(i+x,j+y,index)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用area数组记录对应地的面积</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                area.append(dfs(i,j,index))</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="number">0</span>:</span><br><span class="line">                s = set()</span><br><span class="line">                <span class="keyword">for</span> x,y <span class="keyword">in</span> directions:</span><br><span class="line">                    <span class="keyword">if</span> <span class="number">0</span>&lt;=i+x&lt;n <span class="keyword">and</span> <span class="number">0</span>&lt;=j+y&lt;n <span class="keyword">and</span> grid[i+x][j+y]&gt;<span class="number">1</span>:</span><br><span class="line">                        s.add(grid[i+x][j+y])</span><br><span class="line">                res = max(res,sum(area[i] <span class="keyword">for</span> i <span class="keyword">in</span> s)+<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 如果grid中全为1，上一个循环中的判断就进不去，res就为0，此时结果应该为grid的面积</span></span><br><span class="line">    <span class="keyword">return</span> res <span class="keyword">or</span> n**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="string">"difficulty:hard</span></span><br><span class="line"><span class="string">63/63 test cases passed</span></span><br><span class="line"><span class="string">runtime: 127ms"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 829 Consecutive Numbers Sum</title>
      <link href="/2018/05/10/Leetcode-829-Consecutive-Numbers-Sum/"/>
      <url>/2018/05/10/Leetcode-829-Consecutive-Numbers-Sum/</url>
      <content type="html"><![CDATA[<p>Given a positive integer N,how many ways can we write it as a sum of consecutive positive integers?</p><p><strong>Example 1:</strong></p><blockquote><p>Input: 5<br>Output: 2<br>Explanation: 5 = 5 = 2+3</p></blockquote><a id="more"></a><p><strong>Example 2:</strong></p><blockquote><p>Input: 9<br>Output: 3<br>Explanation: 9 = 9 = 4+5 = 2+3+4</p></blockquote><p><strong>Example 3:</strong></p><blockquote><p>Input: 15<br>Output: 4<br>Explanation: 15 = 15 = 7+8 = 4+5+6 = 1+2+3+4+5</p></blockquote><p>Note: 1&lt;=N&lt;=10^9</p><p><b>思路：</b><br>这道题就是问一个数写成若干个连续正整数的和共有多少种形式？那么就非常简单了<br>如果能写成1个连续的整数，那么这个数能表示成a<br>如果能写成2个连续的整数，那么这个数能表示成a+(a+1)=2<em>a+1<br>如果能写成3个连续的整数，那么这个数能表示成a+(a+1)+(a+2)=3</em>a+3<br>如果能写成n个连续的整数，那么这个数能表示成n<em>a+n</em>(n-1)/2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consecutiveNumbersSum</span><span class="params">(N)</span>:</span></span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    n = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        divisor = N - (n<span class="number">-1</span>)*n/<span class="number">2</span></span><br><span class="line">        <span class="comment"># 因为a至少为1，所以一旦小于就可以直接返回结果</span></span><br><span class="line">        <span class="keyword">if</span> divisor &lt; n: <span class="keyword">return</span> res</span><br><span class="line">        res += divisor%n==<span class="number">0</span></span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="string">"difficulty: medium</span></span><br><span class="line"><span class="string">170 / 170 test cases passed.</span></span><br><span class="line"><span class="string">Runtime: 238 ms"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何搭建一个这样的博客？</title>
      <link href="/2018/05/10/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%B6%85%E9%AA%9A%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%9F/"/>
      <url>/2018/05/10/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%B6%85%E9%AA%9A%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>在一次突发奇想觉得该记录一下我做的各种事情后，便开始有了搭建一个博客的想法。</p><p>但是普通的CSDN或者其他的吧，就感觉挺没有逼格的，刚好记得有人说过可以用Github做博客，便疯狂百度如何用github搭建自己的博客，历经各种意外事件最后好歹也算搭建起来了，搭建完确认无误之后第一件事那必是记录下搭建博客的整个过程。(不过刚好赶上报告的deadline，写报告加开会拖了好久)<br><a id="more"></a><br>前言，<strong>我不建议完全不懂代码的人用github搭建博客</strong>，虽说过程不是很复杂，但是对于没接触过代码的人可能看着攻略也弄不好，并且就算搭建成功了之后写博客的时候还要用到Markdown语法，还有点小麻烦。</p><h2 id="github配置"><a href="#github配置" class="headerlink" title="github配置"></a>github配置</h2><p>首先，你需要一个github账号，注册的过程不用我多说了吧！<br>注册完毕之后进入主界面，点击右上角+号里的New repository,要注意的一点是你的repository name必须和Owner下的名字是一致的，否则之后会出现很多问题，如图1所示：</p><p><img src="/images/如何搭建博客_1.png" alt="图1"></p><p>点击创建后切换到settings界面进行设置，如图2所示：</p><p><img src="/images/如何搭建博客_2.png" alt="图二"></p><p>在settings界面，你可以在github pages这一栏中看到你的博客部署的网址，如图三所示，你也可以点击 choose a theme给自己的博客选择一个主题。在最底部的danger zone中可以删除整个repository！！！</p><p><img src="/images/如何搭建博客_3.png" alt="图三"></p><p>OK！你现在已经可以点进去这个网址看一下了，虽然里面什么都没有就是了。不过这便有了基础，任何人都可以通过这个网址来访问你的博客，如果你嫌这个网址很丑，你也可以去购买一个你喜欢的域名，然后可以通过一定的设置绑定那个域名。(必须提一句买域名并不贵，不过我目前博客里还没什么东西，等内容多一点之后我必买一个！等买了之后再补上绑定域名的方法)</p><h2 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h2><p>接下来需要下载两个软件: node.js 和 git，下载链接在下面百度云中。<br>两个软件都是标准的windows软件安装模式，中间配置建议全部默认！<br>安装完成后打开cmd命令行，输入如下命令，出现某个版本号即为安装成功,如图四所示：<br>链接：<a href="https://pan.baidu.com/s/1D5amENHdqaB8Qmk88I2_sw" target="_blank" rel="noopener">https://pan.baidu.com/s/1D5amENHdqaB8Qmk88I2_sw</a><br>密码：s6t9<br><img src="/images/如何搭建博客_4.png" alt="图四"><br>在电脑任何位置单机鼠标右键出现下图所示：<br><img src="/images/如何搭建博客_5.png" alt="图五"></p><hr><p>好，目前前期配置基本结束，可以开始进行搭建博客了。<br>在你的电脑的某个合适位置创建一个文件夹，例如命名为blog，然后通过命令行进入blog文件夹<br><img src="/images/如何搭建博客_6.png" alt="图六"><br><img src="/images/如何搭建博客_7.png" alt="图七"></p><ol><li>输入npm install hexo -g，开始安装hexo，如何提示没有npm命令说明之前的node.js没有安装好（因为我已经装好了所以没法再装一遍提供截图…）</li><li>然后输入 hexo -v 检查hexo是否安装成功<br><img src="/images/如何搭建博客_8.png" alt="图8"></li><li>输入hexo init，这一步需要一点等待时间，成功标志为最后显示start blogging with Hexo</li><li>依次输入npm install, hexo g, hexo s，即可开启本地服务器，开始使用blog<br><img src="/images/如何搭建博客_9.png" alt=""><br><code>这里实在没办法给全部截图，都是最初时期的配置，等你们配好了你们就会理解这里真的很难给...</code></li><li>输入上面图中给出的地址，即可进入博客的本地界面，若界面一直无法跳转，先使用ctrl+c终止，然后输入 hexo server -p 5000，不过一般不会出现这个情况。</li></ol><h2 id="github和本地联动"><a href="#github和本地联动" class="headerlink" title="github和本地联动"></a>github和本地联动</h2><p>OK，上面过程将本地博客配置完成，那么如何将本地博客与github连接起来呢，这时候就要用到之前安装的git，我们先进入之前存放blog文件夹的地方，右键空白处然后点击git bash here<br><img src="/images/如何搭建博客_10.png" alt=""></p><ol><li>输入 git config –global user.name “填你自己的名字”<br><img src="/images/如何搭建博客_11.png" alt=""></li><li>输入git config –global user.email “填你自己的邮箱”<br><img src="/images/如何搭建博客_12.png" alt=""></li><li>输入 cd ~/.ssh，检查是否有.ssh文件夹，没有是最好的，但如果有也没关系（不一定出问题，先按照下面的步骤走）。</li><li>输入 ssh-keygen -t rsa -C “your email”，这里email和上面的保持一致，有三个配置需要你输入，但是建议全部为空就完事了（敲三个回车），最后生成了两个文件，id_rsa和id_rsa.pub，存储路径为：C:/Users/Administrator/.ssh</li><li>输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent<br>进入github网页中，添加ssh，先进入setting，再进入ssh and gpg keys<br><img src="/images/如何搭建博客_13.png" alt=""><br><img src="/images/如何搭建博客_14.png" alt=""><br>新建一个ssh key，起个名字，然后将之前生成的id_rsa.pub文件的内容复制进来（用记事本打开）</li><li>输入ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>，测试ssh是否成功，中间可能出现几个配置选择不过不重要，如果最后看到hi your name，就说明配置成功！<br><code>现在回看第三步，如果出问题了怎么办呢，那得把之前已经存在的ssh文件夹删掉，然后在按照这个过程走一遍</code></li></ol><hr><p>到这里可以说基本配置完成了，最后一步，进入blog文件夹，打开_config.yml文件<code>(这个文件很重要，基本修改配置都是在这，一般称为站点配置文件，而不同的主题的下面也自带有这个文件，一般称为主题配置文件)</code>，在最后补上一些记录，其中repository值是你自己的ssh值，在github中可以查看<br><img src="/images/如何搭建博客_15.png" alt=""><br><img src="/images/如何搭建博客_16.png" alt=""><br>最后在命令行中输入npm install hexo-deployer-git –save<br><img src="/images/如何搭建博客_17.png" alt=""><br>OK，全部搞定，可以开始写博客了，你所有的博客以.md文件形式存储在/source/_posts文件夹下<br>如果你需要新建一篇博客，在命令行中输入 hexo new “blog name”，然后在md文件中编辑即可</p><p>编辑完成后可直接在本地博客中查看效果，输入hexo s,进入本地博客地址观察效果</p><p>输入hexo d -g可真正上传到你的博客地址中，就是最初那个里面什么都没有的xxxx.github.io</p><p>更多操作你都可以在其自带的hello-world.md文件中看到！</p><p>当然你可能会觉得hexo这个界面是真的丑，你可以去自己选比较好看的主题，我是用的next主题，也是比较流行的一种主题。你可以在这个网址上选择不同的主题：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></p><p>这里再推荐一个教程：<a href="https://www.jianshu.com/p/bcdbe7347c8d" target="_blank" rel="noopener">https://www.jianshu.com/p/bcdbe7347c8d</a><br>可以从这个网址里看一看几个比较优秀的主题，然后看是怎么配置的<br>PS: 我超喜欢maupassant这个主题，可惜瑞了，懒得重新配了</p>]]></content>
      
      
        <tags>
            
            <tag> 有趣的东西 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 831 Masking Personal Information</title>
      <link href="/2018/05/07/Leetcode-831-Masking-Personal-Information/"/>
      <url>/2018/05/07/Leetcode-831-Masking-Personal-Information/</url>
      <content type="html"><![CDATA[<p><img src="/images/leetcode_831_1.png" alt="这是题目描述"><br><a id="more"></a><br><img src="/images/leetcode_831_2.png" alt="这是示例"></p><p><b>思路: </b><br>先判断到底是email还是phonenumber，根据情况依次判断<br>email只取@符号前面的字符串的首末两个字符，其余不变(当然要先把所有的变成小写)<br>phone就判断数字有多少个，超过10就多一个+号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maskPII</span><span class="params">(S)</span>:</span></span><br><span class="line"><span class="comment"># 定义一个flag,为1的时候代表是email,为0的时候代表是phonenumber</span></span><br><span class="line"><span class="comment"># 初始化为1，即默认是email，通过开头是否是数字或符号来判断是否改变</span></span><br><span class="line">flag = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> S[<span class="number">0</span>] <span class="keyword">in</span> <span class="string">'()0123456789+-'</span>: flag = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">const_str = <span class="string">'***-***-'</span></span><br><span class="line"><span class="keyword">if</span> flag == <span class="number">0</span>: <span class="comment"># means S is phonenumber</span></span><br><span class="line">cnt = <span class="number">0</span>   <span class="comment"># 记录S中数字的长度</span></span><br><span class="line">rec = <span class="string">''</span>  <span class="comment">#记录S中最后四位数字</span></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> range(len(S)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line"><span class="keyword">if</span> S[e] <span class="keyword">in</span> <span class="string">'1234567890'</span>: </span><br><span class="line">cnt += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> cnt &lt;= <span class="number">4</span>: rec += S[e]</span><br><span class="line"><span class="keyword">if</span> cnt == <span class="number">10</span>: <span class="keyword">return</span> const_str + rec[::<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">else</span>: <span class="keyword">return</span> <span class="string">'+'</span> + <span class="string">'*'</span>*(cnt<span class="number">-10</span>) + <span class="string">'-'</span> + const_str + rec[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> flag == <span class="number">1</span>: <span class="comment"># means S is email address</span></span><br><span class="line">S = S.lower()</span><br><span class="line">l,r = S.split(<span class="string">'@'</span>)</span><br><span class="line"><span class="keyword">return</span> l[<span class="number">0</span>] + <span class="string">'*****'</span> + l[<span class="number">-1</span>] + <span class="string">'@'</span> + r</span><br><span class="line"></span><br><span class="line"><span class="string">"difficulty: midium</span></span><br><span class="line"><span class="string">66 / 66 test cases passed.</span></span><br><span class="line"><span class="string">Runtime: 39 ms"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 830 Positions of Large Groups</title>
      <link href="/2018/05/06/Leetcode-830-Positions-of-Large-Groups/"/>
      <url>/2018/05/06/Leetcode-830-Positions-of-Large-Groups/</url>
      <content type="html"><![CDATA[<p>In a string S of lowercase letters, these letters form consecutive groups of the same character.</p><p>For example, a string like S = “abbxxxxzyy” has the groups “a”, “bb”, “xxxx”, “z” and “yy”.</p><p>Call a group large if it has 3 or more characters.  We would like the starting and ending positions of every large group.</p><p>The final answer should be in lexicographic order.</p><blockquote><p>Example 1:<br>Input: “abbxxxxzzy”<br>Output: [[3,6]]<br>Explanation: “xxxx” is the single large group with starting  3 and ending positions 6.</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: “abc”<br>Output: []<br>Explanation: We have “a”,”b” and “c” but no large group.</p></blockquote><blockquote><p>Example 3:<br>Input: “abcdddeeeeaabbbcd”<br>Output: [[3,5],[6,9],[12,14]]</p></blockquote><p>Note:  1 &lt;= S.length &lt;= 1000</p><p><b>思路：</b><br>一道简单的字符串处理问题。每次判断是否有连续三个以上的字符相同，相同则将下标加入res。注意处理边界问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largeGroupPositions</span><span class="params">(S)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type S: str</span></span><br><span class="line"><span class="string">    :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    i,j = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> i &lt; len(S):</span><br><span class="line">        j = i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; len(S) <span class="keyword">and</span> S[j] == S[i]: j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> j-i &gt;= <span class="number">3</span>: res.append([i,j<span class="number">-1</span>])</span><br><span class="line">        i = j</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="string">"difficulty: easy</span></span><br><span class="line"><span class="string">202 / 202 test cases passed.</span></span><br><span class="line"><span class="string">Runtime: 114 ms"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
