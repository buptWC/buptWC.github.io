<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Leetcode 884 Decoded String an Index</title>
      <link href="/2018/08/05/Leetcode-884-Decoded-String-an-Index/"/>
      <url>/2018/08/05/Leetcode-884-Decoded-String-an-Index/</url>
      <content type="html"><![CDATA[<p>An encoded string S is given.  To find and write the decoded string to a tape, the encoded string is read one character at a time and the following steps are taken:<br>If the character read is a letter, that letter is written onto the tape.<br>If the character read is a digit (say d), the entire current tape is repeatedly written d-1 more times in total.<br>Now for some encoded string S, and an index K, find and return the K-th letter (1 indexed) in the decoded string.</p><blockquote><p>Example 1:<br>Input: S = “leet2code3”, K = 10<br>Output: “o”<br>Explanation:<br>The decoded string is “leetleetcodeleetleetcodeleetleetcode”.<br>The 10th letter in the string is “o”.</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: S = “ha22”, K = 5<br>Output: “h”<br>Explanation:<br>The decoded string is “hahahaha”.  The 5th letter is “h”.<br>Example 3:<br>Input: S = “a2345678999999999999999”, K = 1<br>Output: “a”<br>Explanation:<br>The decoded string is “a” repeated 8301530446056247680 times.  The 1st letter is “a”.</p></blockquote><p>Note:</p><ol><li>2 &lt;= S.length &lt;= 100</li><li>S will only contain lowercase letters and digits 2 through 9.</li><li>S starts with a letter.</li><li>1 &lt;= K &lt;= 10^9</li><li>The decoded string is guaranteed to have less than 2^63 letters.</li></ol><p><strong>分析：</strong></p><ol><li>这道题是把字符串按照给定的规则展开，然后返回展开后的字符串的第K个字符，应该要怎么思考呢？</li><li>我不知道大家注意到note的第5点没有，为什么他在这里突然加这么一点，告诉我们长度小于2^63，其实就是在暗示我们要用到总长度（因为我们不可能真把展开后的字符串写出来）</li><li>然后这里的测试样例也有点迷惑作用，因为他故意不给出最后以字符结尾的例子，就是担心把思路直接暴露出来了，我们来看一个例子</li><li>S = ‘leet2code3problem’，这个字符串展开后总长度为43，’problem’是没有重复的部分，前面’leet2code3’总长度是36，那么假设此时K = 37,38,39…，43，我们可以直接得出答案。那如果K小于37呢，那么问题是不是可以转换成在S=’leet2code3’求第K个字符（多余的部分可以直接不要）</li><li>当以数字结尾时，那么整个字符串就是S[:-1]的若干次重复，例如此时S=’leet2code3’的长度为36，设K=18吧，那么基本字符串的长度应该为36/3=12，那么我们要求的字符应该是第18%12=6个字符，现在问题转换成了S=’leet2code’,K=6,又变成我们第4点中分析的情况了，依次类推即可</li></ol><p><strong>思路：</strong></p><ol><li>分析过程很简单明了，但是代码却不太好写，比较繁杂</li><li>我们先去找S中最后一个数字的位置，然后判断K是不是处于这个数字后面的那串字符串中（关键），若是则直接返回</li><li>若不是则改变S，K的值，注意了我们的总长度不能每次改变一次S重新计算一次，那样太麻烦了(不过我猜应该不会超时，因为s长度不超过100)，而是每次通过减去多余字符串的长度和除以结尾数字来改变！！！</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decodeAtIndex</span><span class="params">(self, S, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 先计算总长度</span></span><br><span class="line">        M = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(S)):</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'1'</span> &lt; S[i] &lt;= <span class="string">'9'</span>: M *= int(S[i])</span><br><span class="line">            <span class="keyword">else</span>: M += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(S,K,M)</span>:</span></span><br><span class="line">            <span class="comment"># 找到最后数字出现的位置</span></span><br><span class="line">            index = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(S)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="string">'1'</span> &lt; S[i] &lt;= <span class="string">'9'</span>: index = i;<span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 若没有数字，说明已经是最简字符串了，直接返回即可</span></span><br><span class="line">            <span class="keyword">if</span> index == <span class="number">-1</span>: <span class="keyword">return</span> S[K<span class="number">-1</span>]</span><br><span class="line">            <span class="comment"># 判断K是不是在数字后面的那串字符串中</span></span><br><span class="line">            <span class="keyword">if</span> M-K &lt; len(S)<span class="number">-1</span>-index: <span class="keyword">return</span> S[K-M<span class="number">-1</span>]</span><br><span class="line">            <span class="comment"># 先减去多余字符串的长度，然后再除以最后数字的大小，然后调整K的大小</span></span><br><span class="line">            M -= len(S)-index<span class="number">-1</span></span><br><span class="line">            M //= int(S[index])</span><br><span class="line">            K %= M</span><br><span class="line">            <span class="comment"># 这里一个小问题，假如K=3，M=3，那么实际应该返回第三个字符但是这里去mod的话会是0，所以要单独处理这种情况</span></span><br><span class="line">            <span class="keyword">if</span> K == <span class="number">0</span>: K = M</span><br><span class="line">            <span class="keyword">return</span> helper(S[:index],K,M)</span><br><span class="line">        <span class="keyword">return</span> helper(S,K,M)</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 885 Boats to Save People</title>
      <link href="/2018/08/05/Leetcode-885-Boats-to-Save-People/"/>
      <url>/2018/08/05/Leetcode-885-Boats-to-Save-People/</url>
      <content type="html"><![CDATA[<p>The i-th person has weight people[i], and each boat can carry a maximum weight of limit.<br>Each boat carries at most 2 people at the same time, provided the sum of the weight of those people is at most limit.<br>Return the minimum number of boats to carry every given person.  (It is guaranteed each person can be carried by a boat.)</p><blockquote><p>Example 1:<br>Input: people = [1,2], limit = 3<br>Output: 1<br>Explanation: 1 boat (1, 2)</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: people = [3,2,2,1], limit = 3<br>Output: 3<br>Explanation: 3 boats (1, 2), (2) and (3)<br>Example 3:<br>Input: people = [3,5,3,4], limit = 5<br>Output: 4<br>Explanation: 4 boats (3), (3), (4), (5)</p></blockquote><p>Note:</p><ol><li>1 &lt;= people.length &lt;= 50000</li><li>1 &lt;= people[i] &lt;= limit &lt;= 30000</li></ol><p><strong>分析：</strong></p><ol><li>我感觉这道题该归为easy才对，每条船最多只能装两个人，那么只要能装两个人我就装</li><li>从重量最大的人开始分析，能不能和重量最小的人一起呢？能就一起不能就拉倒！为什么在这里贪心不会出错呢？</li><li>因为之后分析的人的重量都比这个人要小，也就不存在某个人不能和现在这个人一起反而能和比这个人轻的人一起的情况。</li></ol><p><strong>思路：</strong></p><ol><li>用一个双向队列，分别把最重最轻的人依次出队</li><li>如果目前最重的人和最轻的人加一起比Limit要小，就都pop出来，否则就只pop最重的人</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numRescueBoats</span><span class="params">(self, people, limit)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type people: List[int]</span></span><br><span class="line"><span class="string">        :type limit: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        people.sort()</span><br><span class="line">        Q = collections.deque(people)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> Q:</span><br><span class="line">            w = Q.pop()</span><br><span class="line">            <span class="keyword">if</span> Q <span class="keyword">and</span> Q[<span class="number">0</span>] &lt;= limit - w:</span><br><span class="line">                Q.popleft()</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 887 Projection Area of 3D Shapes</title>
      <link href="/2018/08/05/Leetcode-887-Projection-Area-of-3D-Shapes/"/>
      <url>/2018/08/05/Leetcode-887-Projection-Area-of-3D-Shapes/</url>
      <content type="html"><![CDATA[<p>On a N * N grid, we place some 1 * 1 * 1 cubes that are axis-aligned with the x, y, and z axes.</p><p>Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j).</p><p>Now we view the projection of these cubes onto the xy, yz, and zx planes.</p><p>A projection is like a shadow, that maps our 3 dimensional figure to a 2 dimensional plane. </p><p>Here, we are viewing the “shadow” when looking at the cubes from the top, the front, and the side.</p><p>Return the total area of all three projections.</p><a id="more"></a><p><img src="/images/leetcode_887.png" alt=""><br>Note:</p><ol><li>1 &lt;= grid.length = grid[0].length &lt;= 50</li><li>0 &lt;= grid[i][j] &lt;= 50</li></ol><p><strong>分析：</strong></p><ol><li>这道题就是高中所学的正视图、侧视图、俯视图</li><li>对于正视图，也就是从x轴方向看，我们看到的就是沿y轴方向的一系列最高的柱子</li><li>对于侧视图，也就是从y轴方向看，我们看到的就是沿x轴方向的一系列最高的柱子</li><li>对于俯视图，所有的柱子都是1，因为底面积是1</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">projectionArea</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid <span class="keyword">or</span> <span class="keyword">not</span> grid[<span class="number">0</span>]: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        m,n = len(grid),len(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 俯视图的所有柱子，包括了0，等下需要减去</span></span><br><span class="line">        res += m*n</span><br><span class="line">        <span class="comment"># 侧视图的最高</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> grid: </span><br><span class="line">            res += max(row)</span><br><span class="line">            <span class="comment"># 减去俯视图里多计算的0的数量</span></span><br><span class="line">            res -= row.count(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 正视图的最高</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> zip(*grid): </span><br><span class="line">            res += max(row)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 877 Stone Game</title>
      <link href="/2018/07/29/Leetcode-877-Stone-Game/"/>
      <url>/2018/07/29/Leetcode-877-Stone-Game/</url>
      <content type="html"><![CDATA[<p>Alex and Lee play a game with piles of stones.  There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].<br>The objective of the game is to end with the most stones.  The total number of stones is odd, so there are no ties.<br>Alex and Lee take turns, with Alex starting first.  Each turn, a player takes the entire pile of stones from either the beginning or the end of the row.  This continues until there are no more piles left, at which point the person with the most stones wins.<br>Assuming Alex and Lee play optimally, return True if and only if Alex wins the game.</p><blockquote><p>Example 1:<br>Input: [5,3,4,5]<br>Output: true<br>Explanation:<br>Alex starts first, and can only take the first 5 or the last 5.<br>Say he takes the first 5, so that the row becomes [3, 4, 5].<br>If Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points.<br>If Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points.<br>This demonstrated that taking the first 5 was a winning move for Alex, so we return true.</p></blockquote><a id="more"></a><p>Note:</p><ol><li>2 &lt;= piles.length &lt;= 500</li><li>piles.length is even.</li><li>1 &lt;= piles[i] &lt;= 500</li><li>sum(piles) is odd.</li></ol><p>和leetcode 486题一样，只是更简单了<br><strong>分析：</strong></p><ol><li>不妨认为Alex第一次拿的piles[0]，那么剩下的是piles[1:]</li><li>Lee拿piles[1]还是piles[-1]不取决于这两个数哪个大，而是拿了某个数之后使得剩下的数中Alex能获得的总数小</li><li>若定义firstscore(piles)表示在当前piles数组中，先拿的人最后能获得的总分数，则alex的分数应该是<code>max(piles[0]+min(firstscore(piles[1:-1]),firstscore(piles[2:])), piles[-1] + min(firstscore(piles[1:-1]), firstscore(piles[:-2])))</code></li></ol><p><strong>思路：</strong></p><ol><li>因为涉及到大量重复计算，所以需要采用记忆化的思想，用一个cache存已经计算过的值</li><li>但如果用piles作为key值，所花的时间和空间都太大了，所以改成用下标替代的方法</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stoneGame</span><span class="params">(piles)</span>:</span></span><br><span class="line">cache = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">firstscore</span><span class="params">(i,j)</span>:</span></span><br><span class="line"><span class="keyword">if</span> i&gt;=j: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> j==i+<span class="number">1</span> <span class="keyword">and</span> j &lt; len(piles): <span class="keyword">return</span> piles[i]</span><br><span class="line"><span class="keyword">if</span> (i,j) <span class="keyword">in</span> cache: <span class="keyword">return</span> cache[i,j]</span><br><span class="line">res = max(piles[i]+min(firstscore(i+<span class="number">2</span>,j), firstscore(i+<span class="number">1</span>,j<span class="number">-1</span>)) , piles[j<span class="number">-1</span>] + min(firstscore(i+<span class="number">1</span>,j<span class="number">-1</span>), firstscore(i,j<span class="number">-2</span>)))</span><br><span class="line">cache[i,j] = res</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">Alex = firstscore(<span class="number">0</span>,len(piles))</span><br><span class="line">Lee = sum(piles) - Alex</span><br><span class="line"><span class="keyword">return</span> Alex &gt; Lee</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 878 Nth Magical Number</title>
      <link href="/2018/07/29/Leetcode-878-Nth-Magical-Number/"/>
      <url>/2018/07/29/Leetcode-878-Nth-Magical-Number/</url>
      <content type="html"><![CDATA[<p>A positive integer is magical if it is divisible by either A or B.<br>Return the N-th magical number.  Since the answer may be very large, return it modulo 10^9 + 7.</p><blockquote><p>Example 1:<br>Input: N = 1, A = 2, B = 3<br>Output: 2</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: N = 4, A = 2, B = 3<br>Output: 6</p></blockquote><blockquote><p>Example 3:<br>Input: N = 5, A = 2, B = 4<br>Output: 10</p></blockquote><blockquote><p>Example 4:<br>Input: N = 3, A = 6, B = 4<br>Output: 8</p></blockquote><p>Note:</p><ol><li>1 &lt;= N &lt;= 10^9</li><li>2 &lt;= A &lt;= 40000</li><li>2 &lt;= B &lt;= 40000<br>2，3，4，6，8，9，10，12，14，15，16<br><strong>分析:</strong></li><li>在极大的范围内找到一个数,使其满足某种条件，显然是二分法</li><li>对于找到的某个数K，要判断其是不是正好是满足条件的第N个数，也就是判断是不是刚好有N-1个满足条件的数比他小。</li><li>举个例子，N，A，B = 11，2，3<ol><li>我们用二分搜索搜到了16，那么比16小的2的倍数的数有2，4，6，8，10，12，14，共7个</li><li>比16小的3的倍数的数有3，6，9，12，15共5个</li><li>其中6，12重复了，故应减去这两个数，而这也正好是A,B最小公倍数即6的倍数</li><li>故比16小且满足条件的数共有7+5-2=10，说明16正好是第11个数</li></ol></li></ol><p>思路：</p><ol><li>先找到A,B的最小公倍数</li><li>二分计算结果</li><li>mod 1e9+7</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthMagicalNumber</span><span class="params">(self, N, A, B)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :type A: int</span></span><br><span class="line"><span class="string">        :type B: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        mod = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        A,B = min(A,B),max(A,B)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">gcd</span><span class="params">(a,b)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> b: <span class="keyword">return</span> a</span><br><span class="line">            <span class="keyword">return</span> gcd(b,a%b)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">lcm</span><span class="params">(a,b)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> a*b == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> int(a*b/gcd(a,b))</span><br><span class="line">        C = lcm(A,B)</span><br><span class="line">        </span><br><span class="line">        lo = <span class="number">1</span></span><br><span class="line">        hi = <span class="number">10</span>**<span class="number">14</span></span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mid = (lo+hi) / <span class="number">2</span></span><br><span class="line">            num1 = int(math.ceil(mid/float(A))) - <span class="number">1</span></span><br><span class="line">            num2 = int(math.ceil(mid/float(B))) - <span class="number">1</span></span><br><span class="line">            num3 = int(math.ceil(mid/float(C))) - <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> num1+num2-num3 == N<span class="number">-1</span>  <span class="keyword">and</span> (mid % A == <span class="number">0</span> <span class="keyword">or</span> mid % B == <span class="number">0</span>): <span class="keyword">return</span> mid % mod</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">elif</span> num1+num2-num3 &gt; N<span class="number">-1</span>:</span><br><span class="line">                hi = mid</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lo = mid+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">66</span> / <span class="number">66</span> test cases passed.</span><br><span class="line">difficulty: hard</span><br><span class="line">Runtime: <span class="number">24</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> math， Binary search </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>bfs系列详解</title>
      <link href="/2018/07/24/bfs%E7%B3%BB%E5%88%97%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/07/24/bfs%E7%B3%BB%E5%88%97%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1 id="BFS算法基本套路"><a href="#BFS算法基本套路" class="headerlink" title="BFS算法基本套路"></a>BFS算法基本套路</h1><p>本文默认读者是有一定算法基础的，对于基本的语法和bfs概念都了解，本文由浅入深(也不是很深咯)，让你知道碰到bfs系列题目应该去怎么想，代码应该怎么去写，OK，直接进入正题。</p><a id="more"></a><h2 id="基本bfs算法"><a href="#基本bfs算法" class="headerlink" title="基本bfs算法"></a>基本bfs算法</h2><p>这一部分是<code>重中之重</code>，因为在这里给出最基本bfs算法的写法，之后底下大部分的题，只是在这个基础上加一点东西罢了，所以这里的代码得牢记。<br>本文默认所有二叉树的定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br></pre></td></tr></table></figure></p><p>那么最基本的，用bfs算法去遍历一颗二叉树(bfs算法基本格式，很好记)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">    Q = collections.deque([root])</span><br><span class="line">    <span class="keyword">while</span> Q:</span><br><span class="line">        node = Q.popleft()</span><br><span class="line">        <span class="keyword">if</span> node.left: Q.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right: Q.append(node.right)</span><br></pre></td></tr></table></figure></p><p>以小见大，我们就从最基本的bfs算法中总结一下bfs算法的流程。</p><ol><li>初始化队列，将起始点保存</li><li>节点依次出队列，并将出队列的节点的所有相邻节点加入队列</li><li>直至找到所求或队列遍历结束</li></ol><p>bfs不仅用在树中，在二维数组（也可看成是一个图）中，也是经常使用的，正好利用上面总结的流程来看bfs算法在数组中怎么写<br>不妨设给定数组名为matrix，matrix[i][j]为起始点<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(i,j)</span>:</span></span><br><span class="line">    m,n = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">    visited = set((i,j))</span><br><span class="line">    <span class="comment"># 初始化队列，保存起始点</span></span><br><span class="line">    Q = collections.deque([(i,j)])</span><br><span class="line">    <span class="keyword">while</span> Q:</span><br><span class="line">        i,j = Q.popleft()</span><br><span class="line">        <span class="comment"># visited.add((x,y))</span></span><br><span class="line">        <span class="comment"># 所有相邻节点加入队列</span></span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> [(i+<span class="number">1</span>,j),(i<span class="number">-1</span>,j),(i,j+<span class="number">1</span>),(i,j<span class="number">-1</span>)]:</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>&lt;=x&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=y&lt;n <span class="keyword">and</span> (x,y) <span class="keyword">not</span> <span class="keyword">in</span> visited: <span class="comment"># 未出界and不走回头路</span></span><br><span class="line">                Q.append((x,y))</span><br><span class="line">                <span class="comment"># 注意visited一定要放在这里，不能是放在上面注释的地方，否则产生大量重复计算</span></span><br><span class="line">                visited.add((x,y))</span><br></pre></td></tr></table></figure></p><p><strong>OK，基本套路在心里有个印象，然后来看两个简单例子巩固一下</strong></p><hr><h2 id="leetcode-107-Binary-Tree-Level-Order-Traversal"><a href="#leetcode-107-Binary-Tree-Level-Order-Traversal" class="headerlink" title="leetcode 107 Binary Tree Level Order Traversal"></a>leetcode 107 Binary Tree Level Order Traversal</h2><p>给定一棵树的根节点，按照自下而上的顺序依次输出每层节点<br><img src="/images/bfs_1.png" alt=""><br>显然，这道题应用bfs进行遍历，但是需要一层一层的遍历，如何在遍历过程中知道现在这个节点是该层的最后一个节点呢？<br>这道题就体现了一个思路，每次记录一下当前队列的长度<code>l</code>，然后用一个长度为l的循环来pop node，循环结束时，刚好遍历完一层的节点<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">    Q = collections.deque([root])</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> Q:</span><br><span class="line">        rec = [] <span class="comment"># record all node in the same level</span></span><br><span class="line">        l = len(Q)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</span><br><span class="line">            node = Q.popleft()</span><br><span class="line">            rec.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left: Q.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right: Q.append(node.right)</span><br><span class="line">        <span class="comment"># 循环结束rec正好储存了该层的所有节点</span></span><br><span class="line">        res.append(rec)</span><br><span class="line">    <span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p><hr><h2 id="leetcode-103-Binary-Tree-Zigzag-Level-Order-Traversal"><a href="#leetcode-103-Binary-Tree-Zigzag-Level-Order-Traversal" class="headerlink" title="leetcode 103 Binary Tree Zigzag Level Order Traversal"></a>leetcode 103 Binary Tree Zigzag Level Order Traversal</h2><p>给定一棵树的根节点，按照zigzag顺序输出每层节点，即第一层节点从左至右，第二层节点从右至左，第三层节点从左至右，依次类推。<br><img src="/images/bfs_2.png" alt=""><br>这道题和上道基本一样，无非是在处理某些层时，记录的节点顺序需要反转一下，引入一个level变量判定是否反转即可<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">    Q = collections.deque([root])</span><br><span class="line">    res = []</span><br><span class="line">    level = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> Q:</span><br><span class="line">        rec = [] <span class="comment"># record all node in the same level</span></span><br><span class="line">        l = len(Q)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</span><br><span class="line">            node = Q.popleft()</span><br><span class="line">            rec.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left: Q.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right: Q.append(node.right)</span><br><span class="line">        <span class="comment"># 循环结束rec正好储存了该层的所有节点</span></span><br><span class="line">        <span class="keyword">if</span> level % <span class="number">2</span> != <span class="number">0</span>: res.append(rec)</span><br><span class="line">        <span class="keyword">else</span>: res.append(rec[::<span class="number">-1</span>])</span><br><span class="line">        level += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><hr><p>上面两个跟树相关的bfs相对较为简单，因为对于总结的流程来说，二叉树通常有：</p><ol><li><code>明确的起点，通常是根节点</code></li><li><code>明确的相邻节点且不用考虑重复遍历的情况（因为单向）</code></li></ol><p>但在更多的题目中却不是这样，不论是起始点还是相邻节点，都需要我们自己去分析判断才能得出。再来看下面两个例子，感受下这类题目如何去找流程中的两个关键点。</p><h2 id="leetcode-542-01-Matrix"><a href="#leetcode-542-01-Matrix" class="headerlink" title="leetcode 542 01 Matrix"></a>leetcode 542 01 Matrix</h2><p>给定一个矩阵matrix（只包含0or1，保证至少有一个0），返回一个矩阵res，其中res[i][j]代表距离matrix[i][j]处最近的0的距离。<br><img src="/images/bfs_3.png" alt=""><br>对于这道题，<strong>怎么找bfs的起始点呢</strong>，我们可能最初想到的是对每一个1都进行一次bfs遍历，去寻找与他最近的0的位置，但这样显然会超时，因为当1都聚集在一起的时候会有大量重复计算。<br>换个思路，既然1不行，那0行吗，以单个的0肯定不行，因为这个0找到的最近的1，并不一定是最短的，还得计算别的0然后来比较，所以还是得有大量重复计算和比较。<br>既然起始点找单个不行，我们可以找多个，我们<code>将所有的0作为起始点</code>，去找所有最后res[i][j]=1的点，然后<code>将res=1的点作为起始点</code>，去找所有最后res[i][j]=2的点，以此类推。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(matrix)</span>:</span></span><br><span class="line">    m,n = len(matrix),len(matrix[<span class="number">0</span>])</span><br><span class="line">    Q = collections.deque([])</span><br><span class="line">    visited = set()</span><br><span class="line">    <span class="comment"># 初始化队列，将所有起始点加入</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">                Q.append((i,j))</span><br><span class="line">                visited.add((i,j))</span><br><span class="line">    <span class="comment"># 标准bfs写法，将相邻节点加入队列</span></span><br><span class="line">    <span class="keyword">while</span> Q:</span><br><span class="line">        i,j = Q.popleft()</span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> [(i+<span class="number">1</span>,j),(i<span class="number">-1</span>,j),(i,j+<span class="number">1</span>),(i,j<span class="number">-1</span>)]:</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>&lt;=x&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=y&lt;n <span class="keyword">and</span> (x,y) <span class="keyword">not</span> <span class="keyword">in</span> visited:<span class="comment"># 不出界 and 不走回头路</span></span><br><span class="line">                matrix[x][y] = matrix[i][j] + <span class="number">1</span></span><br><span class="line">                <span class="comment"># visited一定要在这里添加，否则产生大量重复计算</span></span><br><span class="line">                visited.add((x,y))</span><br><span class="line">                Q.append((x,y))</span><br><span class="line">    <span class="keyword">return</span> matrix</span><br></pre></td></tr></table></figure></p><hr><h2 id="leetcode-279-Perfect-Squares"><a href="#leetcode-279-Perfect-Squares" class="headerlink" title="leetcode 279 Perfect Squares"></a>leetcode 279 Perfect Squares</h2><p>给定一个正整数n，找到m个平方数(1,4,9…)使得m个数的和为n，返回满足条件的最小的m<br>n = 12, return 3; because 12 = 4 + 4 + 4<br>n = 13, return 2; because 13 = 4 + 9</p><p>一般看到这道题大家第一反应可能是dp，记dp[i]表示组成和为i的平方数的最优个数，则dp[n]为所求。<br>递推式为：<code>dp[n] = 1 + min(dp[n-1],dp[n-4],dp[n-9],...)</code><br>当然这是完全正确的，但是这里我们如果用bfs方法应该怎么做呢？</p><ol><li>找起点，显然是n本身。</li><li>找相邻节点，显然为n-1,n-4,n-9,…,n-k^2，k满足(k+1)^2 &gt; n。<br><img src="/images/bfs_4.png" alt=""><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(n)</span>:</span></span><br><span class="line">    Q = collections.deque([n])</span><br><span class="line">    visited = set()</span><br><span class="line">    level = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> Q:</span><br><span class="line">        l = len(Q)<span class="comment"># 按层处理</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</span><br><span class="line">            n = Q.popleft()</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> level</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,int(n**<span class="number">0.5</span>)+<span class="number">1</span>):<span class="comment"># 遍历相邻节点 and  不重复计算</span></span><br><span class="line">                val = n - i**<span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> val <span class="keyword">in</span> visited: <span class="keyword">continue</span></span><br><span class="line">                Q.append(val)</span><br><span class="line">                visited.add(val)</span><br><span class="line">        level += <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ol><hr><p>如果你看到这里觉得仿佛有点感觉了，那么建议你用这道题练一练<br><a href="https://leetcode.com/problems/open-the-lock/description/" target="_blank" rel="noopener">https://leetcode.com/problems/open-the-lock/description/</a></p><hr><p>OK，截至到目前位置，我默认你应该对这种比较基础的bfs问题已经“一般”掌握了<br>所以我们稍微来看一点进阶的题目</p><h2 id="leetcode-127-Word-Ladder"><a href="#leetcode-127-Word-Ladder" class="headerlink" title="leetcode 127 Word Ladder"></a>leetcode 127 Word Ladder</h2><p>给定一个word1和word2，和一个转换列表wlist，找出最短的变换路径使word1变成word2，其变换规则需满足：</p><ol><li>一次只能改变word1中的一个字母</li><li>每次改变后的单词必须存在于wlist中</li><li>如果无法转换则返回0</li></ol><p>word1 = “hit”,word2= “cog”<br>wlist = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]<br>return 5; because hit -&gt; hot -&gt; dot -&gt; dog -&gt; cog</p><p>相信你看了上面那么多题之后这道题应该不用我详细分析了吧，如图就完事了：<br><img src="/images/bfs_5.png" alt=""><br>我们仍然根据之前说的bfs解题思路来分析：</p><ol><li>找起始点，显然是word1</li><li>找相邻节点，显然是与当前单词只有一处地方不同的单词</li></ol><p>那么我们得想办法保存一下每个单词的“相邻”单词。<br>例如对于’hot’，我们分别去找形如’_ot’,’h_t’,’ho_’ 的单词，又想到如果看到一个再去找一个复杂度也太高了，不如最初就把他们按照这种规则存在字典里面。<br>例如’hot’就分别存入d[‘_ot’],d[‘h_t’],d[‘ho_’]中，这样只花费了n*m个空间，其中n=len(wlist),m=len(wlist[0])<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(word1,word2,wlist)</span>:</span></span><br><span class="line">    <span class="comment"># 按照上述规则存储每个字符</span></span><br><span class="line">    d = collections.defaultdict(list)</span><br><span class="line">    visited = set()</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> wlist:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            d[s[i:]+<span class="string">'_'</span>+s[i+<span class="number">1</span>:]].append(s)</span><br><span class="line">    <span class="comment"># 初始化队列，将起点加入</span></span><br><span class="line">    Q = collections.deque([word1])</span><br><span class="line">    level = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> Q:</span><br><span class="line">        l = len(Q)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</span><br><span class="line">            s = Q.popleft()</span><br><span class="line">            <span class="keyword">if</span> s == word2: <span class="keyword">return</span> level  <span class="comment"># 找到s</span></span><br><span class="line">            <span class="comment"># visited.add(s)</span></span><br><span class="line">            <span class="comment"># 添加相邻节点 and 不重复计算</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(s)):</span><br><span class="line">                <span class="keyword">for</span> s1 <span class="keyword">in</span> d[s[:j]+<span class="string">'_'</span>+s[j+<span class="number">1</span>:]]:</span><br><span class="line">                    <span class="keyword">if</span> s1 <span class="keyword">not</span> <span class="keyword">in</span> visited: </span><br><span class="line">                        Q.append(s1)</span><br><span class="line">                        <span class="comment"># visited一定要放在这，不能在上面注释的地方，否则产生大量重复计算</span></span><br><span class="line">                        visited.add(s1)</span><br><span class="line">        level += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p><hr><p>未完待续！</p>]]></content>
      
      
        <tags>
            
            <tag> bfs </tag>
            
            <tag> 经典算法分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 875 Koko Eating Bananas</title>
      <link href="/2018/07/22/Leetcode-875-Koko-Eating-Bananas/"/>
      <url>/2018/07/22/Leetcode-875-Koko-Eating-Bananas/</url>
      <content type="html"><![CDATA[<p>Koko loves to eat bananas.  There are N piles of bananas, the i-th pile has piles[i] bananas.  The guards have gone and will come back in H hours.<br>Koko can decide her bananas-per-hour eating speed of K.  Each hour, she chooses some pile of bananas, and eats K bananas from that pile.  If the pile has less than K bananas, she eats all of them instead, and won’t eat any more bananas during this hour.<br>Koko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back.<br>Return the minimum integer K such that she can eat all the bananas within H hours.</p><blockquote><p>Example 1:<br>Input: piles = [3,6,7,11], H = 8<br>Output: 4</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: piles = [30,11,23,4,20], H = 5<br>Output: 30</p></blockquote><blockquote><p>Example 3:<br>Input: piles = [30,11,23,4,20], H = 6<br>Output: 23</p></blockquote><p>Note:</p><ol><li>1 &lt;= piles.length &lt;= 10^4</li><li>piles.length &lt;= H &lt;= 10^9</li><li>1 &lt;= piles[i] &lt;= 10^9</li></ol><p><strong>分析：</strong></p><ol><li>去找一个值满足某种条件，这种题见得太多了，显然是二分法，之后我整理一下所有的这种题目做一个合辑。</li><li>那么这里怎么选定初始的lo和hi呢？我们要明确我们找的是吃的速度，那么最低，起码得在吃吧，所以起码lo = 1，那hi呢？我们注意到note中第二点pile.length &lt;= H，因为我们吃的速度就算再快，一次也只能吃一盘而已，所以无论怎样最少都得pile.length个小时才能吃完，所以hi = max(piles)</li></ol><p><strong>思路：</strong></p><ol><li>对于某个确定的k值，我们如何计算吃完所有pile需要的时间呢，对于一盘，时间应该是piles[i]/k 向上取整，然后求和判断是否大于H</li><li>若小于，则说明吃完还绰绰有余，还可以吃慢一点，从lo,mid中继续找</li><li>若大于，则说明吃得太慢了，则应该从mid,hi中继续找</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># O(NlogM) time，N = len(piles), M = max(piles)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minEatingSpeed</span><span class="params">(self, piles, H)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type piles: List[int]</span></span><br><span class="line"><span class="string">        :type H: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        lo,hi = <span class="number">1</span>,max(piles)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">canEat</span><span class="params">(k)</span>:</span></span><br><span class="line">            time = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(piles)):</span><br><span class="line">                time += int(math.ceil(piles[i]/float(k)))</span><br><span class="line">                <span class="keyword">if</span> time &gt; H: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mid = (lo + hi) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> canEat(mid):</span><br><span class="line">                hi = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lo = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> lo</span><br><span class="line"></span><br><span class="line"><span class="number">113</span> / <span class="number">113</span> test cases passed.</span><br><span class="line">diffculty: medium</span><br><span class="line">Runtime: <span class="number">824</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> Binary search </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 874 Walking Robot Simulation</title>
      <link href="/2018/07/22/Leetcode-874-Walking-Robot-Simulation/"/>
      <url>/2018/07/22/Leetcode-874-Walking-Robot-Simulation/</url>
      <content type="html"><![CDATA[<p>A robot on an infinite grid starts at point (0, 0) and faces north.  The robot can receive one of three possible types of commands:<br>-2: turn left 90 degrees<br>-1: turn right 90 degrees<br>1 &lt;= x &lt;= 9: move forward x units<br>Some of the grid squares are obstacles.<br>The i-th obstacle is at grid point (obstacles[i][0], obstacles[i][1])<br>If the robot would try to move onto them, the robot stays on the previous grid square instead (but still continues following the rest of the route.)<br>Return the square of the maximum Euclidean distance that the robot will be from the origin.</p><blockquote><p>Example 1:<br>Input: commands = [4,-1,3], obstacles = []<br>Output: 25<br>Explanation: robot will go to (3, 4)</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: commands = [4,-1,4,-2,4], obstacles = [[2,4]]<br>Output: 65<br>Explanation: robot will be stuck at (1, 4) before turning left and going to (1, 8)</p></blockquote><p>Note:</p><ol><li>0 &lt;= commands.length &lt;= 10000</li><li>0 &lt;= obstacles.length &lt;= 10000</li><li>-30000 &lt;= obstacle[i][0] &lt;= 30000</li><li>-30000 &lt;= obstacle[i][1] &lt;= 30000</li><li>The answer is guaranteed to be less than 2 ^ 31.</li></ol><p><strong>分析：</strong></p><ol><li>首先应该确定目前行进的方向，我用(1,-1,-2,2)这四个值分别代表上下左右,dire = 1代表目前向上行进，故初始化dire = 1</li><li>当commands[i] = -2 or -1时，改变dire的值，这跟dire当前的值有关，具体方法于思路中说</li><li>因为每次行进的距离不超过10，那么最多也就走90000步，我们完全可以每一步都判断其是否被一个obstacles所阻挡，但是每次比较一个元祖是不是在集合中也太蠢了，所以稍微处理一下，我们用两个字典记录obstacles，例如，dx[x1]代表一个列表，列表里面记录所有横坐标为x1的点的纵坐标,dy[y1]同理</li><li><code>注意，这道题是要求整个过程中达到的最大的欧拉距离，并不是最后的距离，所有每移动一次就要比较一次，我就是没看到这一点，做了特别特别久，都不知道哪里错了！</code></li></ol><p><strong>思路：</strong></p><ol><li>我们用一个directions = {1:[-2,2], -1:[2,-2], -2:[-1,1], 2:[1,-1]}记录方向的变换，对于directions[x]，x代表当前方向，directions[x][0]表示向左转之后的方向，directions[x][1]代表向右转之后的方向</li><li>用position=[x,y]记录此时的位置，每进行一次移动就记录一次</li><li>别看代码这么长，其实后面的代码都是一样的（只跟方向有关），因为太恶心了我也懒得整合了</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># O(n) time, O(n) space</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">robotSim</span><span class="params">(self, commands, obstacles)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type commands: List[int]</span></span><br><span class="line"><span class="string">        :type obstacles: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dx = collections.defaultdict(set)</span><br><span class="line">        dy = collections.defaultdict(set)</span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> obstacles:</span><br><span class="line">            dx[x].add(y)</span><br><span class="line">            dy[y].add(x)</span><br><span class="line"></span><br><span class="line">        position = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        directions = &#123;<span class="number">1</span>:[<span class="number">-2</span>,<span class="number">2</span>], <span class="number">-1</span>:[<span class="number">2</span>,<span class="number">-2</span>], <span class="number">-2</span>:[<span class="number">-1</span>,<span class="number">1</span>], <span class="number">2</span>:[<span class="number">1</span>,<span class="number">-1</span>]&#125;</span><br><span class="line">        dire = <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(commands)):</span><br><span class="line">            <span class="comment"># 左转</span></span><br><span class="line">            <span class="keyword">if</span> commands[i] == <span class="number">-2</span>:</span><br><span class="line">                dire = directions[dire][<span class="number">0</span>]</span><br><span class="line">            <span class="comment"># 右转</span></span><br><span class="line">            <span class="keyword">elif</span> commands[i] == <span class="number">-1</span>:</span><br><span class="line">                dire = directions[dire][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x = commands[i]</span><br><span class="line">                <span class="comment"># 若在向上or下走，固定x,判断每个y是否存在于dx[x]中</span></span><br><span class="line">                <span class="keyword">if</span> dire == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,x+<span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">if</span> position[<span class="number">1</span>] + i <span class="keyword">in</span> dx[position[<span class="number">0</span>]]:</span><br><span class="line">                            position[<span class="number">1</span>] = position[<span class="number">1</span>] + i - <span class="number">1</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        position[<span class="number">1</span>] = position[<span class="number">1</span>] + i</span><br><span class="line">                <span class="keyword">elif</span> dire == <span class="number">-1</span>:</span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,x+<span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">if</span> position[<span class="number">1</span>] - i <span class="keyword">in</span> dx[position[<span class="number">0</span>]]:</span><br><span class="line">                            position[<span class="number">1</span>] = position[<span class="number">1</span>] - i + <span class="number">1</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        position[<span class="number">1</span>] = position[<span class="number">1</span>] - i</span><br><span class="line">                <span class="comment"># 若在向左or右走，固定y，判断每个x是否存在于dy[y]中</span></span><br><span class="line">                <span class="keyword">elif</span> dire == <span class="number">-2</span>:</span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,x+<span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">if</span> position[<span class="number">0</span>] - i <span class="keyword">in</span> dy[position[<span class="number">1</span>]]:</span><br><span class="line">                            position[<span class="number">0</span>] = position[<span class="number">0</span>] - i + <span class="number">1</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        position[<span class="number">0</span>] = position[<span class="number">0</span>] - i</span><br><span class="line">                <span class="keyword">elif</span> dire == <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,x+<span class="number">1</span>):</span><br><span class="line">                        <span class="keyword">if</span> position[<span class="number">0</span>] + i <span class="keyword">in</span> dy[position[<span class="number">1</span>]]:</span><br><span class="line">                            position[<span class="number">0</span>] = position[<span class="number">0</span>] + i - <span class="number">1</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        position[<span class="number">0</span>] = position[<span class="number">0</span>] + i</span><br><span class="line">            res = max(res, position[<span class="number">0</span>]**<span class="number">2</span> + position[<span class="number">1</span>]**<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="number">47</span> / <span class="number">47</span> test cases passed.</span><br><span class="line">diffculty: easy</span><br><span class="line">Runtime: <span class="number">144</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 873 Length of Longest Fibonacci Subsequence</title>
      <link href="/2018/07/22/Leetcode-873-Length-of-Longest-Fibonacci-Subsequence/"/>
      <url>/2018/07/22/Leetcode-873-Length-of-Longest-Fibonacci-Subsequence/</url>
      <content type="html"><![CDATA[<p>A sequence X_1, X_2, …, X_n is fibonacci-like if:<br>· n &gt;= 3<br>· X_i + X_{i+1} = X_{i+2} for all i + 2 &lt;= n<br>Given a strictly increasing array A of positive integers forming a sequence, find the length of the longest fibonacci-like subsequence of A.  If one does not exist, return 0.<br>(Recall that a subsequence is derived from another sequence A by deleting any number of elements (including none) from A, without changing the order of the remaining elements.  For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].)</p><blockquote><p>Example 1:<br>Input: [1,2,3,4,5,6,7,8]<br>Output: 5<br>Explanation:<br>The longest subsequence that is fibonacci-like: [1,2,3,5,8].</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: [1,3,7,11,12,14,18]<br>Output: 3<br>Explanation:<br>The longest subsequence that is fibonacci-like:<br>[1,11,12], [3,11,14] or [7,11,18].</p></blockquote><p>Note:</p><ol><li>3 &lt;= A.length &lt;= 1000</li><li>1 &lt;= A[0] &lt; A[1] &lt; … &lt; A[A.length - 1] &lt;= 10^9<br>(The time limit has been reduced by 50% for submissions in Java, C, and C++.)</li></ol><p><strong>分析：</strong></p><ol><li>对于这种找子串的问题，大家应该敏感一点，虽然不说绝对，但是极大可能是dp，在这里写一下我分析这道题的心路历程</li><li>第一反应，dp[i]表示nums[:i]的最长fiboc序列长度。但仔细想想dp[i]只记录长度，我根本没法去判断nums[i]能否组出一个更长的序列，那用dp[i]记录下一个期望的数（序列中最后两个数的和）？但是就想example2一样，首先可能会有很多期望的值，其次，可能最后最长的那个序列在最初分析数组前几个数时根本不包括其中，所以这个方法应该是行不通。</li><li>第二反应，发现A的长度不超过1000，这不是暗示我n^2的方法嘛，一想dp[i][j]表示nums[i:j]的最长fibco序列长度，乍一看好像可行诶，首先可以初始化，因为j-i&lt;2则dp[i][j] = 0，所有的j-i=2都可以判断出来（因为就三个数），对于j-i&gt;2，可以依次分析dp[i][i+2],dp[i][i+3]…dp[i][j-1]与nums[j]能否构成更长的序列，取最长的那个保存，但想到这里的时候，发现这个方法复杂度好像有点高哦，达到n^3了，想了一会也没想到怎么优化，而且也还是会面临第2点中说的第一个问题，遂放弃。</li><li>第三反应，逆向思维一下，像上面两个方法都是判断最后一个数能不能和前面的组成更长的序列，那为什么不固定住最后的序列，去找前面的序列呢(这个思维正好把第2点中提到的那个“其次”解决了)，dp[i][j]表示以nums[i]和nums[j]结尾的fibco序列的最长长度，则dp[i][j] = dp[nums[j]-nums[i]的index][i] + 1，当然这必须要满足nums[j]-nums[i]在A中</li></ol><p><strong>思路：</strong></p><ol><li>用一个字典保存值和下标的对应关系，用于获得nums[j]-nums[i]的index</li><li>集合记录A（有序）中元素，判断nums[j]-nums[i]是否在A中</li><li>这一点inspired by @lee215，判断nums[j]-nums[i] &lt; nums[i] and nums[j]-nums[i] in s，可以避免重复计算</li><li>inspired by @lee215，可以用值来代替下标(python版本，它的C++版本是用的我上面说的思路，这么一看python实在太方便了)，可以让代码简洁很多（这是真的大神！！！）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lenLongestFibSubseq</span><span class="params">(A)</span>:</span></span><br><span class="line">    dp = collections.defaultdict(int)</span><br><span class="line">    s = set(A)</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> xrange(len(A)):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(j):</span><br><span class="line">            <span class="keyword">if</span> A[j] - A[i] &lt; A[i] <span class="keyword">and</span> A[j] - A[i] <span class="keyword">in</span> s:</span><br><span class="line">                dp[A[i], A[j]] = dp.get((A[j] - A[i], A[i]), <span class="number">2</span>) + <span class="number">1</span></span><br><span class="line">                res = max(res, dp[A[i], A[j]])</span><br><span class="line">    <span class="keyword">return</span> max(dp.values() <span class="keyword">or</span> [<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="number">33</span> / <span class="number">33</span> test cases passed.</span><br><span class="line">diffculty: medium</span><br><span class="line">Runtime: <span class="number">328</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 872 Leaf-Similar Trees</title>
      <link href="/2018/07/22/Leetcode-872-Leaf-Similar-Trees/"/>
      <url>/2018/07/22/Leetcode-872-Leaf-Similar-Trees/</url>
      <content type="html"><![CDATA[<p><img src="/images/leetcode_872.png" alt=""></p><a id="more"></a><p><strong>分析：</strong></p><ol><li>一棵树的叶子节点的值从左至右构成的序列叫做叶子序列</li><li>判断两颗树的叶子序列是否相同</li><li>显然要处理不同层的叶子还要从左至右，肯定是dfs了</li></ol><p><strong>思路：</strong></p><ol><li>编写dfs()用于遍历树，并记录叶子序列</li><li>对两棵树分别调用dfs函数，比较叶子序列是否相同</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">leafSimilar</span><span class="params">(self, root1, root2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root1: TreeNode</span></span><br><span class="line"><span class="string">        :type root2: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root,rec)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                rec.append(root.val)</span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                dfs(root.left,rec)</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                dfs(root.right,rec)</span><br><span class="line">        rec1, rec2 = [], []</span><br><span class="line">        dfs(root1, rec1)</span><br><span class="line">        dfs(root2, rec2)</span><br><span class="line">        <span class="keyword">return</span> rec1 == rec2</span><br><span class="line"></span><br><span class="line"><span class="number">36</span> / <span class="number">36</span> test cases passed.</span><br><span class="line">diffculty: easy</span><br><span class="line">Runtime: <span class="number">28</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dfs </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 583 Delete Operation for Two Strings</title>
      <link href="/2018/07/19/Leetcode-583-Delete-Operation-for-Two-Strings/"/>
      <url>/2018/07/19/Leetcode-583-Delete-Operation-for-Two-Strings/</url>
      <content type="html"><![CDATA[<p>给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。</p><blockquote><p>示例 1:<br>输入: “sea”, “eat”<br>输出: 2<br>解释: 第一步将”sea”变为”ea”，第二步将”eat”变为”ea”</p></blockquote><a id="more"></a><p>说明:<br>给定单词的长度不超过500。<br>给定单词中的字符只含有小写字母。</p><p><strong>分析：</strong></p><ol><li>因为只能做删除操作，所以这其实就是一个最长公共子序列问题</li><li>定义dp[i][j]表示word1[:i+1]和word2[:j+1]之间的最长公共子序列长度</li><li>递推式如下：<ol><li>dp[i][j] = dp[i-1][j-1] + 1 if word1[i] == word2[j]</li><li>dp[i][j] = max(dp[i-1][j], dp[i][j-1])</li></ol></li><li>示例中dp数组应如下：</li></ol><table><thead><tr><th></th><th>e</th><th>a</th><th>t</th></tr></thead><tbody><tr><td>s</td><td>0</td><td>0</td><td>0</td></tr><tr><td>e</td><td>1</td><td>1</td><td>1</td></tr><tr><td>a</td><td>1</td><td>2</td><td>2</td></tr></tbody></table><p><strong>思路：</strong></p><ol><li>初始化所有的dp[0][j],dp[i][0]</li><li>按照递推式运算</li><li>记l = dp[-1][-1]，则应返回 m-l + n-l，m,n分别代表word1和word2的长度</li><li>处理数据为空的情况</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, w1, w2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type word1: str</span></span><br><span class="line"><span class="string">        :type word2: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> w1: <span class="keyword">return</span> len(w2)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> w2: <span class="keyword">return</span> len(w1)</span><br><span class="line">        m,n = len(w1), len(w2)</span><br><span class="line">        dp = [[<span class="number">1</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> w1[i] != w2[<span class="number">0</span>]: dp[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> w1[<span class="number">0</span>] != w2[j]: dp[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">if</span> w1[i] == w2[j]:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])</span><br><span class="line">        l = dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> m - l + n - l</span><br><span class="line"></span><br><span class="line"><span class="number">1307</span> / <span class="number">1307</span> test cases passed.</span><br><span class="line">diffculty: medium</span><br><span class="line">Runtime: <span class="number">180</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 581 Shortest Unsorted Continuous Subarray</title>
      <link href="/2018/07/19/Leetcode-581-Shortest-Unsorted-Continuous-Subarray/"/>
      <url>/2018/07/19/Leetcode-581-Shortest-Unsorted-Continuous-Subarray/</url>
      <content type="html"><![CDATA[<p>给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。<br>你找到的子数组应是最短的，请输出它的长度。</p><blockquote><p>示例 1:<br>输入: [2, 6, 4, 8, 10, 9, 15]<br>输出: 5<br>解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。</p></blockquote><a id="more"></a><p>说明 :</p><ol><li>输入的数组长度范围在 [1, 10,000]。</li><li>输入的数组可能包含重复元素 ，所以升序的意思是&lt;=。</li></ol><p><strong>分析：</strong></p><ol><li>我们需要找一段<code>最短无序数组nums[start:end]</code>，使其排序完成后整个数组也是有序的，换个角度想，我们也可以找<code>两段最长的有序数组nums[:start]和nums[end:]</code>，那么怎样找到“最长”的情况呢</li><li>对于某一个元素nums[i]，如果其满足<code>nums[i] &lt; min(nums[i+1:])</code>，则我们可以说nums[i]是处于有序序列中的，即nums[:start]中。</li><li>对于某一个元素nums[j]，如果其满足<code>nums[j] &gt; max(nums[:j])</code>，则我们可以说nums[j]也是处于有序序列中的，即nums[end:]中。</li></ol><p><strong>思路：</strong></p><ol><li>从0开始，找到第一个不满足<code>nums[i] &lt; min(nums[i+1:])</code>的i，记为start</li><li>从len(nums)-1开始，找到第一个不满足<code>nums[j] &gt; max(nums[:j])</code>的j，记为end</li><li>用s[i]记录min(nums[i:])，用l[j]记录max(nums[:j])</li><li>处理数组初始有序情况</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findUnsortedSubarray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        s = [nums[<span class="number">-1</span>]] * len(nums)</span><br><span class="line">        l = [nums[<span class="number">0</span>]] * len(nums)</span><br><span class="line">        start = end = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 找到start</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            s[i] = min(nums[i], s[i+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; s[i+<span class="number">1</span>]:</span><br><span class="line">                start = i;<span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 找到end</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            l[i] = max(l[i<span class="number">-1</span>],nums[i])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; l[i<span class="number">-1</span>]:</span><br><span class="line">                end = i;<span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 处理初始有序情况</span></span><br><span class="line">        <span class="keyword">if</span> start == end == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> end - start + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">307</span> / <span class="number">307</span> test cases passed.</span><br><span class="line">difficulty: easy</span><br><span class="line">Runtime: <span class="number">72</span> ms,beats <span class="number">29</span>%</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 576 Out of Boundary Paths</title>
      <link href="/2018/07/19/Leetcode-576-Out-of-Boundary-Paths/"/>
      <url>/2018/07/19/Leetcode-576-Out-of-Boundary-Paths/</url>
      <content type="html"><![CDATA[<p>给定一个 m × n 的网格和一个球。球的起始坐标为 (i,j) ，你可以将球移到相邻的单元格内，或者往上、下、左、右四个方向上移动使球穿过网格边界。但是，你最多可以移动N次。找出可以将球移出边界的路径数量。答案可能非常大，返回结果mod 1e9+7的值。</p><p><img src="/images/leetcode_576.png" alt=""><br><a id="more"></a><br>说明:</p><ol><li>球一旦出界，就不能再被移动回网格内。</li><li>网格的长度和高度在 [1,50] 的范围内。</li><li>N 在 [0,50] 的范围内。</li></ol><p><strong>分析：</strong></p><ol><li>这道题乍一看很像一个标准的bfs，因为限定最多只能移动N次，我们只要bfs依次遍历发现出界就+1，当bfs的深度大于N的时候break。当然理论上是没有任何问题的，确实能得出正确答案，但是这里N的取值范围达到了50，我们对任意一个点bfs有四个方向（可以走回头路），那么复杂度达到了4^N，显然会超时。当然我会在文章后面给出bfs的做法，毕竟这是可以处理N比较小的情况的解法，让大家更熟悉bfs的套路。</li><li>我不知道你们有没有这种感觉，一般看到这个mod 1e9+7，这道题8成就是dp了，而且就是那种每个dp值你都得mod一下再去进行运算的那种。我觉得这算一个小技巧吧，看到mod 1e9+7就要想到dp。</li><li>显然，这里dp很好定义，我们定义<code>dp[(i,j,N)]</code>表示<code>从i,j出发，最多走N步情况下满足题意的路径数量</code>，那么我们所求也就是dp[(i,j,N)]。根据我们上面说的bfs的思路，递推式可得：<br><code>dp[(i,j,N)] = dp[(i+1,j,N-1)] + dp[(i-1,j,N-1)] + dp[(i,j+1,N-1)] + dp[(i,j-1,N-1)]</code></li></ol><p><strong>思路：</strong></p><ol><li>处理好边界情况：<ol><li>当i,j仍然在网格内时，如果N=0，说明这条路走不出去,dp[(i,j,N)] = 0</li><li>当i,j仍然在网格内时，如果N&gt;0，如递推式</li><li>当i,j在网格外时，说明已经走出去，dp[(i,j,N)] = 1</li></ol></li><li>这里我为了方便代码书写就用的记忆化的形式，用一个cache来存储已经计算过的结果</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPaths</span><span class="params">(self, m, n, N, i, j)</span>:</span></span><br><span class="line">        mod = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        cache = collections.defaultdict(int)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(i,j,N)</span>:</span></span><br><span class="line">            <span class="comment"># 记忆化思想</span></span><br><span class="line">            <span class="keyword">if</span> (i,j,N) <span class="keyword">in</span> cache:</span><br><span class="line">                <span class="keyword">return</span> cache[(i,j,N)]</span><br><span class="line">            <span class="comment">#i,j在网格内情况</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>&lt;=i&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=j&lt;n:</span><br><span class="line">                <span class="keyword">if</span> N == <span class="number">0</span>:</span><br><span class="line">                    cache[(i,j,N)] = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">return</span> cache[(i,j,N)]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> x,y <span class="keyword">in</span> [(i+<span class="number">1</span>,j),(i<span class="number">-1</span>,j),(i,j+<span class="number">1</span>),(i,j<span class="number">-1</span>)]:</span><br><span class="line">                    cache[(i,j,N)] += helper(x,y,N<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> cache[(i,j,N)] % mod</span><br><span class="line">            <span class="comment"># 网格外情况</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cache[(i,j,N)] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> cache[(i,j,N)]</span><br><span class="line">        <span class="keyword">return</span> helper(i,j,N) % mod</span><br><span class="line"></span><br><span class="line"><span class="number">94</span> / <span class="number">94</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">272</span> ms</span><br></pre></td></tr></table></figure><p>下面是bfs代码，在这道题中tle<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPaths</span><span class="params">(m,n,N,i,j)</span>:</span></span><br><span class="line">    mod = <span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span></span><br><span class="line">    Q = collections.deque([(i,j,<span class="number">0</span>)])</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> Q:</span><br><span class="line">        x,y,step = Q.popleft()</span><br><span class="line">        <span class="keyword">if</span> step &gt; N: <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span>&lt;=x&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=y&lt;n:</span><br><span class="line">            Q.append((x+<span class="number">1</span>,y,step+<span class="number">1</span>))</span><br><span class="line">            Q.append((x<span class="number">-1</span>,y,step+<span class="number">1</span>))</span><br><span class="line">            Q.append((x,y+<span class="number">1</span>,step+<span class="number">1</span>))</span><br><span class="line">            Q.append((x,y<span class="number">-1</span>,step+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res % mod</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 575 Distribute Candies</title>
      <link href="/2018/07/18/Leetcode-575-Distribute-Candies/"/>
      <url>/2018/07/18/Leetcode-575-Distribute-Candies/</url>
      <content type="html"><![CDATA[<p>给定一个偶数长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。你需要把这些糖果平均分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数。</p><blockquote><p>示例 1:<br>输入: candies = [1,1,2,2,3,3]<br>输出: 3<br>解析: 一共有三种种类的糖果，每一种都有两个。最优分配方案：妹妹获得[1,2,3],弟弟也获得[1,2,3]。这样使妹妹获得糖果的种类数最多。</p></blockquote><a id="more"></a><blockquote><p>示例 2 :<br>输入: candies = [1,1,2,3]<br>输出: 2<br>解析: 妹妹获得糖果[2,3],弟弟获得糖果[1,1]，妹妹有两种不同的糖果，弟弟只有一种。这样使得妹妹可以获得的糖果种类数最多。</p></blockquote><p>注意:</p><ol><li>数组的长度为[2, 10,000]，并且确定为偶数。</li><li>数组中数字的大小在范围[-100,000, 100,000]内。</li></ol><p><strong>分析：</strong></p><ol><li>设总共有2*n个糖果，那么显然妹妹最后会分到n个糖果，如果糖果的种类数大于n，妹妹最多只能得到n种糖果，若糖果的种类数小于n，妹妹则最多只能得到糖果的种类数</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distributeCandies</span><span class="params">(self, candies)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type candies: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        s = set(candies)</span><br><span class="line">        <span class="keyword">return</span> min(len(candies)/<span class="number">2</span>, len(s))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">205</span> / <span class="number">205</span> test cases passed.</span><br><span class="line">difficulty: easy</span><br><span class="line">Runtime: <span class="number">92</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 529 Minesweeper</title>
      <link href="/2018/07/11/Leetcode-529-Minesweeper/"/>
      <url>/2018/07/11/Leetcode-529-Minesweeper/</url>
      <content type="html"><![CDATA[<p>让我们一起来玩扫雷游戏！<br>给定一个代表游戏板的二维字符矩阵。 ‘M’ 代表一个未挖出的地雷，’E’ 代表一个未挖出的空方块，’B’ 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的已挖出的空白方块，数字（’1’ 到 ‘8’）表示有多少地雷与这块已挖出的方块相邻，’X’ 则表示一个已挖出的地雷。<br>现在给出在所有未挖出的方块中（’M’或者’E’）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：</p><ol><li>如果一个地雷（’M’）被挖出，游戏就结束了- 把它改为 ‘X’。</li><li>如果一个没有相邻地雷的空方块（’E’）被挖出，修改它为（’B’），并且所有和其相邻的方块都应该被递归地揭露。</li><li>如果一个至少与一个地雷相邻的空方块（’E’）被挖出，修改它为数字（’1’到’8’），表示相邻地雷的数量。</li><li>如果在此次点击中，若无更多方块可被揭露，则返回面板。</li></ol><a id="more"></a><p><img src="/images/leetcode_529_1.png" alt=""><br><img src="/images/leetcode_529_2.png" alt=""></p><p><strong>注意:</strong></p><ol><li>输入矩阵的宽和高的范围为 [1,50]。</li><li>点击的位置只能是未被挖出的方块 (‘M’ 或者 ‘E’)，这也意味着面板至少包含一个可点击的方块。</li><li>输入面板不会是游戏结束的状态（即有地雷已被挖出）。</li><li>简单起见，未提及的规则在这个问题中可被忽略。例如，当游戏结束时你不需要挖出所有地雷，考虑所有你可能赢得游戏或标记方块的情况。</li></ol><p><strong>分析：</strong></p><ol><li>根据规则中所述，关键有以下几点<ol><li>点击处必为’E’或’M’，若是’M’，将其改为’X’游戏结束</li><li>若点击处为’E’，则判断’E’周围是否有雷存在，若有则返回雷的数量，将其修改为雷的数量</li><li>若’E’周围无雷，则对’E’周围格子（共8个）依次按照上述规则递归</li></ol></li><li>这里举个简单例子，若点击(0,0)：(<code>不能越过数字去递归(0,2)，这一点从示例1中也能看出</code>)<br>[E,E,E]————&gt;[B,1,E]<br>[E,E,M]————&gt;[B,1,M]</li></ol><p><strong>思路：</strong></p><ol><li>当我们递归E的时候如何判断周边是否有雷呢，每次都遍历8个方向会有大量重复工作，虽然在这道题中即使你这样做也可以通过，但是显然这不是我们追求的</li><li>我们使用一个字典d[(i,j)]来存储(i,j)处周围的雷数量，那么容易想到我先遍历每一个雷，然后对雷周围的格子在d中进行一次变换存储</li><li>这样我们之后递归E时便可通过判断(i,j)是否存在于d中来判断E周边是否有雷</li><li>本身递归的dfs是很简单的，这里不做详细说明了</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">updateBoard</span><span class="params">(self, board, click)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :type click: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m,n = len(board),len(board[<span class="number">0</span>])</span><br><span class="line">        d = collections.defaultdict(int)</span><br><span class="line">        directions = [(i<span class="number">-1</span>,j<span class="number">-1</span>),(i<span class="number">-1</span>,j),(i<span class="number">-1</span>,j+<span class="number">1</span>),(i,j<span class="number">-1</span>),(i,j+<span class="number">1</span>),(i+<span class="number">1</span>,j<span class="number">-1</span>),(i+<span class="number">1</span>,j),(i+<span class="number">1</span>,j+<span class="number">1</span>)]</span><br><span class="line">        click_i,click_j = click</span><br><span class="line">        <span class="comment"># 点击处为雷</span></span><br><span class="line">        <span class="keyword">if</span> board[click_i][click_j] == <span class="string">'M'</span>:</span><br><span class="line">            board[click_i][click_j] = <span class="string">'X'</span></span><br><span class="line">            <span class="keyword">return</span> board</span><br><span class="line">        <span class="comment"># 初始化字典</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">setNum</span><span class="params">(i,j,d)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> x,y <span class="keyword">in</span> directions:</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=x&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=y&lt;n <span class="keyword">and</span> board[x][y] != <span class="string">'M'</span>:</span><br><span class="line">                    d[(x,y)] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">'M'</span>:</span><br><span class="line">                    setNum(i,j,d)</span><br><span class="line">        <span class="comment"># 点击处周边有雷</span></span><br><span class="line">        <span class="keyword">if</span> (click_i,click_j) <span class="keyword">in</span> d:</span><br><span class="line">            board[click_i][click_j] = str(d[(click_i,click_j)])</span><br><span class="line">            <span class="keyword">return</span> board</span><br><span class="line">        <span class="comment"># dfs依次递归</span></span><br><span class="line">        visited = set()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i,j)</span>:</span></span><br><span class="line">            visited.add((i,j))</span><br><span class="line">            <span class="comment"># 递归到数字则修改board</span></span><br><span class="line">            <span class="keyword">if</span> (i,j) <span class="keyword">in</span> d: </span><br><span class="line">                board[i][j] = str(d[(i,j)])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                board[i][j] = <span class="string">'B'</span></span><br><span class="line">            <span class="keyword">for</span> x,y <span class="keyword">in</span> directions:</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=x&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=y&lt;n <span class="keyword">and</span> (x,y) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    dfs(x,y)</span><br><span class="line"></span><br><span class="line">        dfs(click_i,click_j)</span><br><span class="line">        <span class="keyword">return</span> board</span><br><span class="line"></span><br><span class="line"><span class="number">54</span> / <span class="number">54</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">248</span> ms,beats <span class="number">97</span>%</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 525 Contiguous Array</title>
      <link href="/2018/07/10/Leetcode-525-Contiguous-Array/"/>
      <url>/2018/07/10/Leetcode-525-Contiguous-Array/</url>
      <content type="html"><![CDATA[<p>给定一个二进制数组, 找到含有相同数量的 0 和 1 的最长连续子数组。</p><blockquote><p>示例 1:<br>输入: [0,1]<br>输出: 2<br>说明: [0, 1] 是具有相同数量0和1的最长连续子数组。<br>示例 2:<br>输入: [0,1,0]<br>输出: 2<br>说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。</p></blockquote><p>注意: 给定的二进制数组的长度不会超过50000。<br><a id="more"></a></p><p><code>不想做重复的工作，这道题和523 560一模一样，如果你想弄懂前缀和的这个解法，建议先看560，再看523，我在另外两篇博客中写得很详细了</code><br>具体见<a href="https://buptwc.github.io/2018/07/10/Leetcode-523-Continuous-Subarray-Sum/" target="_blank" rel="noopener">https://buptwc.github.io/2018/07/10/Leetcode-523-Continuous-Subarray-Sum/</a></p><p><code>当你看懂前两道题后再来分析这道题，将所有的0变成-1，这道题就变成找最长的和为0的连续子数组，前缀和可解</code></p><p><strong>思路：</strong><br>（建议先看560，否则你可能不知道我在说什么）</p><ol><li>改用字典存储已经遍历过的值，对应相应的下标，即d[sum(nums[:i])] = i，相同的key值取最小（最左边）的下标</li><li>依次遍历判断，若成功找到key值，存储一次长度</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxLength</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">0</span>: nums[i] = <span class="number">-1</span></span><br><span class="line">        sm = <span class="number">0</span></span><br><span class="line">        d = collections.defaultdict(<span class="keyword">lambda</span>: float(<span class="string">'inf'</span>))</span><br><span class="line">        d[<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            sm += nums[i]</span><br><span class="line">            <span class="keyword">if</span> sm <span class="keyword">in</span> d: </span><br><span class="line">                res = max(res,i-d[sm])</span><br><span class="line">            d[sm] = min(d[sm],i) </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">555</span> / <span class="number">555</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">292</span> ms,beats <span class="number">91.27</span>%</span><br><span class="line"><span class="comment"># 可以稍微优化一下，第一次的遍历nums将0改成1可以去除，直接在sm += nums[i]时判断nums[i]的值即可</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 523 Continuous Subarray Sum</title>
      <link href="/2018/07/10/Leetcode-523-Continuous-Subarray-Sum/"/>
      <url>/2018/07/10/Leetcode-523-Continuous-Subarray-Sum/</url>
      <content type="html"><![CDATA[<p>给定一个包含非负数的数组和一个目标整数k，编写一个函数来判断该数组是否含有连续的子数组，其大小至少为2，总和为k的倍数，即总和为 n*k，其中n也是一个整数。</p><blockquote><p>示例 1:<br>输入: [23,2,4,6,7], k = 6<br>输出: True<br>解释: [2,4] 是一个大小为 2 的子数组，并且和为 6。<br>示例 2:<br>输入: [23,2,6,4,7], k = 6<br>输出: True<br>解释: [23,2,6,4,7]是大小为 5 的子数组，并且和为 42。</p></blockquote><a id="more"></a><p>说明:</p><ol><li>数组的长度不会超过10,000。</li><li>你可以认为所有数字总和在 32 位有符号整数范围内。</li></ol><p><strong>分析：</strong></p><ol><li>这道题和560题解法一样，强烈建议先看那道题，具体见<a href="https://leetcode.com/problems/subarray-sum-equals-k/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/subarray-sum-equals-k/solution/</a></li><li>当我们分析数组中连续的若干数之和时，很容易想到先用一个数组sm[i]记录sum(nums[:i])，那么则有<code>sm[j] - sm[i] = sum(nums[i:j])</code></li><li>但是如果依次遍历时间复杂度为O(n^2)，在这里肯定超时，所以我们得想个简单的办法，这也就是这类型题的经典思想，前缀和处理</li><li>我们先来考虑一个简单的情况，即是否存在连续的子数组的和为k，我们应该怎么做呢？<ol><li>假设存在i,j满足<code>sum(nums[i:j]) = k</code>，那么则应有<code>sm[j] - sm[i] = k</code>，也就是如果我们找到i,j满足这个式子就可以说明存在…！</li><li>那当我们遍历sm数组时，将遍历的数依次存进集合，遍历至<code>sm[j]</code>时，我们如果发现<code>sm[j]-k</code>，即<code>sm[i]</code>是存在于集合中的，那么我们就可以确定,确实存在sum(nums[i:j]) = k</li></ol></li><li>回到我们这道题上，假设确实存在i,j(j-i&gt;=2)满足<code>sum(nums[i:j]) = n * k</code>，即<code>sm[j] - sm[i] = n * k</code>，此时用上面的方法是不可行的，因为n*k是个不确定的数，我们无法判断其是否在集合内，但我们只用作一个小小的变换————对上式两边同时模k，上式变为<code>sm[j]%k - sm[i]%k = 0</code>，此时就和4中情况是等价的，唯独是集合中存储的数从sm[i]变成了sm[i]%k</li></ol><p><strong>思路：</strong></p><ol><li>因为j-i&gt;=2，所以更新集合的时候应当推迟一步，即分析完sm[i]之后才将sm[i-1]%k加入集合之中</li><li>注意k = 0的情况，因为模0操作是不被允许的，所以需要单独处理</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkSubarraySum</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>: <span class="keyword">return</span> <span class="string">'00'</span> <span class="keyword">in</span> <span class="string">''</span>.join(map(str,nums))</span><br><span class="line">        <span class="comment"># 初始化集合和前缀和数组</span></span><br><span class="line">        s = set([<span class="number">0</span>])</span><br><span class="line">        sm = [nums[<span class="number">0</span>]] * len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            sm[i] = sm[i<span class="number">-1</span>] + nums[i]</span><br><span class="line">            <span class="keyword">if</span> sm[i] % k <span class="keyword">in</span> s: </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="comment"># 分析完之后再更新集合</span></span><br><span class="line">            s.add(sm[i<span class="number">-1</span>]%k)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">75</span> / <span class="number">75</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">36</span> ms,beats <span class="number">98</span>%</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> array </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 518 Coin Change 2</title>
      <link href="/2018/07/10/Leetcode-518-Coin-Change-2/"/>
      <url>/2018/07/10/Leetcode-518-Coin-Change-2/</url>
      <content type="html"><![CDATA[<p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 </p><p>注意: 你可以假设</p><ol><li>0 &lt;= amount (总金额) &lt;= 5000</li><li>1 &lt;= coin (硬币面额) &lt;= 5000</li><li>硬币种类不超过500种</li><li>结果符合32位符号整数</li></ol><a id="more"></a><blockquote><p>示例 1:<br>输入: amount = 5, coins = [1, 2, 5]<br>输出: 4<br>解释: 有四种方式可以凑成总金额:<br>5=5<br>5=2+2+1<br>5=2+1+1+1<br>5=1+1+1+1+1</p></blockquote><blockquote><p>示例 2:<br>输入: amount = 3, coins = [2]<br>输出: 0<br>解释: 只用面额2的硬币不能凑成总金额3。</p></blockquote><blockquote><p>示例 3:<br>输入: amount = 10, coins = [10]<br>输出: 1</p></blockquote><p><strong>分析：</strong></p><ol><li>回溯过不了，因为最小的coin会很小，当amount达到5000的时候递归爆炸</li><li>只能是用dp[i]记录组成i元钱有多少种方法，最后返回dp[amount]即可</li><li>这种思想还挺常见的，我要不是以前做过好几道这样的题目可能也想不到，所以你如果也没想到不要担心，多做之后自然就能想到了</li><li>不过这里有一个点和我以前见到用这个方法的题目是不太一样的，那就是这里是对dp进行<code>顺序遍历</code>，以往都是需要<code>逆序遍历</code>的，就为了<code>防止重复利用数字</code>，但这里恰恰是要重复使用！</li></ol><p><strong>思路：</strong></p><ol><li>建立dp数组，初始化dp[0] = 1</li><li><code>dp[i] += dp[i-coins[j]] for j in range(len(coins)</code></li><li>顺序遍历数组，以示例1中数据为例：<ol><li>dp = [1,0,0,0,0,0] 初始情况</li><li>dp = [1,1,1,1,1,1] 对于coins[0]=1</li><li>dp = [1,1,2,2,3,3] 对于coins[1]=2</li><li>dp = [1,1,2,2,3,4] 对于coins[2]=5</li></ol></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(self, amount, coins)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type amount: int</span></span><br><span class="line"><span class="string">        :type coins: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        :这道题的数据有丶搞的，看样子回溯可能怎样优化都过不了了，只能是dp了</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> amount: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> coins: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        coins.sort()</span><br><span class="line">        dp = [<span class="number">0</span>] * (amount+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(dp)):</span><br><span class="line">                <span class="keyword">if</span> i - c &gt;= <span class="number">0</span>:</span><br><span class="line">                    dp[i] += dp[i-c]</span><br><span class="line">        <span class="comment"># print dp</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">27</span> / <span class="number">27</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">144</span> ms,beats <span class="number">79</span>%</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 516 Longest Palindromic Subsequence</title>
      <link href="/2018/07/09/Leetcode-516-Longest-Palindromic-Subsequence/"/>
      <url>/2018/07/09/Leetcode-516-Longest-Palindromic-Subsequence/</url>
      <content type="html"><![CDATA[<p>给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。</p><blockquote><p>示例 1:<br>输入:<br>“bbbab”<br>输出:<br>4<br>一个可能的最长回文子序列为 “bbbb”。</p></blockquote><a id="more"></a><blockquote><p>示例 2:<br>输入:<br>“cbbd”<br>输出:<br>2<br>一个可能的最长回文子序列为 “bb”。</p></blockquote><p><strong>分析：</strong></p><ol><li>这道题如果能想到定义<code>dp[i][j]表示s[i:j+1]的最长回文子序列长度</code>的话就很简单了，所以在这里的话，我更想去说一下我是怎么想到要用dp以及这样来定义dp的，我认为这才是有帮助的</li><li>看到示例1的时候，’bbbab’，我想首先依次遍历，然后看此时遍历的字符有没有在之前出现过，如果出现过，以这个两个相同字符为边界，看是否能找到一个回文串，那么中间的字符是什么状态呢？是本身就是回文串呢或者说其子串包含回文串呢，想到这一步我突然意识到，这不就是问题的解依赖于其子问题的解吗，于是想到用dp来解决</li><li>那么怎么定义dp呢，因为按照我的思路是固定住两边观察中间，所以我定义一个二维dp，那么上面说的那种情况就可以写成<code>dp[i][j] = dp[i+1][j-1] + 2</code>，到这里豁然开朗，我知道自己没想错……</li></ol><p><strong>思路：</strong></p><ol><li><code>if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2</code></li><li><code>else: dp[i][j] = max(dp[i+1][j], dp[i][j-1])</code></li><li>我是用斜向遍历的，对于示例1：<ol><li>(0,1)-&gt;(1,2)-&gt;(2,3)-&gt;(3,4)</li><li>(0,2)-&gt;(1,3)-&gt;(2,4)</li><li>(0,3)-&gt;(2,4)</li><li>(0,4) # 最后结果</li></ol></li><li>实际上你可以用从最后一层向上遍历，那样的代码应该是最优美的！<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindromeSubseq</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># dp[i][j] reps from i to j,the length of LPS</span></span><br><span class="line">        <span class="keyword">if</span> s == s[::<span class="number">-1</span>]: <span class="keyword">return</span> len(s) <span class="comment"># this code helps my runtime decrease from 1500ms to 500ms,beats 99%</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [[<span class="number">1</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="comment"># 处理斜向遍历时i,j的间隔</span></span><br><span class="line">        gap = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">            i,j = <span class="number">0</span>,gap</span><br><span class="line">            <span class="keyword">while</span> j &lt; n:</span><br><span class="line">                <span class="keyword">if</span> gap == <span class="number">1</span>:</span><br><span class="line">                    dp[i][j] += s[i] == s[j]</span><br><span class="line">                <span class="keyword">elif</span> s[i] == s[j]:</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>] + <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = max(dp[i+<span class="number">1</span>][j],dp[i][j<span class="number">-1</span>])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            gap += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>]<span class="comment"># 返回dp中最大的数，实际也就是这个</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> string </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 567 Permutation in String</title>
      <link href="/2018/07/09/Leetcode-567-Permutation-in-String/"/>
      <url>/2018/07/09/Leetcode-567-Permutation-in-String/</url>
      <content type="html"><![CDATA[<p>给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。<br>换句话说，第一个字符串的排列之一是第二个字符串的子串。</p><blockquote><p>示例1:<br>输入: s1 = “ab” s2 = “eidbaooo”<br>输出: True<br>解释: s2 包含 s1 的排列之一 (“ba”).</p></blockquote><a id="more"></a> <blockquote><p>示例2:<br>输入: s1= “ab” s2 = “eidboaoo”<br>输出: False</p></blockquote><p>注意：</p><ol><li>输入的字符串只包含小写字母</li><li>两个字符串的长度都在 [1, 10000] 之间</li></ol><p><strong>分析：</strong></p><ol><li>标准的滑动窗口解法，示例都太简单，我在这里给出一个例子帮助理解,s1 = ‘abca’,s2 = ‘baabc’</li><li>我们有很多方法判断两个等长的字符串是不是所含字母个数也相同，如collections模块中的Counter函数，如构造一个长度为26的数组，分别记录对应英文字母的个数，这里我们不妨就选后者来进行存储</li><li>对于例子来说:<ol><li>初始化一个d1 = [2,1,1,0,…,0] 记录s1</li><li>初始化一个d2 = [2,2,0,0,…,0] 记录s2中<code>前len(s1)个元素</code>，此时窗口笼罩着<code>&#39;baab&#39;</code></li><li>判断d1 == d2，因为长度为26，且字符串长度不超过10000，故滑动一次只需要比较26次，共滑动<code>len(s2)-len(s1)+1</code>次，所以显然不会超时</li><li>开始滑动，此时窗口笼罩着<code>&#39;aabc&#39;</code>，d2中<code>b减少1</code>，<code>c增加1</code>，再次比较，依此类推，直至遍历结束</li></ol></li></ol><p><strong>思路：</strong></p><ol><li>用ord()函数将字符串转换成asc码</li><li>防止index error，先判断一下len(s2) &lt; len(s1)？</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkInclusion</span><span class="params">(self, s1, s2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s1: str</span></span><br><span class="line"><span class="string">        :type s2: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(s2) &lt; len(s1): <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        d1 = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        d2 = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(s)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> ord(s) - ord(<span class="string">'a'</span>)</span><br><span class="line">        <span class="comment"># 初始化d1,d2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s1)):</span><br><span class="line">            d1[helper(s1[i])] += <span class="number">1</span></span><br><span class="line">            d2[helper(s2[i])] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> d1 == d2: <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 开始滑动</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s2)-len(s1)):</span><br><span class="line">            d2[helper(s2[i])] -= <span class="number">1</span></span><br><span class="line">            d2[helper(s2[i+len(s1)])] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> d1 == d2: <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="number">102</span> / <span class="number">102</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">60</span> ms,beats <span class="number">99</span>%</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> string </tag>
            
            <tag> sliding window </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 866 Smallest Subtree with all the Deepest Nodes</title>
      <link href="/2018/07/09/leetcode-866-Smallest-Subtree-with-all-the-Deepest-Nodes/"/>
      <url>/2018/07/09/leetcode-866-Smallest-Subtree-with-all-the-Deepest-Nodes/</url>
      <content type="html"><![CDATA[<p>Given a binary tree rooted at root, the depth of each node is the shortest distance to the root.<br>A node is deepest if it has the largest depth possible among any node in the entire tree.<br>The subtree of a node is that node, plus the set of all descendants of that node.<br>Return the node with the largest depth such that it contains all the deepest nodes in it’s subtree.</p><p><img src="/images/leetcode_866.png" alt="题目描述"></p><a id="more"></a><p><strong>分析：</strong></p><ol><li>标准的bfs问题，我们只需要记录最后一层的所有节点，然后获取他们的父节点，依次类推，当父节点的数量只有1个时，说明找到了最后所求</li><li>bfs中队列存储数据格式为<code>(node,parent_node)</code>，初始化为<code>(root,None)</code>,让我们用字典能建立对应关系!</li></ol><p><strong>思路：</strong></p><ol><li>我们在用bfs遍历时，用一个字典记录下结点与其父节点的对应关系，并用一个列表记录下每一层的所有结点，当bfs遍历结束时，列表中所存结点即为最后一层结点</li><li>对列表中结点进行迭代，用一个集合来记录父节点，当集合长度为1时，循环结束</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtreeWithAllDeepest</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        Q = collections.deque([(root,<span class="keyword">None</span>)])</span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">while</span> Q:</span><br><span class="line">            iters = len(Q)</span><br><span class="line">            rec = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(iters):</span><br><span class="line">                a,b = Q.popleft()</span><br><span class="line">                rec.append(a)</span><br><span class="line">                <span class="keyword">if</span> a.left: Q.append((a.left,a))</span><br><span class="line">                <span class="keyword">if</span> a.right: Q.append((a.right,a))</span><br><span class="line">                <span class="comment"># 建立对应关系</span></span><br><span class="line">                d[a] = b</span><br><span class="line">        <span class="comment"># rec records the last level node</span></span><br><span class="line">        s = set(rec)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> len(s) != <span class="number">1</span>:</span><br><span class="line">            s = set()</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> rec:</span><br><span class="line">                s.add(d[node])</span><br><span class="line">            res += rec</span><br><span class="line">            rec = list(s)</span><br><span class="line">        <span class="keyword">return</span> list(s)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">57</span> / <span class="number">57</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">24</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> bfs </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 865 Shortest Path to Get All keys</title>
      <link href="/2018/07/09/leetcode-865-Shortest-Path-to-Get-All-keys/"/>
      <url>/2018/07/09/leetcode-865-Shortest-Path-to-Get-All-keys/</url>
      <content type="html"><![CDATA[<p>We are given a 2-dimensional grid. “.” is an empty cell, “#” is a wall, “@” is the starting point, (“a”, “b”, …) are keys, and (“A”, “B”, …) are locks.<br>We start at the starting point, and one move consists of walking one space in one of the 4 cardinal directions.  We cannot walk outside the grid, or walk into a wall.  If we walk over a key, we pick it up.  We can’t walk over a lock unless we have the corresponding key.<br>For some 1 &lt;= K &lt;= 6, there is exactly one lowercase and one uppercase letter of the first K letters of the English alphabet in the grid.  This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.<br>Return the lowest number of moves to acquire all keys.  If it’s impossible, return -1.</p><blockquote><p>Example 1:<br>Input: [“@.a.#”,”###.#”,”b.A.B”]<br>Output: 8</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: [“@..aA”,”..B#.”,”….b”]<br>Output: 6</p></blockquote><p>Note:</p><ol><li>1 &lt;= grid.length &lt;= 30</li><li>1 &lt;= grid[0].length &lt;= 30</li><li>grid[i][j] contains only ‘.’, ‘#’, ‘@’, ‘a’-‘f’ and ‘A’-‘F’</li><li>The number of keys is in [1, 6].  Each key has a different letter and opens exactly one lock.</li></ol><p><strong>分析：</strong></p><ol><li>这道题就像我在498题中说的迷宫问题一样，求到达某点的最短路径，显然是用bfs</li><li>那么这和普通的bfs有什么不同呢，现在给出一个具体实例[[@…a],[.###A],[b.BCc]]，你会发现这里要走回头路的，那么如果凭空就可以来回走的话，会是一个死循环，但我们稍微仔细思考一下，我认为想到<code>走回头路的条件是获得一个新key</code>这个点应该不难想到，那么我们只需要将标准bfs写法中的visited中key值变为(i,j,key)即可</li><li>虽然我做出来了，但是我的代码目前比较凌乱（因为经过多次修改），现在借助一位老哥的代码，和我的思路是完全一样的，来看一看具体如何实现</li></ol><p><strong>思路：</strong></p><ol><li>首先遍历一次数组，记录下起始位置，即‘@’，以及key的数量，即小写字母的数量，记为numOfKey</li><li>队列中的每项元素具有如下结构<code>(i,j,step,key,collectedkey)</code>:<ol><li>i,j表示位置,<code>step</code>代表bfs的深度</li><li><code>key</code>代表目前能走的格子从，初始化为<code>&#39;abcdef.@&#39;</code>，每收集到一个小写字母便将对应的大写字母加入key中</li><li><code>collectedkey</code>代表已经收集的key的数量，如果<code>collectedkey = numOfKey</code>，则代表成功</li></ol></li><li>用visited记录已经走过的状态，避免无限循环，visited中值为(i,j,key)，保证只有在收集到新key之后才能走回头路</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestPathAllKeys</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n, m = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">        numOfKeys = <span class="number">0</span></span><br><span class="line">        direc = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">-1</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">-1</span>,<span class="number">0</span>]]</span><br><span class="line">        visited = set()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">'@'</span>:</span><br><span class="line">                    starti = i</span><br><span class="line">                    startj = j</span><br><span class="line">                <span class="keyword">elif</span> grid[i][j] <span class="keyword">in</span> <span class="string">"abcdef"</span>:</span><br><span class="line">                    numOfKeys += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        deque = collections.deque()</span><br><span class="line">        deque.append([starti, startj, <span class="number">0</span>, <span class="string">".@abcdef"</span>, <span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> deque:</span><br><span class="line">            i, j, steps, keys, collectedKeys = deque.popleft()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> grid[i][j] <span class="keyword">in</span> <span class="string">"abcdef"</span> <span class="keyword">and</span> grid[i][j].upper() <span class="keyword">not</span> <span class="keyword">in</span> keys:</span><br><span class="line">                keys += grid[i][j].upper()</span><br><span class="line">                collectedKeys += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> collectedKeys == numOfKeys:</span><br><span class="line">                <span class="keyword">return</span> steps</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> x, y <span class="keyword">in</span> direc:</span><br><span class="line">                ni = i+x</span><br><span class="line">                nj = j+y</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=ni&lt;n <span class="keyword">and</span> <span class="number">0</span>&lt;=nj&lt;m <span class="keyword">and</span> grid[ni][nj] <span class="keyword">in</span> keys:</span><br><span class="line">                    <span class="keyword">if</span> (ni, nj, keys) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        visited.add((ni,nj,keys))</span><br><span class="line">                        deque.append([ni, nj, steps + <span class="number">1</span>, keys, collectedKeys])</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">35</span> / <span class="number">35</span> test cases passed.</span><br><span class="line">difficulty: hard</span><br><span class="line">Runtime: <span class="number">504</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 513 Find Bottom Left Tree Value</title>
      <link href="/2018/07/07/Leetcode-513-Find-Bottom-Left-Tree-Value/"/>
      <url>/2018/07/07/Leetcode-513-Find-Bottom-Left-Tree-Value/</url>
      <content type="html"><![CDATA[<p><img src="/images/leetcode_513.png" alt=""></p><a id="more"></a><p><strong>分析：</strong></p><ol><li>这道题是要找最左下的结点，我们可以先找到最低一层，然后找到该层最左边的结点就OK了</li><li>显然bfs可以很好的完成按层查找的功能</li></ol><p><strong>思路：</strong></p><ol><li>我们使用一个None结点代表一层的遍历结束，用一个<code>lastnode</code>变量记录上一个访问的结点</li><li>如果<code>lastnode = None</code>，说明此时遍历的结点就是该层的第一个结点，即最左边的结点</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findBottomLeftValue</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 标准的bfs写法，一定要烂熟于心！</span></span><br><span class="line">        Q = collections.deque([root,<span class="keyword">None</span>])</span><br><span class="line">        lastnode,res = <span class="keyword">None</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> Q:</span><br><span class="line">            node = Q.popleft()</span><br><span class="line">            <span class="keyword">if</span> lastnode == <span class="keyword">None</span>:</span><br><span class="line">                res = node.val</span><br><span class="line">            lastnode = node</span><br><span class="line">            <span class="comment"># 处理一层结束时的情况</span></span><br><span class="line">            <span class="keyword">if</span> node == <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> Q:</span><br><span class="line">                    <span class="keyword">return</span> res</span><br><span class="line">                Q.append(<span class="keyword">None</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.left: Q.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right: Q.append(node.right)</span><br><span class="line"></span><br><span class="line"><span class="number">74</span> / <span class="number">74</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">36</span> ms,beats <span class="number">100</span>%</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 498 Diagonal Traverse</title>
      <link href="/2018/07/05/Leetcode-498-Diagonal-Traverse/"/>
      <url>/2018/07/05/Leetcode-498-Diagonal-Traverse/</url>
      <content type="html"><![CDATA[<p><img src="/images/leetcode_498_1.png" alt=""><br><a id="more"></a><br><strong>分析：</strong></p><ol><li>这道题像我们之前做的那种走迷宫的问题，给一个矩阵，0代表可以通信，1代表有障碍，问从左上走到右下最短距离是多少，走不到返回-1，这种就是标准的bfs问题</li><li>这道题中我们按层依次遍历，始终从左下到右上，只要额外判断一下本身该是从右上到左下的层数即可</li></ol><p><img src="/images/leetcode_498_2.png" alt=""></p><p><strong>思路：</strong></p><ol><li>用visited记录已经遍历过的下标，rec记录每一层的所有元素，level判断奇偶来决定是否要反转rec</li><li>用（-1，-1）作为每一层的终止条件，处理下最后只剩(-1,-1)的情况</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDiagonalOrder</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]: <span class="keyword">return</span> []</span><br><span class="line">        m,n = len(matrix),len(matrix[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        visited = set()</span><br><span class="line">        res,rec,level = [],[],<span class="number">0</span></span><br><span class="line">        Q = collections.deque([(<span class="number">0</span>,<span class="number">0</span>),(<span class="number">-1</span>,<span class="number">-1</span>)])</span><br><span class="line">        <span class="keyword">while</span> Q:</span><br><span class="line">            i,j = Q.popleft()</span><br><span class="line">            <span class="keyword">if</span> i == j == <span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">if</span> level &amp; <span class="number">1</span>: rec = rec[::<span class="number">-1</span>]</span><br><span class="line">                res.extend(rec)</span><br><span class="line">                level += <span class="number">1</span></span><br><span class="line">                rec = []</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> Q: <span class="keyword">break</span></span><br><span class="line">                Q.append((<span class="number">-1</span>,<span class="number">-1</span>))</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i,j) <span class="keyword">in</span> visited: <span class="keyword">continue</span></span><br><span class="line">            visited.add((i,j))</span><br><span class="line">            rec.append(matrix[i][j])</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>&lt;=i+<span class="number">1</span>&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=j&lt;n:</span><br><span class="line">                Q.append((i+<span class="number">1</span>,j))</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>&lt;=i&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=j+<span class="number">1</span>&lt;n:</span><br><span class="line">                Q.append((i,j+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">O(m*n) time, O(m*n) space</span><br><span class="line"><span class="number">32</span> / <span class="number">32</span> test cases passed.</span><br><span class="line">difficluty: medium</span><br><span class="line">Runtime: <span class="number">164</span> ms,beats <span class="number">100</span>%</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 503 Next Greater Element II</title>
      <link href="/2018/07/04/Leetcode-503-Next-Greater-Element-II/"/>
      <url>/2018/07/04/Leetcode-503-Next-Greater-Element-II/</url>
      <content type="html"><![CDATA[<p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p><blockquote><p>示例 1:<br>输入: [1,2,1]<br>输出: [2,-1,2]<br>解释: 第一个 1 的下一个更大的数是 2；<br>数字 2 找不到下一个更大的数；<br>第二个 1 的下一个最大的数需要循环搜索，结果也是 2。<br>注意: 输入数组的长度不会超过 10000。</p></blockquote><a id="more"></a><p><strong>分析：</strong></p><ol><li>如果你还没解决next Greater Element I，那么建议你先看一下I的解法，具体思路见<a href="https://buptwc.github.io/2018/07/03/Leetcode-496-Next-Greater-Element-I" target="_blank" rel="noopener">Leetcode-496-Next-Greater-Element-I</a>，看完之后本题解法呼之欲出</li><li>我们只需要对给定的nums数组*2即可，如示例1中nums，我们将其改成[1,2,1, 1,2,1]，用I中思想解即可</li><li>对于数组中最大的数，全设为-1即可</li></ol><p><strong>思路：</strong></p><ol><li>初始化res数组，全为-1，len(res) = len(nums) </li><li>利用栈存储数据和其下标，因为我们将nums长度翻倍了，故需判断一下下标是否小于len(res)</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElements</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> []</span><br><span class="line">        res = [<span class="number">-1</span>] * len(nums)</span><br><span class="line">        </span><br><span class="line">        nums += nums</span><br><span class="line">        stack = [(nums[<span class="number">0</span>],<span class="number">0</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> nums[i] &gt; stack[<span class="number">-1</span>][<span class="number">0</span>]:</span><br><span class="line">                val,index = stack.pop()</span><br><span class="line">                <span class="keyword">if</span> index &lt; len(res):</span><br><span class="line">                    res[index] = nums[i]</span><br><span class="line">            stack.append((nums[i],i))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="number">224</span> / <span class="number">224</span> test cases passed.</span><br><span class="line">diffculty: medium</span><br><span class="line">Runtime: <span class="number">548</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 483 Smallest Good Base</title>
      <link href="/2018/07/04/Leetcode-483-Smallest-Good-Base/"/>
      <url>/2018/07/04/Leetcode-483-Smallest-Good-Base/</url>
      <content type="html"><![CDATA[<p>对于一个正整数n，如果将n化作k进制表示后，n的所有位全是1，我们将k叫做n的一个good base<br>现在给定一个字符串代表n，要求你以字符串的形式返回n的最小good base</p><blockquote><p>Example 1:<br>Input: “13”<br>Output: “3”<br>Explanation: 13 base 3 is 111.</p></blockquote><p><code>这道题超有意思！！！</code><br><a id="more"></a></p><blockquote><p>Example 2:<br>Input: “4681”<br>Output: “8”<br>Explanation: 4681 base 8 is 11111.</p></blockquote><blockquote><p>Example 3:<br>Input: “1000000000000000000”<br>Output: “999999999999999999”<br>Explanation: 1000000000000000000 base 999999999999999999 is 11.</p></blockquote><p>Note:</p><ol><li>n的取值范围为 [3, 10^18]</li><li>给出的代表n的字符串你可以认为是始终合法的，不存在前导0的情况</li></ol><p><strong>分析：</strong></p><ol><li>对于给定的n，假设我们将其划为<code>k进制数</code>，那么k的可能取值有2，n-1，在n比较大的时候显然这种方法是会超时的</li><li>那么我们需要反向思维一下，对于给定的n，将其划为<code>长度为k</code>的字符串，即<code>&#39;1&#39;*k</code>，那么此时的k的取值最多到60，因为 2^60 &gt; 10^18，我们固定住k，去看能否找到一个x使得<code>1+x+x^2+...+x^(k-1) = n</code>，k从大往小遍历，第一个找到的x就是最小的good base</li><li>截至到上一步都很容易想到，那么关键在对于一个固定k，我们如何去计算这个x呢，根据等比数列的求和公式我们知道上式左边可化为 <code>(x^k-1)/(x-1)</code>，但这个式子是不可直接解的（虽然只有一个未知数），那么这时又需要反向思维一下了</li><li>n = 1 + x + x^2 + … + x^(k-1),对于该式，我们可以得到<ol><li>n &gt; x^(k-1)，显然</li><li>n &lt; (x+1)^(k-1)，将右边式子略作展开，显然，根据discuss中所提，这就是二项式定理</li><li>结合上面两个式子，左右同时开k-1次方，我们不妨记c为n开k-1次方的结果，则有 x &lt; c &lt; x+1</li><li>这里一要注意，3中式子是<code>严格小于</code>和<code>严格大于</code>的，并且c一定不可能是整数（想通这一点很关键，因为c是小数的话，我们只需要用int(c)即可得到x，但如果c是整数，那么x = int(c)-1，因为是严格小于)</li></ol></li><li>根据4中步骤对于每一个k可以得到一个x值，我们接下来只需要判断3中式子是否成立了，即<code>(x^k-1)/(x-1) == n</code></li></ol><p><strong>注意：</strong></p><ol><li>这道题其实是有漏洞的，因为当n&gt;10^16时，可能是和计算机内部存储数的方式有关，有：<ol><li>n^1.0 = n^1 但 n^1.0 - 1 != n^1 - 1</li></ol></li><li>这也是为什么代码中最后有一个return str(res)</li><li>时间复杂度是O(logn)，因为我确定的k&lt;60，其实就是将n默认最大，然后取2的对数得出来的结果</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallestGoodBase</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = int(n)</span><br><span class="line">        res = n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">60</span>,<span class="number">1</span>,<span class="number">-1</span>):</span><br><span class="line">            c = math.fabs(<span class="number">1.0</span>/(k<span class="number">-1</span>))</span><br><span class="line">            x = int(math.ceil(n**c<span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> x &gt; <span class="number">1</span> <span class="keyword">and</span>  (x**k<span class="number">-1</span>) // (x<span class="number">-1</span>) == n:</span><br><span class="line">                <span class="keyword">return</span> str(x)</span><br><span class="line">        <span class="keyword">return</span> str(res)</span><br><span class="line"></span><br><span class="line">O(logn) time, O(<span class="number">1</span>) space</span><br><span class="line"><span class="number">106</span> / <span class="number">106</span> test cases passed.</span><br><span class="line">Status: Accepted</span><br><span class="line">Runtime: <span class="number">42</span> ms,beats <span class="number">65.63</span>%</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 496 Next Greater Element I</title>
      <link href="/2018/07/03/Leetcode-496-Next-Greater-Element-I/"/>
      <url>/2018/07/03/Leetcode-496-Next-Greater-Element-I/</url>
      <content type="html"><![CDATA[<p>给定两个没有重复元素的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。</p><p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出-1。</p><blockquote><p>示例 1:<br>输入: nums1 = [4,1,2], nums2 = [1,3,4,2].<br>输出: [-1,3,-1]<br>解释:<br>   对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。<br>   对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。<br>   对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。</p></blockquote><a id="more"></a><blockquote><p>示例 2:<br>输入: nums1 = [2,4], nums2 = [1,2,3,4].<br>输出: [3,-1]<br>解释:<br>   对于num1中的数字2，第二个数组中的下一个较大数字是3。<br>   对于num1中的数字4，第二个数组中没有下一个更大的数字，因此输出 -1。</p></blockquote><p>注意:</p><ol><li>nums1和nums2中所有元素是唯一的。</li><li>nums1和nums2 的数组大小都不超过1000。</li></ol><p><strong>分析：</strong></p><ol><li>这道题看英文的时候有点绕，意思是对于nums1中的数，在nums2中找到其对应的位置，然后在对应位置的右侧找到第一个比其值大的数</li><li>数组中没有重复数字且长度都不超过1000，说明这道题数据要求比较低，n^2的方法也可通过</li></ol><p><strong>思路：</strong></p><ol><li>我们直接将nums2中的所有数对应的greater number找出来，用字典保存，然后遍历nums1，依次输出即可</li><li>使用一个栈来记录数据，如对于示例1中的[1,3,4,2],应按照如下步骤：<ol><li>nums[0] = 1, stack is empty , so stack = [1]</li><li>nums[1] = 3, nums[1] &gt; stack[-1],so d[1] = 3,now stack = [3]</li><li>nums[2] = 4, nums[2] &gt; stack[-1],so d[3] = 4,now stack = [4]</li><li>nums[3] = 2, nums[3] &lt; stack[-1],so stack = [4,2]</li><li>now d = {1:3, 3:4}, for num in nums1, 有key则输出对应值，没key则输出-1</li></ol></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextGreaterElement</span><span class="params">(self, findNums, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type findNums: List[int]</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>] &lt; num:</span><br><span class="line">                d[stack.pop()] = num</span><br><span class="line">            stack.append(num)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> findNums:</span><br><span class="line">            <span class="keyword">if</span> val <span class="keyword">in</span> d:</span><br><span class="line">                res.append(d[val])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">O(n) time, O(n) space</span><br><span class="line"><span class="number">17</span> / <span class="number">17</span> test cases passed.</span><br><span class="line">diffculty: easy</span><br><span class="line">Runtime: <span class="number">58</span> ms,beats <span class="number">60.10</span>%</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 495 Teemo Attacking</title>
      <link href="/2018/07/03/Leetcode-495-Teemo-Attacking/"/>
      <url>/2018/07/03/Leetcode-495-Teemo-Attacking/</url>
      <content type="html"><![CDATA[<p>在《英雄联盟》的世界中，有一个叫“提莫”的英雄，他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。现在，给出提莫对艾希的攻击时间序列和提莫攻击的中毒持续时间，你需要输出艾希的中毒状态总时长。<br>你可以认为提莫在给定的时间点进行攻击，并立即使艾希处于中毒状态。</p><blockquote><p>示例1:<br>输入: [1,4], 2<br>输出: 4<br>原因: 在第1秒开始时，提莫开始对艾希进行攻击并使其立即中毒。中毒状态会维持2秒钟，直到第2秒钟结束。<br>在第4秒开始时，提莫再次攻击艾希，使得艾希获得另外2秒的中毒时间。<br>所以最终输出4秒。</p></blockquote><a id="more"></a><blockquote><p>示例2:<br>输入: [1,2], 2<br>输出: 3<br>原因: 在第1秒开始时，提莫开始对艾希进行攻击并使其立即中毒。中毒状态会维持2秒钟，直到第2秒钟结束。<br>但是在第2秒开始时，提莫再次攻击了已经处于中毒状态的艾希。<br>由于中毒状态不可叠加，提莫在第2秒开始时的这次攻击会在第3秒钟结束。<br>所以最终输出3。</p></blockquote><p>注意：</p><ol><li>你可以假定时间序列数组的总长度不超过10000。</li><li>你可以假定提莫攻击时间序列中的数字和提莫攻击的中毒持续时间都是非负整数，并且不超过10,000,000。</li></ol><p><strong>分析：</strong></p><ol><li>上单提莫有什么用？</li><li>艾希600码的手，提莫还上去A呢，不先被艾希射炸？</li><li>@今が最高 我猜你段位不超过青铜，嘻嘻</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPoisonedDuration</span><span class="params">(self, timeSeries, duration)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type timeSeries: List[int]</span></span><br><span class="line"><span class="string">        :type duration: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> timeSeries: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        timeSeries.sort()</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(timeSeries)):</span><br><span class="line">            res += min(duration, timeSeries[i]-timeSeries[i<span class="number">-1</span>])</span><br><span class="line">        <span class="comment"># 上面循环没有计算最后一次中毒</span></span><br><span class="line">        <span class="keyword">return</span> res + duration</span><br><span class="line"></span><br><span class="line">O(nlogn) time, O(<span class="number">1</span>) space</span><br><span class="line"><span class="number">39</span> / <span class="number">39</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">183</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Leetcode 416 Partition Equal Subset Sum</title>
      <link href="/2018/07/03/Leetcode-416-Partition-Equal-Subset-Sum/"/>
      <url>/2018/07/03/Leetcode-416-Partition-Equal-Subset-Sum/</url>
      <content type="html"><![CDATA[<p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>注意:<br>每个数组中的元素不会超过 100<br>数组的大小不会超过 200</p><blockquote><p>示例 1:<br>输入: [1, 5, 11, 5]<br>输出: true<br>解释: 数组可以分割成 [1, 5, 5] 和 [11].</p></blockquote><a id="more"></a><blockquote><p>示例 2:<br>输入: [1, 2, 3, 5]<br>输出: false<br>解释: 数组不能分割成两个元素和相等的子集.</p></blockquote><p><strong>分析：</strong></p><ol><li>首先，若sum(nums) % 2 != 0，则显然不可分</li><li>题目演变成在数组中找寻是否有若干个数的和为target，target = sum(nums) / 2</li><li>数组大小不超过200，元素不超过100，则target大小不超过20000</li></ol><p><strong>思路：</strong></p><ol><li>建立dp数组，其中dp[i] = 1表示nums中有若干数的和为i，则最后返回dp[target]即可，初始化dp[0] = 1</li><li>依次对nums中的数进行分析，如示例1中[1,5,11,5]，首先对nums[0]进行分析，则可得出dp[1] = 1(因为dp[0] = 1)，然后对nums[1]进行分析，则可得出dp[5] = 1,dp[6] = 1(因为dp[0] = 1,dp[1] = 1)，依次类推</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        s = sum(nums)</span><br><span class="line">        <span class="keyword">if</span> s &amp; <span class="number">1</span>: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        target = s / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        dp = [<span class="number">0</span>] * (target+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(nums)):</span><br><span class="line">        <span class="comment"># 必须反向遍历，正向遍历会出现错误</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(target,nums[i]<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> dp[j-nums[i]]: dp[j] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">False</span>,<span class="keyword">True</span>][dp[target]]</span><br><span class="line"></span><br><span class="line"><span class="number">104</span> / <span class="number">104</span> test cases passed.</span><br><span class="line">diffculty: medium</span><br><span class="line">Runtime: <span class="number">926</span> ms,beats <span class="number">63.91</span>%</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 494 Target Sum</title>
      <link href="/2018/07/03/Leetcode-494-Target-Sum/"/>
      <url>/2018/07/03/Leetcode-494-Target-Sum/</url>
      <content type="html"><![CDATA[<p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p><p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><blockquote><p>示例 1:<br>输入: nums: [1, 1, 1, 1, 1], S: 3<br>输出: 5<br>解释:<br>-1+1+1+1+1 = 3<br>+1-1+1+1+1 = 3<br>+1+1-1+1+1 = 3<br>+1+1+1-1+1 = 3<br>+1+1+1+1-1 = 3<br>一共有5种方法让最终目标和为3。</p></blockquote><a id="more"></a><p>注意:</p><ol><li>数组的长度不会超过20，并且数组中的值全为正数。</li><li>初始的数组的和不会超过1000。</li><li>保证返回的最终结果为32位整数。</li></ol><p><strong>分析：</strong></p><ol><li>这道题可以单纯的用暴力法解决，也就是对每个元素分别进行一次正负的累加，复杂度为2^n，因为n不超过20，故也就100w左右，但是在leetcode上同样的解法c++和java可以通过，python是无法通过的</li><li>这里介绍discuss里一位大神提出来的超帅的数学解法，这道题中我们加正负号无非是将nums分为两个子集<code>p</code>,<code>n</code>，p中元素全部加<code>正号</code>，n中元素全部加<code>负号</code>，使得<code>sum(p) - sum(n) = S</code>，而本身又有<code>sum(p) + sum(n) = sum(nums)</code>，故两式相加化简得<code>sum(p) = (sum(nums)+S) / 2</code></li><li>那么这个式子直接给出了一个信息，也就是如果能找到p，则必有<code>sum(nums)+S % 2 == 0</code>这个条件，这个条件可以帮我们快速判断是否有解。</li><li>那么此时题目就变成给定一个数组nums，求有多少组不同的p，使得sum(p) = target，直接dp可解</li></ol><p><strong>思路：</strong></p><ol><li>建立dp，dp[i] = j代表数组nums中有j组子集的和为i，初始dp[0] = 1</li><li>如nums = [1,1,1,1,1]，按照如下步骤分析<ol><li>对nums[0]分析，则得dp[1] = 1(因为dp[0] = 1)</li><li>对nums[1]分析，则得dp[1] = 2,dp[2] = 1(因为dp[0] = 1,dp[1] = 1)</li><li>对nums[2]分析，则得dp[1] = 3,dp[2] = 2,d[3] = 1,依次类推</li></ol></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span><span class="params">(self, nums, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type S: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> sum(nums) &lt; S: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (sum(nums) + S) &amp; <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        target = (sum(nums) + S) / <span class="number">2</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (target+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">for</span> val <span class="keyword">in</span> range(target, nums[i]<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> dp[val-nums[i]]:</span><br><span class="line">                    dp[val] += dp[val-nums[i]]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">O(n*sum(nums)) time, O(sum(nums)) space</span><br><span class="line"><span class="number">139</span> / <span class="number">139</span> test cases passed.</span><br><span class="line">diffculty: medium</span><br><span class="line">Runtime: <span class="number">91</span> ms,beats <span class="number">95.24</span>%</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dp </tag>
            
            <tag> backtracking </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 491 Increasing Subsequences</title>
      <link href="/2018/07/03/Leetcode-491-Increasing-Subsequences/"/>
      <url>/2018/07/03/Leetcode-491-Increasing-Subsequences/</url>
      <content type="html"><![CDATA[<p>给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。</p><blockquote><p>示例:<br>输入: [4, 6, 7, 7]<br>输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]</p></blockquote><a id="more"></a><p>说明:</p><ol><li>给定数组的长度不会超过15。</li><li>数组中的整数范围是 [-100,100]。</li><li>给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。</li></ol><p><strong>分析：</strong></p><ol><li>如果你看出来这道题和最长上升子序列是一模一样的话那么答案做出来也就不难了，这也是为什么我把这道题归入dp类的原因</li><li>我们可以先思考一下LIS问题是怎么处理的，我们使用dp[i]表示前i个数字组成的序列中以nums[i]结尾的最长上升子序列的长度，dp[i] = max([dp[j]+1 for j in range(i) if nums[j] &lt; nums[i]]) </li><li>根据这个思路我们可以想到这道题其实也可以用一样的方法，我们使用一个字典d，d[i]表示以nums[i]结尾的上升子序列，初始化所有的d[i] = [[nums[i]]]</li><li>则可获得递推式 d[i].append(l+nums[i]) for j in range(i) if nums[j] &lt;= nums[i] for l in d[j] </li><li>当然严格来说上式不能算是递推式，我们直接用给出的具体实例来看一下是怎么运作的，初始化d = {0:[[4]],1:[[6]],2:[[7]],3:[[7]]}，我们从1开始分析，nums[1] &gt; nums[0]，所以d[1] = [[6],[4,6]]，依次类推d[2] = [[4,7],[6,7],[4,6,7]]，d[3] = …</li></ol><p><strong>思路：</strong></p><ol><li>递推式如分析中所示，但考虑到4,6,7,7,7这种情况，计算第三个7的时候会出现重复情况，所以用一个集合来确保答案中没有重复元素，然后又因为list本身不可hash，所以转化成元祖来进行hash即可</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSubsequences</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 初始化字典</span></span><br><span class="line">        d = &#123;i:[[nums[i]]] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt;= nums[j]:</span><br><span class="line">                    <span class="keyword">for</span> l <span class="keyword">in</span> d[j]:</span><br><span class="line">                        d[i].append(l+[nums[i]])</span><br><span class="line">        </span><br><span class="line">        s = set()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">for</span> l <span class="keyword">in</span> d[i]:</span><br><span class="line">            <span class="comment"># 因为字典中本身存在长度为1的list，需要我们排除</span></span><br><span class="line">                <span class="keyword">if</span> len(l) &lt; <span class="number">2</span>: <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> tuple(l) <span class="keyword">in</span> s: <span class="keyword">continue</span></span><br><span class="line">                s.add(tuple(l))</span><br><span class="line">                res.append(l)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="number">57</span> / <span class="number">57</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">984</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 862 Shortest Subarray with Sum at Least K</title>
      <link href="/2018/07/02/Leetcode-862-Shortest-Subarray-with-Sum-at-Least-K/"/>
      <url>/2018/07/02/Leetcode-862-Shortest-Subarray-with-Sum-at-Least-K/</url>
      <content type="html"><![CDATA[<p>Return the length of the shortest, non-empty, contiguous subarray of A with sum at least K.<br>If there is no non-empty subarray with sum at least K, return -1.</p><blockquote><p>Example 1:<br>Input: A = [1], K = 1<br>Output: 1</p></blockquote><blockquote><p>Example 2:<br>Input: A = [1,2], K = 4<br>Output: -1</p></blockquote><a id="more"></a><blockquote><p>Example 3:<br>Input: A = [2,-1,2], K = 3<br>Output: 3</p></blockquote><p>Note:</p><ol><li>1 &lt;= A.length &lt;= 50000</li><li>-10 ^ 5 &lt;= A[i] &lt;= 10 ^ 5</li><li>1 &lt;= K &lt;= 10 ^ 9</li></ol><p><strong>这题思路来源于@lee215大神，我没想到用队列来保存下标，只想到了哪些数可以不考虑（见分析第2步中提到的假设）</strong></p><p><strong>分析：</strong></p><ol><li>显然，我们会想到使用dp[i]记录sum(A[:i])，那么这道题就变成了，给定一个数组dp,找到一组i,j，使得dp[j]-dp[i]&gt;=K，且j-i尽量小！</li><li>数据长度达到50000，显然不能使用O(n^2)复杂度的方法，我们得想办法让i,j只走一遍</li><li>用一个简单的示例来分析，设 A = [4,-1,2,3],，K = 5，那么dp = [0,4,3,5,8]，我们从dp数组的第2个数开始分析，（假设来了个-1，那么因为-1比0小，后面任意一个数val如若满足val-0&gt;K,那么val+1也一定大于K，且-1所在的位置i显然能获得更优解，所以0这个位置就失去了意义），现在考虑示例，来了个4，我们发现4-0小于5，我们怎么对4进行处理呢，因为考虑到之后或许会出现一个足够大的数，比如9，那么4相对于0是更优的，但也有可能只来一个8，那么4就没作用了，所以先暂且保留观察。等到来了一个5以上的数，我们依次对保留的数（目前是0，4）进行判断得最优解。</li><li>接下来来了个3，那么根据上面提到的论点，4将会被舍弃，但3比0要大，故此时0，3保留。</li><li>然后来了个5，5-0&gt;=5，故找到一组i,j，记录下来，然后判断 5-3&gt;=5 ?如若确实大于，即再次找到一组i,j，若小于，则5保留（考虑到之后或许来了个10），依次类推</li></ol><p><strong>思路：</strong></p><ol><li>建立一个队列记录保留数字，初始为0</li><li>依次对dp中的数进行分析，如果dp[i] - dp[Q[0]] &gt;= K，则记录一次i,j</li><li>如果dp[i] &lt; dp[Q[-1]]，则舍弃Q[-1]</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestSubarray</span><span class="params">(self, A, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 如若有比K大的数，则直接返回1</span></span><br><span class="line">        <span class="keyword">if</span> max(A) &gt;= K: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 记录和，dp[i] = sum(A[:i])</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (len(A)+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(dp)):</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + A[i<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        res = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="comment"># 初始化队列</span></span><br><span class="line">        Q = Queue.deque([<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(dp)):</span><br><span class="line">        <span class="comment"># 思路中第2步</span></span><br><span class="line">            <span class="keyword">while</span> Q <span class="keyword">and</span> dp[i]-dp[Q[<span class="number">0</span>]] &gt;= K:</span><br><span class="line">                res = min(res,i-Q.popleft())</span><br><span class="line">            <span class="comment"># 思路中第3步</span></span><br><span class="line">            <span class="keyword">while</span> Q <span class="keyword">and</span> dp[i]&lt;dp[Q[<span class="number">-1</span>]]:</span><br><span class="line">                Q.pop()</span><br><span class="line">            Q.append(i) </span><br><span class="line">        <span class="keyword">return</span> [res,<span class="number">-1</span>][res==float(<span class="string">'inf'</span>)]</span><br><span class="line"></span><br><span class="line">O(n) time, O(n) space</span><br><span class="line"><span class="number">93</span> / <span class="number">93</span> test cases passed.</span><br><span class="line">difficulty: hard</span><br><span class="line">Runtime: <span class="number">693</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
            <tag> two pointers </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 863 All Nodes Distance K in Binary Tree</title>
      <link href="/2018/07/02/Leetcode-863-All-Nodes-Distance-K-in-Binary-Tree/"/>
      <url>/2018/07/02/Leetcode-863-All-Nodes-Distance-K-in-Binary-Tree/</url>
      <content type="html"><![CDATA[<p><img src="/images/leetcode_863_1.png" alt=""><br><a id="more"></a><br><strong>这道题思想非常简单，但是可能我代码写得有点复杂（因为我回溯用的不好），先着重看思路把，代码实现方法尽量讲一讲</strong></p><p><strong>分析：</strong></p><ol><li>我们先考虑最简单的情况，如果根结点就是目标节点，那么找离根结点距离为K的结点很容易，使用bfs找到第k层所有结点即可，现在定义getAns(root,K)来处理这种情况！</li><li>如下图，如果我们找到目标结点设为self.root，那么圆圈所圈部分中的结果，可直接用getAns(self.root,K)得到<br><img src="/images/leetcode_863_2.png" alt=""></li><li>那么圆圈外的部分，我们应该怎么得到呢？如果我们能想办法将圆圈外的部分也化为以目标节点为根节点的形式就直接解决了， 这次看一个复杂的情形，我们需要把圆圈内所有箭头（即目标节点至根结点路径中所有箭头）反转，才能构建出我们想要的形式，构建完之后使用getAns(self.root,K)计算结果。<br><img src="/images/leetcode_863_3.png" alt=""></li></ol><p><strong>思路：</strong><br><strong>着重讲下search()函数</strong></p><ol><li>当我们找到目标节点后，先计算一次结果，如分析中第2步。然后将其左右孩子全部抹去，将其本身父结点设为其孩子节点。</li><li>而为了尽量不改变父节点本身的结构，如左孩子为目标节点，则将父结点的left先指向None,方便之后再指向父节点的父节点，依次类推。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 别看代码挺长的，其实search()函数里面做的事是重复的，只是分了左右节点而已，思路还是比较明朗</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.res = []</span><br><span class="line">        self.root = <span class="keyword">None</span></span><br><span class="line">        self.visited = set()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distanceK</span><span class="params">(self, root, target, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type target: TreeNode</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> target: <span class="keyword">return</span> self.getAns(root, K)</span><br><span class="line">        self.search(root, target,K)</span><br><span class="line">        self.res += self.getAns(self.root, K)</span><br><span class="line">        <span class="keyword">return</span> list(set(self.res))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 当根节点为目标节点时，使用bfs找到第k层的所有节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getAns</span><span class="params">(self,root,K)</span>:</span></span><br><span class="line">        Q = Queue.deque([(root,<span class="number">0</span>)])</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> Q:</span><br><span class="line">            node,level = Q.popleft()</span><br><span class="line">            <span class="keyword">if</span> level == K:</span><br><span class="line">                res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                Q.append((node.left,level+<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                Q.append((node.right,level+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 找到目标节点并设为根节点，然后转换树结构</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self,root,target,K)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        l = self.search(root.left,target,K)</span><br><span class="line">        r = self.search(root.right, target,K)</span><br><span class="line">        <span class="comment"># 找到目标节点，先进行一次计算，然后转换树结构</span></span><br><span class="line">        <span class="comment"># 将其父节点放入visited，表明这是待转换路径中的节点</span></span><br><span class="line">        <span class="keyword">if</span> l <span class="keyword">is</span> target:</span><br><span class="line">            self.root = l</span><br><span class="line">            self.res = self.getAns(l,K)</span><br><span class="line">            l.left = <span class="keyword">None</span></span><br><span class="line">            l.right = root</span><br><span class="line">            root.left = <span class="keyword">None</span></span><br><span class="line">            self.visited.add(root)</span><br><span class="line">        <span class="keyword">if</span> r <span class="keyword">is</span> target:</span><br><span class="line">            self.root = r</span><br><span class="line">            self.res = self.getAns(r,K)</span><br><span class="line">            r.right = <span class="keyword">None</span></span><br><span class="line">            r.left = root</span><br><span class="line">            root.right = <span class="keyword">None</span></span><br><span class="line">            self.visited.add(root)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 找到待转换路径中的节点，转换树结构，再将父节点加入visited，依次类推</span></span><br><span class="line">        <span class="comment"># 如思路中第2点所说，尽量不改变父节点本身结构，所有需判断一下</span></span><br><span class="line">        <span class="keyword">if</span> l <span class="keyword">in</span> self.visited:</span><br><span class="line">            <span class="keyword">if</span> l.left == <span class="keyword">None</span>:</span><br><span class="line">                l.left = root</span><br><span class="line">            <span class="keyword">elif</span> l.right == <span class="keyword">None</span>:</span><br><span class="line">                l.right = root</span><br><span class="line">            root.left = <span class="keyword">None</span></span><br><span class="line">            self.visited.add(root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> r <span class="keyword">in</span> self.visited:</span><br><span class="line">            <span class="keyword">if</span> r.left == <span class="keyword">None</span>:</span><br><span class="line">                r.left = root</span><br><span class="line">            <span class="keyword">elif</span> r.right == <span class="keyword">None</span>:</span><br><span class="line">                r.right = root</span><br><span class="line">            root.right = <span class="keyword">None</span></span><br><span class="line">            self.visited.add(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">57</span> / <span class="number">57</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">50</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> bfs </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 861 Score After Flipping Matrix</title>
      <link href="/2018/07/02/Leetcode-861-Score-After-Flipping-Matrix/"/>
      <url>/2018/07/02/Leetcode-861-Score-After-Flipping-Matrix/</url>
      <content type="html"><![CDATA[<p>We have a two dimensional matrix A where each value is 0 or 1.<br>A move consists of choosing any row or column, and toggling each value in that row or column: changing all 0s to 1s, and all 1s to 0s.<br>After making any number of moves, every row of this matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers.<br>Return the highest possible score.</p><blockquote><p>Example 1:<br>Input: [[0,0,1,1],[1,0,1,0],[1,1,0,0]]<br>Output: 39<br>Explanation:<br>Toggled to [[1,1,1,1],[1,0,0,1],[1,1,1,1]].<br>0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39</p></blockquote><a id="more"></a><p>Note:</p><ol><li>1 &lt;= A.length &lt;= 20</li><li>1 &lt;= A[0].length &lt;= 20</li><li>A[i][j] is 0 or 1.</li></ol><p><strong>分析：</strong></p><ol><li>一个二维矩阵A，我们对其进行两种操作，一种是将某一列中的0，1全部反转，一种是将某一行的0，1全部反转</li><li>进行若干次操作后按照每一行的数将其变为二进制数，使得所有行求和最大</li><li>如果我们单分析一行，如例子中第一行，0011，我们知道在四位二进制数中后三位的和为7，第一位就有8，所以可以断定在最优情况下，首位数字必要变成1，所有行同理（贪心）。</li><li>当第一位全为1后，根据贪心我们想使第二位尽量多1，此时只能改列（改行可能使首位数字变动），也就是对于第二列，如果1的数量比0少，那么我们就进行一次列反转，反之就不进行操作，之后每一列以此类推！</li></ol><p>按照上述操作后我们观察示例中矩阵A中元素变换过程，首先先将首位全部变为1，然后：<br>1 1 0 0    — — — — — — — — &gt;    1 1 0 0    — — — — — — — — &gt;    1 1 1 0 — — — — — — — — &gt;    1 1 1 1<br>1 0 1 0 — —第二列1多— — —&gt;    1 0 1 0 — —第三列0多— — —&gt;    1 0 0 0 — —第四列0多— — —&gt;    1 0 0 1<br>1 1 0 0    — — — — — — — — &gt;    1 1 0 0    — — — — — — — — &gt;    1 1 1 0    — — — — — — — — &gt;    1 1 1 1</p><p><strong>思路：</strong></p><ol><li>先判断每行第一个元素是否为0，若为0则进行一次行变换</li><li>然后对每一列进行0，1数量的判断，若0多，则进行一次列变换，也就是将1，0的个数对调</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">matrixScore</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m,n = len(A),len(A[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 行变换</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">if</span> A[i][<span class="number">0</span>] == <span class="number">1</span>: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                A[i][j] = <span class="number">1</span> - A[i][j]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 列变换</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> rows <span class="keyword">in</span> zip(*A):</span><br><span class="line">        <span class="comment"># 始终使1的个数是更大的</span></span><br><span class="line">            cnt1 = max(rows.count(<span class="number">1</span>), rows.count(<span class="number">0</span>))</span><br><span class="line">            res += cnt1 * <span class="number">2</span>**(n<span class="number">-1</span>)</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">O(m*n) time, O(m*n) space (because of zip(*A))</span><br><span class="line"><span class="number">80</span> / <span class="number">80</span> test cases passed.</span><br><span class="line">diffculty: medium</span><br><span class="line">Runtime: <span class="number">37</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
            <tag> greedy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 860 Lemonade Change</title>
      <link href="/2018/07/01/Leetcode-860-Lemonade-Change/"/>
      <url>/2018/07/01/Leetcode-860-Lemonade-Change/</url>
      <content type="html"><![CDATA[<p>At a lemonade stand, each lemonade costs $5.<br>Customers are standing in a queue to buy from you, and order one at a time (in the order specified by bills).<br>Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill.  You must provide the correct change to each customer, so that the net transaction is that the customer pays $5.<br>Note that you don’t have any change in hand at first.<br>Return true if and only if you can provide every customer with correct change.</p><blockquote><p>Example 1:<br>Input: [5,5,5,10,20]<br>Output: true<br>Explanation:<br>From the first 3 customers, we collect three $5 bills in order.<br>From the fourth customer, we collect a $10 bill and give back a $5.<br>From the fifth customer, we give a $10 bill and a $5 bill.<br>Since all customers got correct change, we output true.</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: [5,5,10]<br>Output: true</p></blockquote><blockquote><p>Example 3:<br>Input: [10,10]<br>Output: false</p></blockquote><blockquote><p>Example 4:<br>Input: [5,5,10,10,20]<br>Output: false<br>Explanation:<br>From the first two customers in order, we collect two $5 bills.<br>For the next two customers in order, we collect a $10 bill and give back a $5 bill.<br>For the last customer, we can’t give change of $15 back because we only have two $10 bills.<br>Since not every customer received correct change, the answer is false.</p></blockquote><p><strong>Note:</strong></p><ol><li>0 &lt;= bills.length &lt;= 10000</li><li>bills[i] will be either 5, 10, or 20.</li></ol><p><strong>分析：</strong></p><ol><li>一个物品5美元，每个人依次来买，且只买一个</li><li>你初始没钱，要保证每个顾客你都能立即完成找钱操作</li><li>顾客给的钱只会是5,10,20，数据长度达到10000，说明O(n^2)复杂度不可行</li></ol><p><strong>思路：</strong></p><ol><li>如果顾客给的是5元，那么不用做任何操作，直接收下即可</li><li>如果顾客给的是10元，那么需要找一个5元</li><li>如果顾客给的是20元，那么我们有两种选择，一种是找一个5元和一个10元，一种是找三个5元，那么显然因为5元更加灵活（可以用来应对10元情况），所以我们应当优先用第一种找钱方法。</li><li>用一个字典记录5元，10元的个数，当剩余钱数不够找即return False!</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lemonadeChange</span><span class="params">(self, bills)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type bills: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        d = &#123;<span class="number">5</span>:<span class="number">0</span>,<span class="number">10</span>:<span class="number">0</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> bills:</span><br><span class="line">            <span class="comment"># 5元情况</span></span><br><span class="line">            <span class="keyword">if</span> val == <span class="number">5</span>:</span><br><span class="line">                d[<span class="number">5</span>] += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 10元情况，找一个5元</span></span><br><span class="line">            <span class="keyword">elif</span> val == <span class="number">10</span>:</span><br><span class="line">                <span class="keyword">if</span> d[<span class="number">5</span>]:</span><br><span class="line">                    d[<span class="number">5</span>] -= <span class="number">1</span></span><br><span class="line">                    d[<span class="number">10</span>] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="comment"># 20元情况，优先用一个10元和一个5元找钱</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> d[<span class="number">10</span>] <span class="keyword">and</span> d[<span class="number">5</span>]:</span><br><span class="line">                    d[<span class="number">10</span>] -= <span class="number">1</span></span><br><span class="line">                    d[<span class="number">5</span>] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> d[<span class="number">5</span>] &gt;= <span class="number">3</span>:</span><br><span class="line">                    d[<span class="number">5</span>] -= <span class="number">3</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="number">45</span> / <span class="number">45</span> test cases passed.</span><br><span class="line">difficulty: easy</span><br><span class="line">Runtime: <span class="number">99</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 526 Beautiful Arrangement</title>
      <link href="/2018/06/29/Leetcode-526-Beautiful-Arrangement/"/>
      <url>/2018/06/29/Leetcode-526-Beautiful-Arrangement/</url>
      <content type="html"><![CDATA[<p>假设有从 1 到 N 的 N 个整数，如果从这 N 个数字中成功构造出一个数组，使得数组的第 i 位 (1 &lt;= i &lt;= N) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列。条件：<br>第 i 位的数字能被 i 整除<br>i 能被第 i 位上的数字整除<br>现在给定一个整数 N，请问可以构造多少个优美的排列？</p><blockquote><p>示例1:<br>输入: 2<br>输出: 2<br>解释:<br>第 1 个优美的排列是 [1, 2]:<br> 第 1 个位置（i=1）上的数字是1，1能被 i（i=1）整除<br> 第 2 个位置（i=2）上的数字是2，2能被 i（i=2）整除<br>第 2 个优美的排列是 [2, 1]:<br> 第 1 个位置（i=1）上的数字是2，2能被 i（i=1）整除<br> 第 2 个位置（i=2）上的数字是1，i（i=2）能被 1 整除</p></blockquote><a id="more"></a><blockquote><p>说明:<br>N 是一个正整数，并且不会超过15。</p></blockquote><p><strong>分析：</strong></p><ol><li>当你看到N不超过15的时候，你可以在leetcode上把这个15个数的答案都测出来然后返回就完事了，当然这是开玩笑的！</li><li>这道题是标准的回溯，相当于有N个位置，我们依次往每个位置上放置数字，要满足 nums[i] % i == 0 or i % nums[i] == 0.（和N皇后问题一样，只是限制条件不同）</li><li>不妨假设N=15，那么对于第一个位置我们有15种可能，取其中一种记录（之后放置时不能使用重复数字），第二个位置我们有14种可能，第三个位置13种，依次类推。我们发现如果这样重复迭代的话计算量非常之大，因为相当于我们要遍历15!种情况，虽然因为有限制条件剪枝，但仍然太多了（N=15时会超时）</li><li>那么我们需要想到，其实对于第i个位置我们并不用遍历所有的15个数，而只要事先记录15个数中能放在i位置上的数有哪些，只遍历这一部分数（一般只有4个左右）即可，大大减少了运行时间（可以通过）</li></ol><p><strong>思路：</strong></p><ol><li>字典d[i]记录能放在i位置上的所有数</li><li>从第1个位置开始，依次分析，如若能到第N+1个位置（说明N个位置全部放置完毕），res += 1</li></ol><p>这里给出我写的两种方法，一种是没优化，直接回溯，一种是优化解法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 暴力方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self,N,index,visited=set<span class="params">()</span>)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> index == N+<span class="number">1</span>:</span><br><span class="line">            self.res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> visited <span class="keyword">and</span> (i%index==<span class="number">0</span> <span class="keyword">or</span> index % i == <span class="number">0</span>):</span><br><span class="line">                self.helper(N,index+<span class="number">1</span>,visited | set([i]))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countArrangement</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 这里我耍赖了，在自己程序中跑出15的结果，花了2s，确实会超时</span></span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">15</span>: <span class="keyword">return</span> <span class="number">24679</span></span><br><span class="line">        self.helper(N,<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line"><span class="number">15</span> / <span class="number">15</span> test cases passed.</span><br><span class="line">Difficulty:Medium</span><br><span class="line">Runtime: <span class="number">414</span> ms</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 优化解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self,N,index,d,visited=set<span class="params">()</span>)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> index == N+<span class="number">1</span>:</span><br><span class="line">            self.res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> d[index]:</span><br><span class="line">            <span class="keyword">if</span> val <span class="keyword">in</span> visited: <span class="keyword">continue</span></span><br><span class="line">            self.helper(N,index+<span class="number">1</span>,d,visited|set([val]))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countArrangement</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        d = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,N+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i%j == <span class="number">0</span> <span class="keyword">or</span> j%i == <span class="number">0</span>:</span><br><span class="line">                    d[i].append(j)</span><br><span class="line">        self.helper(N,<span class="number">1</span>,d)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">15</span> / <span class="number">15</span> test cases passed.</span><br><span class="line">Difficulty:Medium</span><br><span class="line">Runtime: <span class="number">1394</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Backtracking </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 131 Palindrome Partitioning</title>
      <link href="/2018/06/29/Leetcode-131-Palindrome-Partitioning/"/>
      <url>/2018/06/29/Leetcode-131-Palindrome-Partitioning/</url>
      <content type="html"><![CDATA[<p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。<br>返回 s 所有可能的分割方案。</p><blockquote><p>示例:<br>输入: “aab”<br>输出:<br>[<br> [“aa”,”b”],<br> [“a”,”a”,”b”]<br>]</p></blockquote><a id="more"></a><p><strong>分析：</strong></p><ol><li>这种题其实都是有固定解法的，显然partition(s)定义为s所能组成的回文字符串列表</li><li>那么我们依次截取s的前i个字符，判断其是否为回文字符串。若是，则显然 s[:i] + l for l in partition(s[i:])，就为最后的答案</li><li>例如aab,先判断第一个’a’为回文,则剩余的partition(‘ab’)会返回[[‘a’,’b’]]，然后用第一个’a’分别加上返回的值变为[[‘a’,’a’,’b’]]</li><li>然后判断前两个’aa’为回文，剩余的partition(‘b’)会返回[[‘b’]],加上变为[[‘aa’,’b’]]</li></ol><p><strong>思路：</strong></p><ol><li>定义函数isPalin(s)判断s是否为回文字符串</li><li>设定递归终止条件</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isPalin</span><span class="params">(s)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> s == s[::<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># 只要终止条件设定好，递推式一写答案自然就出来，还是有点神奇的</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">1</span>: <span class="keyword">return</span> [[s]]</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(s)):</span><br><span class="line">            <span class="keyword">if</span> isPalin(s[:i]):</span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> self.partition(s[i:]):</span><br><span class="line">                    res.append([s[:i]] + l)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 上面的递归过程没有将s本身考虑进去，因为i遍历到最后时s[i:]已经没有东西了，不存在l的话，res也就没有append操作了</span></span><br><span class="line">        <span class="keyword">if</span> isPalin(s): res.append([s])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">22</span> / <span class="number">22</span> test cases passed.</span><br><span class="line">Difficulty: Medium</span><br><span class="line">Runtime: <span class="number">196</span> ms,beats <span class="number">34.78</span>%</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> Backtracking </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 140 Word Break II</title>
      <link href="/2018/06/29/Leetcode-140-Word-Break-II/"/>
      <url>/2018/06/29/Leetcode-140-Word-Break-II/</url>
      <content type="html"><![CDATA[<p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。<br>说明：<br>分隔时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。</p><blockquote><p>示例 1：<br>输入:<br>s = “catsanddog”<br>wordDict = [“cat”, “cats”, “and”, “sand”, “dog”]<br>输出:<br>[<br> “cats and dog”,<br> “cat sand dog”<br>]</p></blockquote><a id="more"></a><blockquote><p>示例 2：<br>输入:<br>s = “pineapplepenapple”<br>wordDict = [“apple”, “pen”, “applepen”, “pine”, “pineapple”]<br>输出:<br>[<br> “pine apple pen apple”,<br> “pineapple pen apple”,<br> “pine applepen apple”<br>]<br>解释: 注意你可以重复使用字典中的单词。</p></blockquote><blockquote><p>示例 3：<br>输入:<br>s = “catsandog”<br>wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br>输出:<br>[]</p></blockquote><p><strong>分析：</strong></p><ol><li>标准的回溯思想，我们先从暴力法开始分析，直接遍历wordDict中的每个字符串word，看是否满足s.startwith(word)，若满足再重新开始遍历，这样的话时间复杂度应该是O(kn^2)，其中n为wordDict长度，k为word平均长度。这样显然复杂度太高。</li><li>那么我们容易想到，使用一个字典根据每个单词的首字母来存储，这样我们可以只遍历以s[0]开头的word，这样平均复杂度能够到O(kn)，但若wordDict中大量单词是以同一字母开头，复杂度在最坏情况下仍会是O(kn^2)。但单就这道题来说，这样优化之后是可以通过的。</li><li>在这道题中还有一点无法处理，那就是在上述最坏情况下，s实际上并不能用wordDict构建，这种情况也会导致TLE，故在开始时先判断s是否能有wordDict表示(借鉴于discuss)</li></ol><p><strong>思路：</strong></p><ol><li>定义breakable函数判断s是否可分</li><li>建立字典根据首字母存储wordDict中单词及长度(用来分片)</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s, wordDict)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type wordDict: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 回溯很简单，关键在于判断这个字符串本身是否可分，如若不能，会有大量重复计算，避免这一点就不会TLE</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">breakable</span><span class="params">()</span>:</span></span><br><span class="line">            rightmosts = [<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s) + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> last_index <span class="keyword">in</span> rightmosts:</span><br><span class="line">                    <span class="keyword">if</span> s[last_index:i] <span class="keyword">in</span> words:</span><br><span class="line">                        rightmosts.append(i)</span><br><span class="line">                        <span class="keyword">if</span> i == len(s): </span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        words = set(wordDict)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> breakable(): <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        d = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> wordDict:</span><br><span class="line">            d[word[<span class="number">0</span>]].append((word,len(word)))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 标准回溯代码写法</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(s,rec=<span class="string">''</span>,res=[])</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="comment"># rec右边多一个空格</span></span><br><span class="line">                res.append(rec.rstrip())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> word,c <span class="keyword">in</span> d[s[<span class="number">0</span>]]:</span><br><span class="line">                <span class="keyword">if</span> s.startswith(word):</span><br><span class="line">                    helper(s[c:],rec+word+<span class="string">' '</span>,res)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        helper(s,<span class="string">''</span>,res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="number">39</span> / <span class="number">39</span> test cases passed.</span><br><span class="line">difficulty: hard</span><br><span class="line">Runtime: <span class="number">52</span> ms,beats <span class="number">94.64</span>%</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> Backtracking </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python 运算符优先级顺序</title>
      <link href="/2018/06/29/python-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E9%A1%BA%E5%BA%8F/"/>
      <url>/2018/06/29/python-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E9%A1%BA%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p>最近看到几个小例子，发现自己对这块有点不是很清楚，遂记录一下。<br>以下运算符，从下至上，优先级顺序依次递增。<br><a id="more"></a></p><blockquote><p>Lambda<br>逻辑运算符: or<br>逻辑运算符: and<br>逻辑运算符:not<br>成员测试: in, not in<br>同一性测试: is, is not<br>比较: &lt;,&lt;=,&gt;,&gt;=,!=,==<br>按位或: |<br>按位异或: ^<br>按位与: &amp;<br>移位: &lt;&lt; ,&gt;&gt;<br>加法与减法: + ,-<br>乘法、除法与取余: *, / ,%<br>正负号: +x,-x</p></blockquote><p>举个例子：</p><ol><li><p><strong>+- 加减法优先级大于逻辑运算符</strong><br>>>> 2 - 2 and 1<br>0<br>>>> 2 and 1<br>1<br>>>> 0 and 1<br>0</p></li><li><p><strong>说起逻辑运算符这里就顺便提下里面的一些小细节，假若给定a,b； a&gt;0 and b&gt;0，则有：</strong><br>a and b = b<br>a or b = a<br>>>> 3 or 4<br>3<br>>>> 4 or 3<br>4<br>>>> 3 and 4<br>4<br>>>> 4 and 3<br>3</p></li></ol>]]></content>
      
      
        <tags>
            
            <tag> 知识积累 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 486 Predict the Winner</title>
      <link href="/2018/06/27/Leetcode-486-Predict-the-Winner/"/>
      <url>/2018/06/27/Leetcode-486-Predict-the-Winner/</url>
      <content type="html"><![CDATA[<p>给定一个表示分数的非负整数数组。 玩家1从数组任意一端拿取一个分数，随后玩家2继续从剩余数组任意一端拿取分数，然后玩家1拿，……。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。<br>给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。</p><blockquote><p>示例 1:<br>输入: [1, 5, 2]<br>输出: False<br>解释: 一开始，玩家1可以从1和2中进行选择。<br>如果他选择2（或者1），那么玩家2可以从1（或者2）和5中进行选择。如果玩家2选择了5，那么玩家1则只剩下1（或者2）可选。<br>所以，玩家1的最终分数为 1 + 2 = 3，而玩家2为 5。<br>因此，玩家1永远不会成为赢家，返回 False。</p></blockquote><blockquote><p>示例 2:<br>输入: [1, 5, 233, 7]<br>输出: True<br>解释: 玩家1一开始选择1。然后玩家2必须从5和7中进行选择。无论玩家2选择了哪个，玩家1都可以选择233。<br>最终，玩家1（234分）比玩家2（12分）获得更多的分数，所以返回 True，表示玩家1可以成为赢家。</p></blockquote><a id="more"></a><p>注意:</p><ol><li>1 &lt;= 给定的数组长度 &lt;= 20.</li><li>数组里所有分数都为非负数且不会大于10000000。</li><li>如果最终两个玩家的分数相等，那么玩家1仍为赢家。</li></ol><p><strong>分析：</strong></p><ol><li>显然，第一个人要么拿第1个要么拿最后1个，具体拿哪个取决于哪种拿法能拿的分数更大。</li><li>此时，我们不妨定义score(nums)代表在剩余数组为nums时，先拿的人能获得的最大分数。</li><li>故第一个人能拿到的最大分数就为score(nums)，第二个人能拿到的分数自然是sum(nums)-score(nums)。因总和不变，所以第二个人的策略是使第一个人能得到的分数尽量小！</li></ol><p><strong>思路：</strong></p><ol><li>对于score(nums)，如果len(nums) &lt;= 2，则score(nums) = max(nums)</li><li>如果len(nums)&gt;3，先拿的人可以拿nums[0]，也可以拿nums[-1]，不妨设拿的nums[0]，则此时该第二个人在nums[1:]数组先拿</li><li>第二个人可能拿nums[1]或者nums[-1]，拿哪个取决于让第一个人在剩余数组能获得的最大分数最小，即min(score(nums[2:]),score(nums[1:-1]))</li><li>依次类推，注意中间有大量重复计算，即使nums.len &lt;= 20，我们最好还是用记忆化的形式来计算，又因为list是不可哈希对象，所以先转换成tuple记录</li></ol><p><strong>补充：</strong><br>这种记忆化的递归就是dp，转换成dp更容易想清楚，这里我就不写dp方法了。<br>时间复杂度的分析很简单，观察字典d即可，我们是每递归一次就有一个新的d[nums[i:j]]，i处于(0,n-1),j处于(i+1,n-1)，故为n^2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PredictTheWinner</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(nums)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> tuple(nums) <span class="keyword">in</span> d: <span class="keyword">return</span> d[tuple(nums)]</span><br><span class="line">            <span class="keyword">if</span> len(nums) == <span class="number">1</span>: <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> len(nums) == <span class="number">2</span>: <span class="keyword">return</span> max(nums)</span><br><span class="line">            res = max(nums[<span class="number">0</span>] + min(score(nums[<span class="number">2</span>:]),score(nums[<span class="number">1</span>:<span class="number">-1</span>])), nums[<span class="number">-1</span>] + min(score(nums[<span class="number">1</span>:<span class="number">-1</span>]), score(nums[:<span class="number">-2</span>])))</span><br><span class="line">            d[tuple(nums)] = res</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        s1 = score(nums)</span><br><span class="line">        s2 = sum(nums) - s1</span><br><span class="line">        <span class="keyword">return</span> s1 &gt;= s2</span><br><span class="line"></span><br><span class="line">O(n^<span class="number">2</span>) time, O(n^<span class="number">2</span>) space</span><br><span class="line"><span class="number">61</span> / <span class="number">61</span> test cases passed.</span><br><span class="line">Difficulty: medium</span><br><span class="line">Runtime: <span class="number">40</span> ms, beats <span class="number">73.5</span>%</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 859 Buddy Strings</title>
      <link href="/2018/06/26/Leetcode-859-Buddy-Strings/"/>
      <url>/2018/06/26/Leetcode-859-Buddy-Strings/</url>
      <content type="html"><![CDATA[<p>Given two strings A and B of lowercase letters, return true if and only if we can swap two letters in A so that the result equals B.</p><blockquote><p>Example 1:<br>Input: A = “ab”, B = “ba”<br>Output: true</p></blockquote><blockquote><p>Example 2:<br>Input: A = “ab”, B = “ab”<br>Output: false</p></blockquote><blockquote><p>Example 3:<br>Input: A = “aa”, B = “aa”<br>Output: true</p></blockquote><a id="more"></a><blockquote><p>Example 4:<br>Input: A = “aaaaaaabc”, B = “aaaaaaacb”<br>Output: true</p></blockquote><blockquote><p>Example 5:<br>Input: A = “”, B = “aa”<br>Output: false</p></blockquote><p>Note:</p><ol><li>0 &lt;= A.length &lt;= 20000</li><li>0 &lt;= B.length &lt;= 20000</li><li>A and B consist only of lowercase letters.</li></ol><p><strong>分析：</strong></p><ol><li>先判断是不是组成相同</li><li>在判断不同的个数是2还是0</li><li>如果是0，判断A中有没有相同字符</li></ol><p><strong>思路：</strong><br>如果仔细写应该能写优美一点把，但是瑞了，不想写了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buddyStrings</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: str</span></span><br><span class="line"><span class="string">        :type B: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> collections.Counter(A) != collections.Counter(B):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            <span class="keyword">if</span> A[i] != B[i]:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> cnt &gt; <span class="number">2</span>: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> cnt == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> len(set(A)) != len(A)</span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">O(n) time, O(n) space</span><br><span class="line"><span class="number">20</span> / <span class="number">20</span> test cases passed.</span><br><span class="line">difficulty: easy</span><br><span class="line">Runtime: <span class="number">78</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 858 Mirror Reflection</title>
      <link href="/2018/06/26/Leetcode-858-Mirror-Reflection/"/>
      <url>/2018/06/26/Leetcode-858-Mirror-Reflection/</url>
      <content type="html"><![CDATA[<p><img src="/images/leetcode_858_1.png" alt="题目描述"></p><p><font color="#660000">这道题超有意思！</font><br><br><a id="more"></a></p><p><strong>分析：</strong></p><ol><li>我们首先需要知道镜面反射的一些小技巧，如下图，也就是我们可以作延长线来判断反射之后的线将会落于何处。<br><img src="/images/leetcode_858_2.jpg" alt="示例图1"></li><li>题目既然保证一定会碰到012中的某一个点，那么我只要疯狂做延长线，总会交于某个角</li><li>再来举个例子，如下图，p = 4,q = 3，最后落于点2处,<strong>图中虚线和实线根据标号一一对应，且保证了两线方向一致</strong><br><img src="/images/leetcode_858_3.jpg" alt="示例图2"></li><li>延长线每次交于边界点记作A,B,C,…,显然若A的横坐标为x，则B的横坐标为2x，C的横坐标为3x，依次类推，我们只需要找到某个点其横坐标恰好是p的倍数即可</li></ol><p><strong>思路：</strong></p><ol><li>显然若横坐标是x的偶数倍，说明相交点在下边界线，也就是0处！返回0即可</li><li>若横坐标是x的奇数倍，说明相交点在上边界线，或许是2，或许是1</li><li>那么显然，此时若横坐标是p的偶数倍，如示例1和示例2，最后会落于2处！</li><li>else: 落于1处！</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mirrorReflection</span><span class="params">(self, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type p: int</span></span><br><span class="line"><span class="string">        :type q: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 先找到第一个横坐标为p的倍数的点</span></span><br><span class="line">        k = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p*k % q != <span class="number">0</span>: k += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 若为x的偶数倍</span></span><br><span class="line">        <span class="keyword">if</span> k  % <span class="number">2</span> == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 分别判断p的奇数倍和偶数倍</span></span><br><span class="line">            r = p*k / q</span><br><span class="line">            <span class="keyword">if</span> r % <span class="number">2</span> == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> r % <span class="number">2</span> == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">69</span> / <span class="number">69</span> test cases passed.</span><br><span class="line">diffculty: medium</span><br><span class="line">Runtime: <span class="number">30</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 857 Minimum Cost to Hire K Workers</title>
      <link href="/2018/06/26/Leetcode-857-Minimum-Cost-to-Hire-K-Workers/"/>
      <url>/2018/06/26/Leetcode-857-Minimum-Cost-to-Hire-K-Workers/</url>
      <content type="html"><![CDATA[<p>There are N workers.  The i-th worker has a quality[i] and a minimum wage expectation wage[i].<br>Now we want to hire exactly K workers to form a paid group.  When hiring a group of K workers, we must pay them according to the following rules:<br>Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group.<br>Every worker in the paid group must be paid at least their minimum wage expectation.<br>Return the least amount of money needed to form a paid group satisfying the above conditions.</p><blockquote><p>Example 1:<br>Input: quality = [10,20,5], wage = [70,50,30], K = 2<br>Output: 105.00000<br>Explanation: We pay 70 to 0-th worker and 35 to 2-th worker.</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: quality = [3,1,10,10,1], wage = [4,8,2,2,7], K = 3<br>Output: 30.66667<br>Explanation: We pay 4 to 0-th worker, 13.33333 to 2-th and 3-th workers seperately. </p></blockquote><p>Note:</p><ol><li>1 &lt;= K &lt;= N &lt;= 10000, where N = quality.length = wage.length</li><li>1 &lt;= quality[i] &lt;= 10000</li><li>1 &lt;= wage[i] &lt;= 10000</li><li>Answers within 10^-5 of the correct answer will be considered correct.</li></ol><p><strong>分析：</strong></p><ol><li>这道题有点意思，要雇佣K个人，使得所花钱最少，雇佣需满足两个条件，一是最后给的钱必须成比例，二是不能低于最小值</li><li>我们不妨设最后雇佣时给第i个人的钱为p[i]，则对于被选上的K个人来说，都有相同的比例 p[i] / quality[i]（根据条件1）</li><li>也就是说一旦我们选定了比例 r，那么最后选的K个人一定都满足 r * quality[i] &gt; wage[i]（因为已经被选上了自然满足条件2）</li><li>上式逆推为 r &gt; (wage/quality),故我们将所有人按照 wage/quality 的大小排序，依次作为r 来判断最后的总价格。</li><li>注意N,K都达到了10000，O(n^2)的方法显然不行（绝大部分情况下）</li></ol><p><strong>思路：</strong></p><ol><li>按照wage/quality排序，若选定第i个人的比例r作为标准，那么还需从0到i-1中的人选k-1个人</li><li>对于0到i-1个人，他们每个人的价格就是quality*r，r是固定的，所以quality越小越好，所以我们用最大堆将quality大的丢弃</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mincostToHireWorkers</span><span class="params">(self, quality, wage, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type quality: List[int]</span></span><br><span class="line"><span class="string">        :type wage: List[int]</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 按比例排序,nlogn</span></span><br><span class="line">        workers = sorted([float(wage[i])/quality[i], quality[i]] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(quality)))</span><br><span class="line">        res,qsum = float(<span class="string">'inf'</span>),<span class="number">0</span></span><br><span class="line">        heap = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(workers)):</span><br><span class="line">        <span class="comment"># 选定比例 r</span></span><br><span class="line">            r,q = workers[i]</span><br><span class="line">            heapq.heappush(heap,-q)</span><br><span class="line">            <span class="comment"># qsum始终记录k个人的quality之和，乘以r即为最后结果</span></span><br><span class="line">            qsum += q</span><br><span class="line">            <span class="keyword">if</span> len(heap) &gt; K:</span><br><span class="line">            <span class="comment"># 始终丢弃quality最大的人</span></span><br><span class="line">                qsum += heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">if</span> len(heap) == K:</span><br><span class="line">                res = min(res, qsum * r)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">O(nlogn) time,O(n) space</span><br><span class="line"><span class="number">46</span> / <span class="number">46</span> test cases passed.</span><br><span class="line">difficulty: hard</span><br><span class="line">Runtime: <span class="number">320</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 856 Score of Parentheses</title>
      <link href="/2018/06/26/Leetcode-856-Score-of-Parentheses/"/>
      <url>/2018/06/26/Leetcode-856-Score-of-Parentheses/</url>
      <content type="html"><![CDATA[<p>Given a balanced parentheses string S, compute the score of the string based on the following rule:<br>() has score 1<br>AB has score A + B, where A and B are balanced parentheses strings.<br>(A) has score 2 * A, where A is a balanced parentheses string.</p><blockquote><p>Example 1:<br>Input: “()”<br>Output: 1</p></blockquote><blockquote><p>Example 2:<br>Input: “(())”<br>Output: 2</p></blockquote><a id="more"></a><blockquote><p>Example 3:<br>Input: “()()”<br>Output: 2</p></blockquote><blockquote><p>Example 4:<br>Input: “(()(()))”<br>Output: 6</p></blockquote><p>Note:</p><ol><li>S is a balanced parentheses string, containing only ( and ).</li><li>2 &lt;= S.length &lt;= 50</li></ol><p><strong>分析：</strong></p><ol><li>一个基础()得1分，被括起来是两倍，保证了S一定合法，且S的长度小于50，那么显然随意递归都OK</li></ol><p><strong>思路：</strong><br>S的第一位一定是左括号，找到与之对应的右括号，然后递归即可<br>即形如 (s1)s2，可写成 func(s1)*2 + func(s2)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scoreOfParentheses</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 设置终止条件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> S: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(S)):</span><br><span class="line">            <span class="keyword">if</span> S[i] == <span class="string">'('</span>:</span><br><span class="line">                stack.append(S[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.pop()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                    index = i</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 当已经是最基本的()时，直接返回1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> S[<span class="number">1</span>:index]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + self.scoreOfParentheses(S[index+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> self.scoreOfParentheses(S[<span class="number">1</span>:index]) * <span class="number">2</span> + self.scoreOfParentheses(S[index+<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">85</span> / <span class="number">85</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">34</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 853 Car Fleet</title>
      <link href="/2018/06/20/Leetcode-853-Car-Fleet/"/>
      <url>/2018/06/20/Leetcode-853-Car-Fleet/</url>
      <content type="html"><![CDATA[<p>N cars are going to the same destination along a one lane road.  The destination is target miles away.<br>Each car i has a constant speed speed[i]  (in miles per hour), and initial position position[i] miles towards the target along the road.</p><p>A car can never pass another car ahead of it, but it can catch up to it, and drive bumper to bumper at the same speed.</p><p>The distance between these two cars is ignored - they are assumed to have the same position.</p><p>A car fleet is some non-empty set of cars driving at the same position and same speed.  Note that a single car is also a car fleet.</p><p>If a car catches up to a car fleet right at the destination point, it will still be considered as one car fleet.<br><a id="more"></a></p><blockquote><p>Example 1:<br>Input: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]<br>Output: 3<br>Explanation:<br>The cars starting at 10 and 8 become a fleet, meeting each other at 12.<br>The car starting at 0 doesn’t catch up to any other car, so it is a fleet by itself.<br>The cars starting at 5 and 3 become a fleet, meeting each other at 6.<br>Note that no other cars meet these fleets before the destination, so the answer is 3.</p></blockquote><blockquote><p>Note:<br>0 &lt;= N &lt;= 10 ^ 4<br>0 &lt; target &lt;= 10 ^ 6<br>0 &lt; speed[i] &lt;= 10 ^ 6<br>0 &lt;= position[i] &lt; target<br>All initial positions are different.</p></blockquote><p><strong>分析：</strong></p><ol><li>这道题还有点意思，在不同的点有一系列的车，每辆车有不同的速度，都朝同一个target前进</li><li>无法超车，也就是初始位置在前面的车永远在前面</li><li>若追赶上前面的车则认为这些车属于一个集群，问到达终点后有多少个集群</li></ol><p><strong>思路：</strong></p><ol><li>显然我们先根据车的位置进行排序，从前面的车开始分析，如有A,B,C,D,E 5辆车，p[a] &gt; p[b] &gt; p[c] &gt;…</li><li>我们先判断A到达终点前是否能被B追上，若追不上显然A自身是一个集群，再从B开始判断，若能追上，则判断C能不能追上，依次类推</li><li>假设B,C都能追上A，D追不上，那么显然D也不可能追上C，我们就把D当做此时最前面的车开始分析就行了，所以是O(n),one pass，不会重复计算，但是排序本身是O(nlogn)</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">carFleet</span><span class="params">(target, p, s)</span>:</span></span><br><span class="line"><span class="comment"># 做的时候还没有note的第5条，所以处理了下初始position相同的情况</span></span><br><span class="line"><span class="comment"># d = collections.defaultdict(lambda: 10**6)</span></span><br><span class="line">n = len(p)</span><br><span class="line"><span class="comment"># for i in range(n):</span></span><br><span class="line"><span class="comment"># d[p[i]] = min(d[p[i]],s[i])</span></span><br><span class="line"><span class="comment"># 有第5条之后直接这样既可</span></span><br><span class="line">d = &#123;a:b <span class="keyword">for</span> a,b <span class="keyword">in</span> zip(p,s)&#125;</span><br><span class="line">p.sort(reverse=<span class="keyword">True</span>)</span><br><span class="line">res = n</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i + <span class="number">1</span> &lt; n:</span><br><span class="line">j = i+<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> j &lt; n <span class="keyword">and</span> (target - p[i]) / float(d[p[i]]) * d[p[j]] + p[j] &gt;= target:</span><br><span class="line">j += <span class="number">1</span></span><br><span class="line">res -= <span class="number">1</span></span><br><span class="line">i = j</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">O(nlogn) time, O(n) space</span><br><span class="line"><span class="number">44</span> / <span class="number">44</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">174</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 852 Peak Index in a Mountain Array</title>
      <link href="/2018/06/20/Leetcode-852-Peak-Index-in-a-Mountain-Array/"/>
      <url>/2018/06/20/Leetcode-852-Peak-Index-in-a-Mountain-Array/</url>
      <content type="html"><![CDATA[<p>Let’s call an array A a mountain if the following properties hold:<br>A.length &gt;= 3<br>There exists some 0 &lt; i &lt; A.length - 1 such that A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1]<br>Given an array that is definitely a mountain, return any i such that A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1].</p><blockquote><p>Example 1:<br>Input: [0,1,0]<br>Output: 1</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: [0,2,1,0]<br>Output: 1</p></blockquote><blockquote><p>Note:<br>3 &lt;= A.length &lt;= 10000<br>0 &lt;= A[i] &lt;= 10^6<br>A is a mountain, as defined above.</p></blockquote><p><strong>分析:</strong><br>最近的easy题越来越弱智了，A是一个山，而山的定义是存在i满足 A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1]<br>所以显然A[i]就是A中最大值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peakIndexInMountainArray</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> A.index(max(A))</span><br><span class="line"></span><br><span class="line">O(n) time, O(<span class="number">1</span>) space</span><br><span class="line"><span class="number">32</span> / <span class="number">32</span> test cases passed.</span><br><span class="line">difficulty: easy</span><br><span class="line">Runtime: <span class="number">61</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> array </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 481 Magical String</title>
      <link href="/2018/06/14/Leetcode-481-Magical-String/"/>
      <url>/2018/06/14/Leetcode-481-Magical-String/</url>
      <content type="html"><![CDATA[<p>A magical string S consists of only ‘1’ and ‘2’ and obeys the following rules:</p><p>The string S is magical because concatenating the number of contiguous occurrences of characters ‘1’ and ‘2’ generates the string S itself.</p><p>The first few elements of string S is the following: S = “1221121221221121122……”</p><p>If we group the consecutive ‘1’s and ‘2’s in S, it will be:<br>1 22 11 2 1 22 1 22 11 2 11 22 ……<br>and the occurrences of ‘1’s or ‘2’s in each group are:<br>1 2    2 1 1 2 1 2 2 1 2 2 ……</p><p><strong>You can see that the occurrence sequence above is the S itself.</strong><br>Given an integer N as input, return the number of ‘1’s in the first N number in the magical string S.<br><a id="more"></a></p><blockquote><p>Note: N will not exceed 100,000.</p></blockquote><blockquote><p>Example 1:<br>Input: 6<br>Output: 3<br>Explanation: The first 6 elements of magical string S is “12211” and it contains three 1’s, so return 3.</p></blockquote><p><strong>分析：</strong><br>龟龟!第二次在leetcode上写题解，beats 100%太骚了，而且血虐之后的<br><a href="https://leetcode.com/problems/magical-string/discuss/139180/python-solution-78ms-beats-100" target="_blank" rel="noopener">https://leetcode.com/problems/magical-string/discuss/139180/python-solution-78ms-beats-100%</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">s = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">index = <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> len(s) &lt; <span class="number">100000</span>:</span><br><span class="line"><span class="comment"># according to the last element, we decide the value of 'val'</span></span><br><span class="line">val = <span class="number">3</span> - s[<span class="number">-1</span>]</span><br><span class="line">s.extend([val]*s[index])</span><br><span class="line">index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">magicalString</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> s[:n].count(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">O(n) time, O(n) space</span><br><span class="line"><span class="number">65</span> / <span class="number">65</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">78</span> ms, beats <span class="number">100</span>%</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 482 License Key Formatting</title>
      <link href="/2018/06/14/Leetcode-482-License-Key-Formatting/"/>
      <url>/2018/06/14/Leetcode-482-License-Key-Formatting/</url>
      <content type="html"><![CDATA[<p>You are given a license key represented as a string S which consists only alphanumeric character and dashes. The string is separated into N+1 groups by N dashes.</p><p>Given a number K, we would want to reformat the strings such that each group contains exactly K characters, except for the first group which could be shorter than K, but still must contain at least one character. Furthermore, there must be a dash inserted between two groups and all lowercase letters should be converted to uppercase.</p><p>Given a non-empty string S and a number K, format the string according to the rules described above.<br><a id="more"></a></p><blockquote><p>Example 1:<br>Input: S = “5F3Z-2e-9-w”, K = 4<br>Output: “5F3Z-2E9W”<br>Explanation: The string S has been split into two parts, each part has 4 characters.<br>Note that the two extra dashes are not needed and can be removed.</p></blockquote><blockquote><p>Example 2:<br>Input: S = “2-5g-3-J”, K = 2<br>Output: “2-5G-3J”<br>Explanation: The string S has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above.</p></blockquote><blockquote><p>Note:<br>The length of string S will not exceed 12,000, and K is a positive integer.<br>String S consists only of alphanumerical characters (a-z and/or A-Z and/or 0-9) and dashes(-).<br>String S is non-empty.</p></blockquote><p><strong>分析：</strong></p><ol><li>题目写得挺长，实际上是将一个字符串（由’-‘连接）重新均分成若干份，每份长度为K（第一份可不够），然后用’-‘将每份连接</li><li>注意S长度不超过12000，代表这道题可以闭着眼睛写都不会超时</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 借用到python里的upper()函数直接将字符串全部大写，说实话有点耍赖了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="comment"># 弱智方法1，倒叙遍历，每遍历K个就存一下，最后连接，在出循环的时候判断一下是不是有多余的字段没存就存一下。</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">licenseKeyFormatting1</span><span class="params">(self, S, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(S)</span><br><span class="line">        rec,res = <span class="string">''</span>,[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> S[i] != <span class="string">'-'</span>:</span><br><span class="line">                rec += S[i]</span><br><span class="line">                <span class="keyword">if</span> len(rec) == K:</span><br><span class="line">                    rec = rec.upper()</span><br><span class="line">                    res.append(rec[::<span class="number">-1</span>])</span><br><span class="line">                    rec = <span class="string">''</span></span><br><span class="line">        <span class="keyword">if</span> rec: res.append(rec.upper()[::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'-'</span>.join(res[::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 好一点的方法，我直接用replace()和upper()处理字符串，然后直接连接就完事了</span></span><br><span class="line">    <span class="comment"># 如'5F3Z-2e-9-w' 直接变成 'W92EZ3F5'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">licenseKeyFormatting2</span><span class="params">(self,S,K)</span>:</span></span><br><span class="line">    S = S.replace(<span class="string">'-'</span>,<span class="string">''</span>).upper()[::<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'-'</span>.join([S[i:i+K][::<span class="number">-1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(S))[::K]][::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">Solution <span class="number">1</span>:</span><br><span class="line">O(n) time, O(n) space</span><br><span class="line"><span class="number">38</span> / <span class="number">38</span> test cases passed.</span><br><span class="line">difficulty: easy</span><br><span class="line">Runtime: <span class="number">149</span> ms,beats <span class="number">49</span>%</span><br><span class="line"></span><br><span class="line">Solution <span class="number">2</span>:</span><br><span class="line">O(n) time, O(n) space</span><br><span class="line"><span class="number">38</span> / <span class="number">38</span> test cases passed.</span><br><span class="line">difficulty: easy</span><br><span class="line">Runtime: <span class="number">46</span> ms,beats <span class="number">90</span>%</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 477 Total Hamming Distance</title>
      <link href="/2018/06/11/Leetcode-477-Total-Hamming-Distance/"/>
      <url>/2018/06/11/Leetcode-477-Total-Hamming-Distance/</url>
      <content type="html"><![CDATA[<p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.<br>Now your job is to find the total Hamming distance between all pairs of the given numbers.</p><blockquote><p>Example:<br>Input: 4, 14, 2<br>Output: 6<br>Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just<br>showing the four bits relevant in this case). So the answer will be:<br>HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.</p></blockquote><a id="more"></a><blockquote><p>Note:</p><ol><li>Elements of the given array are in the range of 0 to 10^9</li><li>Length of the array will not exceed 10^4.</li></ol></blockquote><p><strong>分析：</strong><br>在leetcode 461中有如何计算海明距离的方法，这里数据长度不超过10^4，讲道理n^2可行，但是还涉及到数据本身长度（虽然长度很短，不超过32），所以还是会tle<br>所以仔细想想，发现是可以用O(n)的方法来做的</p><p><strong>思路：</strong><br>分别观察每一位，比如所有数的最后一位，假设有m个1，n个0， 那么这一位产生的海明距离之和应该为 m * n（易证）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">totalHammingDistance</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">        <span class="comment"># 从最后一位开始</span></span><br><span class="line">            cnt, mask = <span class="number">0</span>, <span class="number">1</span> &lt;&lt; i</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="comment"># count the number of '1'</span></span><br><span class="line">                cnt += num &amp; mask != <span class="number">0</span></span><br><span class="line">            <span class="comment"># cnt '1' and (n-cnt) '0', the distance is the product!</span></span><br><span class="line">            res += cnt * (len(nums)-cnt)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># O(n) time, O(1) space</span></span><br><span class="line"><span class="number">47</span> / <span class="number">47</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">337</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> bit </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 371 Sum of Two Integer</title>
      <link href="/2018/06/11/Leetcode-371-Sum-of-Two-Integer/"/>
      <url>/2018/06/11/Leetcode-371-Sum-of-Two-Integer/</url>
      <content type="html"><![CDATA[<p>Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.</p><p>Example:<br>Given a = 1 and b = 2, return 3.<br><a id="more"></a></p><p><strong>分析：</strong><br>摆明着要用位运算，那么很容易想到只有在这种情况下 101 ^ 010 = 111（即a&amp;b=0），^操作符等价于+操作符<br>那么就把a拆开，分为 和b一样的部分和 以及 和b完全不一样的部分</p><p><strong>思路：</strong><br>用&amp;操作符取出相同部分，而相同部分相加等价于左移操作符，用^直接把不同部分的结果加出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getSum</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type a: int</span></span><br><span class="line"><span class="string">        :type b: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> a <span class="keyword">if</span> <span class="keyword">not</span> b <span class="keyword">else</span> self.getSum(a^b,(a&amp;b)&lt;&lt;<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># O(1) time O(1) space </span></span><br><span class="line"><span class="number">13</span> / <span class="number">13</span> test cases passed.</span><br><span class="line">difficulty: easy</span><br><span class="line">Runtime: <span class="number">30</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> bit </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 318 Maximum Product of Word Lengths</title>
      <link href="/2018/06/11/Leetcode-318-Maximum-Product-of-Word-Lengths/"/>
      <url>/2018/06/11/Leetcode-318-Maximum-Product-of-Word-Lengths/</url>
      <content type="html"><![CDATA[<p>Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0.</p><blockquote><p>Example 1:<br>Input: [“abcw”,”baz”,”foo”,”bar”,”xtfn”,”abcdef”]<br>Output: 16<br>Explanation: The two words can be “abcw”, “xtfn”.</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: [“a”,”ab”,”abc”,”d”,”cd”,”bcd”,”abcd”]<br>Output: 4<br>Explanation: The two words can be “ab”, “cd”.</p></blockquote><blockquote><p>Example 3:<br>Input: [“a”,”aa”,”aaa”,”aaaa”]<br>Output: 0<br>Explanation: No such pair of words.</p></blockquote><p><strong>分析：</strong><br>在列表中找两个字符串使得这两个字符串的长度乘积最大，这两个字符串必须满足没有相同字符。<br>算乘积一个n^2即可，关键在于限制条件，我们固然可以用set来记录字符串然后用 &amp;操作符判断，但是就有点小蠢，空间也相对花费较大<br>因为只有26个英文字母，我们完全可以用26位长的数字来表示，1代表有，0代表没有，&amp;操作也方便<br>这种用数字表示字母的思想是一种很经典的思路，已经不止见到过一次了，得记住！</p><p><strong>思路：</strong><br>用一个数组记录长度，用一个数组记录位表示，n^2复杂度解决</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(words)</span><br><span class="line">        l = [<span class="number">0</span>] * n</span><br><span class="line">        mask = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            l[i] = len(words[i])</span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> words[i]:</span><br><span class="line">                mask[i] |= <span class="number">1</span> &lt;&lt; (ord(c)-ord(<span class="string">'a'</span>))</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> mask[i] &amp; mask[j]:</span><br><span class="line">                    res = max(res,l[i] * l[j])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># O(n^2) time, O(n) space</span></span><br><span class="line"><span class="number">174</span> / <span class="number">174</span> test cases passed.</span><br><span class="line">dfficulty: medium</span><br><span class="line">Runtime: <span class="number">409</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> bit </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 476 Number Complement</title>
      <link href="/2018/06/11/Leetcode-476-Number-Complement/"/>
      <url>/2018/06/11/Leetcode-476-Number-Complement/</url>
      <content type="html"><![CDATA[<p>Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.<br><strong>Note:</strong><br>The given integer is guaranteed to fit within the range of a 32-bit signed integer.<br>You could assume no leading zero bit in the integer’s binary representation.<br><a id="more"></a></p><blockquote><p>Example 1:<br>Input: 5<br>Output: 2<br>Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.</p></blockquote><blockquote><p>Example 2:<br>Input: 1<br>Output: 0<br>Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.</p></blockquote><p><strong>分析：</strong><br>就是求一个数的反码，还保证了是32bit的数</p><p><strong>思路：</strong><br>这里介绍两种方法：</p><ol><li>用Python内置的bin()函数获得Num的二进制表示形式，然后’0’ ‘1’互换即可</li><li>101 -&gt; 010， 我们可以发现其实就是找0的位置，想到用全1的数来进行异或操作, 即101 ^ 111 = 010</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串转换</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findComplement</span><span class="params">(num)</span>:</span></span><br><span class="line">s = bin(nums)</span><br><span class="line">res = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> s[<span class="number">2</span>:]:</span><br><span class="line">res += str(<span class="number">1</span>-int(e))</span><br><span class="line"><span class="keyword">return</span> int(res,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 异或操作</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findComplement</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> num ^ ((<span class="number">1</span>&lt;&lt;num.bit_length())<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">149</span> / <span class="number">149</span> test cases passed.</span><br><span class="line">dfficulty: easy</span><br><span class="line">Runtime: <span class="number">35</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 851 Loud and Rich</title>
      <link href="/2018/06/11/Leetcode-851-Loud-and-Rich/"/>
      <url>/2018/06/11/Leetcode-851-Loud-and-Rich/</url>
      <content type="html"><![CDATA[<p>In a group of N people (labelled 0, 1, 2, …, N-1), each person has different amounts of money, and different levels of quietness.<br>For convenience, we’ll call the person with label x, simply “person x”.<br>We’ll say that richer[i] = [x, y] if person x definitely has more money than person y.  Note that richer may only be a subset of valid observations.<br>Also, we’ll say quiet[x] = q if person x has quietness q.<br>Now, return answer, where answer[x] = y if y is the least quiet person (that is, the person y with the smallest value of quiet[y]), among all people who definitely have equal to or more money than person x.<br><a id="more"></a></p><blockquote><p>Example 1:<br>Input: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]<br>Output: [5,5,2,5,4,5,6,7]<br>Explanation:<br>answer[0] = 5.<br>Person 5 has more money than 3, which has more money than 1, which has more money than 0.<br>The only person who is quieter (has lower quiet[x]) is person 7, but<br>it isn’t clear if they have more money than person 0.<br>answer[7] = 7.<br>Among all people that definitely have equal to or more money than person 7<br>(which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet[x])<br>is person 7.<br>The other answers can be filled out with similar reasoning.</p></blockquote><blockquote><p>Note:<br>1 &lt;= quiet.length = N &lt;= 500<br>0 &lt;= quiet[i] &lt; N, all quiet[i] are different.<br>0 &lt;= richer.length &lt;= N * (N-1) / 2<br>0 &lt;= richer[i][j] &lt; N<br>richer[i][0] != richer[i][1]<br>richer[i]’s are all different.<br>The observations in richer are all logically consistent.</p></blockquote><p><strong>分析：</strong></p><ol><li>人的编号从0到n-1，每个人有一定的钱和度，并且都不相同</li><li>返回ans，ans[i]代表比i这个人钱多的人中，度最小的人的编号</li><li>数据（节点）长度500，边长度不超过250000，故显然对边分析时，n^2复杂度不可行</li></ol><p><strong>思路：</strong><br>对于每个人可以直接用dfs找，但是也得用dp存一下。topsort也是一样，都得用dp。由于我对dfs还是运用不到位，这里先写下topsort方法吧。<br>对于example中的例子，关系如图：<br><img src="/images/leetcode_851.jpg" alt=""><br>可以看到2，4，5，6入度为0，即没有比他们更多钱的人，那么对于这种节点 ,ans[i] = i<br>对于3,则要从指向他的节点（4，5，6）以及他自身中找到quiet值最小的点index,ans[3] = min(3,4,5,6,key=lambda x: quiet[ans[x]]) ,依次类推即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections,Queue</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loudAndRich</span><span class="params">(richer, quiet)</span>:</span></span><br><span class="line"><span class="comment"># 存储形式 节点： 指向该节点的节点</span></span><br><span class="line">d = collections.defaultdict(list)</span><br><span class="line"><span class="comment"># 存储形式 节点： 该节点指向的节点</span></span><br><span class="line">d1 = collections.defaultdict(list)</span><br><span class="line"><span class="comment"># 记录入度</span></span><br><span class="line">count = [<span class="number">0</span>] * len(quiet)</span><br><span class="line">ans = [float(<span class="string">'inf'</span>)] * len(quiet)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x,y <span class="keyword">in</span> richer:</span><br><span class="line">count[y] += <span class="number">1</span></span><br><span class="line">d[y].append(x)</span><br><span class="line">d1[x].append(y)</span><br><span class="line"><span class="comment"># 取入度为0的点</span></span><br><span class="line">Q = Queue.deque([i <span class="keyword">for</span> i <span class="keyword">in</span> range(len(quiet)) <span class="keyword">if</span> count[i] == <span class="number">0</span>])</span><br><span class="line"><span class="keyword">while</span> Q:</span><br><span class="line">node = Q.popleft()</span><br><span class="line"><span class="comment"># 先默认结果为自身，然后和指向自身的节点依次比较</span></span><br><span class="line">res = node</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> d[node]:</span><br><span class="line"><span class="keyword">if</span> quiet[ans[e]] &lt; quiet[res]:</span><br><span class="line">res = ans[e]</span><br><span class="line">ans[node] = res</span><br><span class="line"><span class="comment"># 修改入度，将入度变为0的节点加入队列</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> d1[node]:</span><br><span class="line">count[i] -= <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> count[i] == <span class="number">0</span>:</span><br><span class="line">Q.append(i)</span><br><span class="line"><span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">86</span> / <span class="number">86</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">256</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dp </tag>
            
            <tag> dfs </tag>
            
            <tag> topsort </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 849 Maximize Distance to Closest Person</title>
      <link href="/2018/06/10/Leetcode-849-Maximize-Distance-to-Closest-Person/"/>
      <url>/2018/06/10/Leetcode-849-Maximize-Distance-to-Closest-Person/</url>
      <content type="html"><![CDATA[<p>In a row of seats, 1 represents a person sitting in that seat, and 0 represents that the seat is empty.<br>There is at least one empty seat, and at least one person sitting.<br>Alex wants to sit in the seat such that the distance between him and the closest person to him is maximized.<br>Return that maximum distance to closest person.</p><blockquote><p>Example 1:<br>Input: [1,0,0,0,1,0,1]<br>Output: 2<br>Explanation:<br>If Alex sits in the second open seat (seats[2]), then the closest person has distance 2.<br>If Alex sits in any other open seat, the closest person has distance 1.<br>Thus, the maximum distance to the closest person is 2.</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: [1,0,0,0]<br>Output: 3<br>Explanation:<br>If Alex sits in the last seat, the closest person is 3 seats away.<br>This is the maximum distance possible, so the answer is 3.</p></blockquote><blockquote><p>Note:<br>1 &lt;= seats.length &lt;= 20000<br>seats contains only 0s or 1s, at least one 0, and at least one 1.</p></blockquote><p><strong>分析：</strong></p><ol><li>题目用一个列表代表一系列座位，1代表有人，0代表没人，现在要你找一个座位使得离你最近的人尽量远。</li><li>数据长度达到20000，显然n^2方法不行，不过这道题怎么想都想不到n^2上去吧。。</li></ol><p><strong>思路：</strong><br>用一个列表记录下那些位置有人坐，如[1,0,0,0,1,0,1]则记录[0,4,6]，分别作差判断能得到的最远距离是多少，最后处理一下边界问题即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxDistToClosest</span><span class="params">(seats)</span>:</span></span><br><span class="line">rec = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(seats)):</span><br><span class="line"><span class="keyword">if</span> seats[i] == <span class="number">1</span>:</span><br><span class="line">rec.append(i)</span><br><span class="line"><span class="comment"># 处理边界情况</span></span><br><span class="line">left = rec[<span class="number">0</span>]</span><br><span class="line">right = len(seats)<span class="number">-1</span> - rec[<span class="number">-1</span>]</span><br><span class="line">res = max(left, right)</span><br><span class="line"><span class="comment"># 依次作差 除2得最远距离</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(rec)):</span><br><span class="line">dis = (rec[i] - rec[i<span class="number">-1</span>]) // <span class="number">2</span></span><br><span class="line">res = max(res,dis)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="number">79</span> / <span class="number">79</span> test cases passed.</span><br><span class="line">difficulty: easy</span><br><span class="line">Runtime: <span class="number">65</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 848 Shifting Letters</title>
      <link href="/2018/06/10/Leetcode-848-Shifting-Letters/"/>
      <url>/2018/06/10/Leetcode-848-Shifting-Letters/</url>
      <content type="html"><![CDATA[<p>We have a string S of lowercase letters, and an integer array shifts.<br>Call the shift of a letter, the next letter in the alphabet, (wrapping around so that ‘z’ becomes ‘a’).<br>For example, shift(‘a’) = ‘b’, shift(‘t’) = ‘u’, and shift(‘z’) = ‘a’.<br>Now for each shifts[i] = x, we want to shift the first i+1 letters of S, x times.<br>Return the final string after all such shifts to S are applied.</p><blockquote><p>Example 1:<br>Input: S = “abc”, shifts = [3,5,9]<br>Output: “rpl”<br>Explanation:<br>We start with “abc”.<br>After shifting the first 1 letters of S by 3, we have “dbc”.<br>After shifting the first 2 letters of S by 5, we have “igc”.<br>After shifting the first 3 letters of S by 9, we have “rpl”, the answer.<br>Note:<br>1 &lt;= S.length = shifts.length &lt;= 20000<br>0 &lt;= shifts[i] &lt;= 10 ^ 9</p></blockquote><a id="more"></a><p><strong>分析：</strong></p><ol><li>题目定义了一个shift函数，将字母按照字母表顺序转换到下一个字母，’z’后又是’a’；题目给了一个shift数组，shift[i]代表要对前i+1个字母作shift[i]次shift函数操作。</li><li>注意数据长度达到20000，显然n^2的方法不可行，数据本身大小达到10^9，说明处理必须一步到位。</li></ol><p><strong>思路：</strong><br>建立一个字典使0到25和zabc…xy互相对应，那么我们分析一个字符的时候便可以转换成数字来处理，处理结束后又可转换成字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">index = <span class="number">0</span></span><br><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> <span class="string">'zabcdefghijklmnopqrstuvwxy'</span>:</span><br><span class="line">d[s] = index</span><br><span class="line">d[index] = s</span><br><span class="line">index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shiftingLetters</span><span class="params">(S, shifts)</span>:</span></span><br><span class="line"><span class="comment"># 因为每次都是对前i+1个字符进行操作，所以实际第一个字符被处理了sum(shift)，依次类推</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(shifts)<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">shifts[i] += shifts[i+<span class="number">1</span>]</span><br><span class="line">res = []</span><br><span class="line"><span class="comment"># S.length = shifts.length</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(S)):</span><br><span class="line">index = (d[S[i]] + shifts[i]) % <span class="number">26</span></span><br><span class="line">res.append(d[index])</span><br><span class="line"><span class="keyword">return</span> <span class="string">''</span>.join(res)</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> string </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>美团2018CodeM初赛A轮第6题</title>
      <link href="/2018/06/09/%E7%BE%8E%E5%9B%A22018CodeM%E5%88%9D%E8%B5%9BA%E8%BD%AE%E7%AC%AC6%E9%A2%98/"/>
      <url>/2018/06/09/%E7%BE%8E%E5%9B%A22018CodeM%E5%88%9D%E8%B5%9BA%E8%BD%AE%E7%AC%AC6%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="加解密"><a href="#加解密" class="headerlink" title="加解密"></a>加解密</h1><p>小团在美团旅行的安全部门实习研究加密算法，他提出了一个加密算法。现在小团把解密算法告诉你，希望你对数据进行解密。</p><p>加密数据包有两部分构成，一对数字a, b和一个字符串S。解密的方式S串最早在a/b的小数部分出现的位置k，k即为解密信息。小数点后从1开始计数。如果a/b不是一个无限循环小数，则在认为后面有无穷多个0，如5/4=1.2500000000…。<br>如果S不在a/b的小数部分出现，则无法解密输出-1。<br><a id="more"></a></p><blockquote><p>输入描述:<br>第一行两个正整数a, b (1 ≤ a, b ≤ 1,000,000,000)。第二行一个数字串S(1 ≤ |S| ≤100,000)。<br>输出描述:<br>输出一行k表示答案。</p></blockquote><blockquote><p>示例1<br>输入<br>1 2<br>500000000000<br>输出<br>1</p></blockquote><blockquote><p>示例2<br>输入<br>1234 5678<br>4579<br>输出<br>8</p></blockquote><blockquote><p>示例3<br>输入<br>233 999<br>333<br>输出<br>-1</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> 思维提升 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>美团2018CodeM初赛A轮第5题</title>
      <link href="/2018/06/09/%E7%BE%8E%E5%9B%A22018CodeM%E5%88%9D%E8%B5%9BA%E8%BD%AE%E7%AC%AC5%E9%A2%98/"/>
      <url>/2018/06/09/%E7%BE%8E%E5%9B%A22018CodeM%E5%88%9D%E8%B5%9BA%E8%BD%AE%E7%AC%AC5%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="塔防"><a href="#塔防" class="headerlink" title="塔防"></a>塔防</h1><p>袋鼠先生最近迷上了玩塔防游戏。塔防游戏中有若干座防御塔。一些防御塔能覆盖的范围为这里面任意三个防御塔形成的三角形区域的并集。注意这里的三角形包括边界，且如果三角形退化那么就相当于一条线段。换句话说，三个或以上的防御塔所能覆盖的范围为这些点形成的凸包，小于三个的防御塔没有任何功能。<br>    袋鼠先生发现有些防御塔和其他防御塔不同，如果拆除这个防御塔会导致防御的区域缩小那么我们称这个防御塔为关键的防御塔。这里区域缩小包括区域的面积减小，线段变短，或者从有到无。<br>    袋鼠先生在建造某些防御塔上面氪了很多金币，所以袋鼠先生希望能通过拆除其他的防御塔使得他氪过金币的防御塔全部成为关键的防御塔。还有一点，袋鼠先生希望剩下的防御塔能覆盖的面积是正的。<br>    袋鼠先生想知道有多少种这样的方案，答案可能很大，所以要对1,000,000,007取模。<br><a id="more"></a></p><blockquote><p>输入描述:<br>第一行一个整数n (1 ≤ n ≤ 200)。<br>接下来n行每行三个整数X_i, Y_i, W_i(0 ≤ |X_i|, |Y_i| ≤ 1,000,000,000, W_i ∈ {0,1})。(X_i, Y_i)表示每个塔的坐标。W_i表示每个塔的属性，如果W_i = 0表示这个塔可以拆除，否则表示这个塔不可拆除。<br>数据保证没有重点。<br>输出描述:<br>输出一行表示答案，即有多少种方案。</p></blockquote><blockquote><p>示例1<br>输入<br>5<br>0 0 0<br>0 2 0<br>2 0 0<br>2 2 0<br>1 1 1<br>输出<br>4</p></blockquote><blockquote><p>示例2<br>输入<br>8<br>0 0 0<br>0 1 1<br>0 2 0<br>1 2 1<br>2 2 0<br>2 1 1<br>2 0 0<br>1 0 1<br>输出<br>7</p></blockquote><blockquote><p>示例3<br>输入<br>6<br>0 0 0<br>0 4 0<br>4 0 0<br>4 4 0<br>2 2 1<br>2 1 0<br>输出<br>11</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> 思维提升 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>美团2018CodeM初赛A轮第4题</title>
      <link href="/2018/06/09/%E7%BE%8E%E5%9B%A22018CodeM%E5%88%9D%E8%B5%9BA%E8%BD%AE%E7%AC%AC4%E9%A2%98/"/>
      <url>/2018/06/09/%E7%BE%8E%E5%9B%A22018CodeM%E5%88%9D%E8%B5%9BA%E8%BD%AE%E7%AC%AC4%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="迷宫"><a href="#迷宫" class="headerlink" title="迷宫"></a>迷宫</h1><p>给定一个n*m的迷宫，其中任意两个相邻单元之间可能存在墙，定义从单元S到单元T的路径为从S出发，通过向上、下、左、右四个方向上的移动组合，在不通过墙的前提下，最终到达T的轨迹。数据保证迷宫中的任意两点之间存在合法的路径。现在考虑一张有k个顶点的完全图G, 其中每个顶点对应迷宫中的某个单元，并且任意两个顶点之间连边的长度为其所对应迷宫单元之间的最短路径的长度。求G的最小生成树的边权和。<br><a id="more"></a></p><blockquote><p>输入描述:<br>第一行三个正整数n, m, k (2 ≤ n, m ≤ 2,000, k ≤ 100,000)。<br>接下来n行，每行m-1个 0/1。其中i行第j个数描述单元(i, j)和(i, j+1)之间是否存在墙。(1表示有墙，0表示没墙)<br>接下来n-1行，每行m个 0/1。其中i行第j个数描述单元(i, j)和(i+1, j)之间是否存在墙。(1表示有墙，0表示没墙)<br>接下来k行，每行两个正整数x, y，描述G中一个顶点所对应的单元，其中x代表行号，y代表列号。保证这k个顶点所对应的单元两两不同。<br>输出描述:<br>输出一行一个整数，描述最小生成树的边权和。<br>示例1<br>输入<br>5 5 3<br>0111<br>0010<br>0101<br>0110<br>0111<br>10000<br>10000<br>10001<br>10000<br>1 4<br>4 3<br>4 2<br>输出<br>9</p></blockquote><p>初步思想，bfs找最短距离,（dp存一下？应该不用吧）kruskal算法找最小生成树。应该是可以做的，现在没时间先放一下。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>美团2018CodeM初赛A轮第3题</title>
      <link href="/2018/06/09/%E7%BE%8E%E5%9B%A22018CodeM%E5%88%9D%E8%B5%9BA%E8%BD%AE%E7%AC%AC3%E9%A2%98/"/>
      <url>/2018/06/09/%E7%BE%8E%E5%9B%A22018CodeM%E5%88%9D%E8%B5%9BA%E8%BD%AE%E7%AC%AC3%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>在点点和评评的世界里有一个城市，城市是一个树形结构，由n个节点组成，有n-1条双向边把这些节点连在了一起（即在任意两个节点AB之间都存在从A到B的路径）。每条边都有一个边权，表示通过这条边需要的时间。<br>现在点点和评评想要从他们所在的S点到T点参加会议，他们想要在过程中体会旅途的乐趣，即好好欣赏每条边上的风景。详细地说，对于每条边，都有一个值l，l表示在从S点到T点的过程中，最少需要经过这条边的次数。因为会期将至，所以点点和评评想要在看够风景的情况下，花费尽可能少的时间。<br>点点和评评一共想询问m组这样的S和T，每组询问单独考虑，对于某一组特定的询问，他们想知道最少需要花费的时间。<br><a id="more"></a></p><blockquote><p>输入描述:<br>第一行一个整数n(1 ≤ n ≤ 100,000)表示点数。<br>接下来n-1行，每行四个整数x, y, z, l(1 ≤ x, y ≤ n, 1 ≤ z, l ≤ 1,000,000,000)，表示从x到y之间有一条边权为z的边，并且这条边至少要经过l次。<br>数据保证没有重边和自环。<br>接下来一个整数m(1 ≤ m ≤ 100,000)表示询问组数。<br>接下来m行，每行两个整数S, T(1 ≤ S, T ≤ n)表示一组询问。<br>输出描述:<br>输出m行，每行一个整数表示答案，因为答案可能很大，请输出答案 mod 1,000,000,007的值。<br>示例1<br>输入<br>3<br>1 2 10 1<br>2 3 20 2<br>2<br>1 3<br>3 2<br>输出<br>70<br>80<br>说明<br>   路径为：<br>   1-&gt;2-&gt;3-&gt;2-&gt;3<br>   3-&gt;2-&gt;1-&gt;2-&gt;3-&gt;2</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> 思维提升 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>美团2018CodeM初赛A轮第2题</title>
      <link href="/2018/06/09/%E7%BE%8E%E5%9B%A22018CodeM%E5%88%9D%E8%B5%9BA%E8%BD%AE%E7%AC%AC2%E9%A2%98/"/>
      <url>/2018/06/09/%E7%BE%8E%E5%9B%A22018CodeM%E5%88%9D%E8%B5%9BA%E8%BD%AE%E7%AC%AC2%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="下棋"><a href="#下棋" class="headerlink" title="下棋"></a>下棋</h1><p> 有一个1*n的棋盘，上面有若干个棋子，一个格子上可能有多个棋子。<br>你每次操作是先选择一个棋子，然后选择以下两个操作中的一个：<br>(1) 若该棋子不在 (1,1)，让这个棋子往左走一格，即从 (1,x) 走到 (1,x-1)；<br>(2) 若该棋子不在 (1,n)，且这个棋子曾经到达过(1,1)，让这个棋子往右走一格，即从 (1,x) 走到 (1,x+1)。<br>给定一开始每个格子上有几个棋子，再给定目标局面每个格子上需要几个棋子，求最少需要多少次操作。<br><a id="more"></a></p><blockquote><p>输入描述:<br>第一行一个正整数n表示棋盘大小。<br>第二行n个非负整数a_1, a_2, …, a_n 表示一开始 (1,i) 上有几个棋子。<br>第三行n个非负整数b_1, b_2, …, b_n 表示目标局面里 (1,i) 上有几个棋子。<br>保证 1 ≤ n ≤ 100,000，<br>输出描述:<br>输出一个非负整数，表示最少需要几次操作。<br>示例1<br>输入<br>5<br>0 0 1 1 0<br>1 0 0 0 1<br>输出<br>9<br>说明<br>先把(1,3)上的棋子走到(1,1)，花费了2次操作。<br>然后把(1,4)上的棋子走到(1,1)，再往右走到(1,5)，花费了3+4=7次操作。<br>所以一共花了9次操作。</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> 思维提升 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>美团2018CodeM初赛A轮第1题</title>
      <link href="/2018/06/09/%E7%BE%8E%E5%9B%A22018CodeM%E5%88%9D%E8%B5%9BA%E8%BD%AE%E7%AC%AC1%E9%A2%98/"/>
      <url>/2018/06/09/%E7%BE%8E%E5%9B%A22018CodeM%E5%88%9D%E8%B5%9BA%E8%BD%AE%E7%AC%AC1%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="遥控按键"><a href="#遥控按键" class="headerlink" title="遥控按键"></a>遥控按键</h1><p>小美想要在电视上看电影，我们知道在电视上搜索电影可以通过搜索电影名字首字母缩写得到，通过首字母搜索电影的界面由一个九宫格组成，如下图：</p><p>@!:        ABC        DEF</p><p>GHI        JKL        MNO</p><p>PQRS    TUV        WXYZ</p><p>光标初始在这个九宫格的左上方，也就是在 “@!:”的位置，每次小美想要输入一个字母，需要通过不断地按上下左右四个方向键(并且只能按方向键），把光标从当前所在的格子移动到目标的格子(也就是待输入的字母所在的格子)，然后在目标的格子上通过其他的按键来输入字母。小美觉得频繁地按方向键是十分烦人的事情，所以她想设计一种移动光标方案使得方向键按的次数最少。问最少要几次?<br>小美想看 T 部电影，所以她会问你 T 个电影名字的缩写分别需要多少次输入。<br>注意在一个电影名字输入完以后，光标会回到左上角，期间按的方向键不会计入答案。<br><a id="more"></a></p><blockquote><p>输入描述:<br>第一行一个T(T ≤ 10)，表示小美想看的电影数。<br>接下来 T 行，每行一个长度不超过100,000的字符串，表示一部电影名字的缩写，保证缩写的每个字符都是大写英文字母。<br>输出描述:<br>对于每个电影名字缩写，输出输入这个名字的最小按方向键的次数。<br>示例1<br>输入<br>2<br>AA<br>AT<br>输出<br>1<br>3</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> 思维提升 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>美团2018CodeM资格赛第6题</title>
      <link href="/2018/06/08/%E7%BE%8E%E5%9B%A22018CodeM%E8%B5%84%E6%A0%BC%E8%B5%9B%E7%AC%AC6%E9%A2%98/"/>
      <url>/2018/06/08/%E7%BE%8E%E5%9B%A22018CodeM%E8%B5%84%E6%A0%BC%E8%B5%9B%E7%AC%AC6%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h1><p>美团外卖日订单已经超过2000万，背后有一个非常复杂的智能调度系统。<br>我们考虑一个简化的情形，有n个外卖小哥要去 n 家商店取货，第 i 个外卖小哥到达商店 j 需要时间 e[i][j] 。现在有 m 对外卖小哥和商店的合作关系。假定每个外卖小哥只能取到一个货物，每个商店只需要一位外卖小哥取货。<br>询问最少多少时间，能有 k 位外卖小哥到达 k 个商店取到货物？对于每个 k ，都输出一个数表示最少使用时间，如果无解输出 -1。<br><a id="more"></a><br>输入描述:</p><blockquote><p>第一行输入两个整数 n , m （1 &lt;= n &lt;= 1000 , 1 &lt;= m &lt;= 100000）。<br>接下来 m 行，每行输入 3 个整数 i , j , e[i][j] (1 &lt;= i, j &lt;= n , 0 &lt;= e[i][j] &lt;= 10^9)，定义如题所述。<br>注：本题测试用例较多，请耐心等待判题结果，也可以去排行榜刷新查看自己的提交结果。</p></blockquote><p>输出描述:</p><blockquote><p>输出一行n个整数，第 i 个整数，表示当 k=i 时，需要的最少时间，如果无解输出-1，结尾无空格。<br>示例1<br>输入<br>    3 7<br>    1 3 5<br>    2 3 2<br>    3 1 7<br>    1 2 0<br>    2 3 2<br>    3 2 0<br>    2 1 5<br>输出<br>    0 2 5</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> 思维提升 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>美团2018CodeM资格赛第5题</title>
      <link href="/2018/06/08/%E7%BE%8E%E5%9B%A22018CodeM%E8%B5%84%E6%A0%BC%E8%B5%9B%E7%AC%AC5%E9%A2%98/"/>
      <url>/2018/06/08/%E7%BE%8E%E5%9B%A22018CodeM%E8%B5%84%E6%A0%BC%E8%B5%9B%E7%AC%AC5%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="你的城市"><a href="#你的城市" class="headerlink" title="你的城市"></a>你的城市</h1><p>2018年第一季度，美团旅行的酒店业务以5770万的订单总量，成为行业第一名。<br>与此同时，美团旅行也提供机票、火车票、船票等各种服务，不断开辟新的目的旅游城市。最近新开的目的地，就包括对小A有特殊意义的偏僻小城C。<br>“我来到 你的城市 熟悉的那一条街。”小A哼着歌，从北京出发，要去C城。这对他非常重要，必须当天到达，虽然交通并不是非常方便。<br>但是，错过火车并不是一个小概率事件。为了保险起见，小A决定选择一个即使错过火车也存在补救措施的交通方案。（即假使未赶上原方案中的任何一班火车，依然可以改乘其他的车次能够在当天到达C城，但同时小A是一个乐观主义者，所以他认为改乘以后的所有车次都不会延误。）当然了，在满足上述条件的情况下，小A希望花费的钱越少越好（只考虑计划中的，不考虑发生意外时换乘带来的代价）。<br>城市及交通网可以看做一张n个点m条边的有向图。每个点代表一个城市（1号点代表北京，n号点代表C城）。每条边由一个五元组&lt; x, y, c, ts, td &gt;组成，表示存在一个车次，由ts时刻从城市x出发，在td时刻到达城市y，且花费为c元。<br>为了简化问题，ts，td均为以半小时为基本单位（具体格式见样例及Hint）。并假设每次中转最少需要花费半个小时，且中转只能发生在同一城市（即到达一个城市距离再次从这个城市出发至少需要间隔半个小时），注意，小 A 如果因为没赶上车次需要改乘，也需要半个小时的时间。<br>问小A到达C城最少需要花费多少钱（行程必须在这一天内完成，可以在0:00上车，也可以在24:00到达）。<br><a id="more"></a><br><strong>输入描述:</strong></p><blockquote><p>第一行，两个正整数n, m。n表示城市数量，m表示当天不同班次的火车数量。<br>接下来m行，每行3个整数x, y, c加两个字符串ts, td，均以空格作为分隔，表示当天的某一班火车。其中x, y, c, ts, td的含义如前描述。<br>所有的车次都是当天的，没有隔夜的票。<br>2 &lt;= n &lt;= 500, m &lt;= 15000, c &lt;= 1000, ts &lt; td，所有数均为正整数。<br>车次保证不过夜，时间范围0:00, 0:30, 1:00, … , 23:00, 23:30, 24:00，可能存在重复车次。</p></blockquote><p><strong>输出描述:</strong></p><blockquote><p>一个整数，表示存在补救措施的前提下，小A到达C城的最小花费。如果不存在这样的路径，则输出-1。<br>示例1<br>输入<br>    3 5<br>    1 3 800 18:00 21:00<br>    1 2 650 13:30 14:00<br>    2 3 100 14:00 18:00<br>    2 3 300 14:30 19:00<br>    2 3 200 15:00 19:30<br>输出<br>    950<br>说明<br>    选择第二个和第四个车次。<br>    第三个车次由于中转时间太短无法选择。第五个车次由于没有可改乘的航班无法选择。<br>    如果错过第二个车次，可以改乘第一个车次。如果错过第四个车次，可以改乘第五个车次。<br>示例2<br>输入<br>    3 5<br>    1 2 1000 0:00 12:00<br>    1 2 100 0:30 14:00<br>    1 2 100 0:30 15:00<br>    2 3 300 16:00 24:00<br>    2 3 200 16:30 24:00<br>输出<br>    1300<br>说明<br>    选择第一个和第四个车次。<br>    不能选择第二个车次是因为，如果错过了0:30的车次2，那么同样在0:30出发的车次3也是来不及改乘的。<br>示例3<br>输入<br>    3 4<br>    1 2 100 0:30 14:00<br>    1 2 200 0:30 15:00<br>    2 3 300 16:00 24:00<br>    2 3 200 16:30 24:00<br>输出<br>    -1<br>说明<br>    和样例二类似，但是缺少了原先的车次一，所以没有换乘方案。<br>示例4<br>输入<br>    3 4<br>    1 2 100 0:30 14:00<br>    1 2 200 1:00 16:00<br>    2 3 300 16:00 24:00<br>    2 3 200 16:30 24:00<br>输出<br>    400<br>说明<br>    选择第一个和第三个车次。<br>示例5<br>输入<br>    3 4<br>    1 2 100 0:30 14:00<br>    1 2 200 1:00 16:30<br>    2 3 300 16:00 24:00<br>    2 3 200 16:30 24:00<br>输出<br>    -1<br>说明<br>    和样例四类似，但假如错过了第一个车次，改乘车次二在16:30到达城市2是不足以赶上16:30出发的车次四的。</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> 思维提升 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>美团2018CodeM资格赛第4题</title>
      <link href="/2018/06/08/%E7%BE%8E%E5%9B%A22018CodeM%E8%B5%84%E6%A0%BC%E8%B5%9B%E7%AC%AC4%E9%A2%98/"/>
      <url>/2018/06/08/%E7%BE%8E%E5%9B%A22018CodeM%E8%B5%84%E6%A0%BC%E8%B5%9B%E7%AC%AC4%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h1><p>小胖参加了人生中最重要的比赛——MedoC资格赛。MedoC的资格赛由m轮构成，使用常见的“加权标准分”的规则。每位选手需要参加所有的m轮的比赛。在一轮中，能取得的分数为自己的成绩除掉最高分的成绩。每个选手的总分为每一轮获得的分数乘上这一轮比赛占得比重。如果在某一轮比赛中所有人获得了零分，那么所有选手在这一轮获得的分数都为0分。<br>比如说，资格赛一共3轮，三轮的权重分别为30%, 30%, 40%。在第一轮中，小胖获得了300分，最高分也为300分。在第二轮中，小胖获得了0分，最高分也为0分。在第三轮中，小胖获得了150分，最高分为300分，那么小胖的总分为(300/300)*30%+0*30%+(150/300)*40%=0.5。<br>一共有n位选手参加了比赛，其中成绩最高的k位选手能够晋级到初赛。如果有多人在分数线上同分，那么系统会随机在这些同分的人中选取，选满k个晋级为止。<br>小胖现在知道了每个选手每场比赛的成绩，但是由于他的疏忽，其中的某个人某场比赛的成绩消失了。所以更多人出线的情况变得未知起来。现在只知道成绩一定是0到C之间的一个整数（包含0和C）。<br>小胖想知道对于每个人的出线情况是怎么样的，也就是一定能出线，一定不能出线还是有可能出线。<br><a id="more"></a><br>输入描述:</p><blockquote><p>第一行四个正整数n,m,k,C (m &lt;= 6, k &lt;= n &lt;= 500, C &lt;= 500)。<br>接下来一行m个整数w1, w2, …, wm，表示每场比赛的权重，第i场比赛的权重为wi/(w1+w2+…+wm)，保证wi &gt;= 0且1 &lt;= w1 + w2 + … + wm &lt;= 1000。<br>接下来n行每行m个整数，第i个整数表示这个选手在第i场比赛中获得的成绩。如果这个数字为-1表示这个数据丢失，保证恰好有一个-1。</p></blockquote><p>输出描述:</p><blockquote><p>n行每行输出一个1到3之间的整数。1表示一定出线，2表示一定不出线，3表示可能出线。</p></blockquote><p>示例1<br>输入</p><blockquote><p>4 2 2 100<br>1 1<br>100 99<br>70 70<br>40 -1<br>100 39</p></blockquote><p>输出</p><blockquote><p>1<br>3<br>3<br>2</p></blockquote><p><strong>分析：</strong><br>其它分数全部固定只有这个-1会变（从0到C），不妨设本身这一轮比赛的最大分值为M<br>首先分数从0开始涨到M，这一过程其它人分数不变，这个人分数在上升，或许能挤掉一些人<br>然后分数从M开始涨到C，这一过程这个人分数不变，其他人分数在下降(对这轮分高的不利，排名可能会下降)，或许又能挤掉一些人<br>那么我想0，C这两个点应该是极端情况才对，应该只考虑这两种情况就行了吧，难道要考虑M的情况？<br>这道题还没搞懂是哪里想错了，就pass 3.7%（或许就过了测试样例吧），这里先写下两种思路吧</p><p><strong>思路：</strong><br>方法1： 假设没有这个-1，有谁可以肯定出线或者有概率出线（同分情况）是可以计算出来的，我们写一个函数来计算，返回一个列表，1代表肯定能出现，3代表有概率出线，0代表不能出线。然后我们找到这个-1，将它改成0计算一次结果，改成C计算一次结果，比较这两次结果即可。(pass 3.7%)</p><p>方法2： 先不考虑有-1的那一轮，将其他的分数全部计算，指针先指着第K个人，然后从0到C遍历，分别计算分数，但是这样感觉特别麻烦，比如 分数3 3 3 3 2，晋级4个，那么当2涨到3的时候，所有人状态全混了，代码上也没法简洁处理的样子，但是感觉这种办法肯定万无一失，毕竟全算了，而且C&lt;500，应该也不会超时。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n,m,k,C = map(int,raw_input().split())</span><br><span class="line">        w = map(int,raw_input().split())</span><br><span class="line">        S= sum(w)</span><br><span class="line">        w = [float(w[i])/S <span class="keyword">for</span> i <span class="keyword">in</span> range(m)]</span><br><span class="line"></span><br><span class="line">        score = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            score[i] = map(int,raw_input().split())</span><br><span class="line">        <span class="comment"># 计算函数</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">herlper</span><span class="params">(score)</span>:</span></span><br><span class="line">            rec = zip(*score)</span><br><span class="line">            res = [<span class="number">0</span>] * n</span><br><span class="line">            ans = [<span class="number">0</span>] * n</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">                M = float(max(rec[i]))</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                    res[j] += rec[i][j]/M * w[i]</span><br><span class="line">            heap = [(res[i],i) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">            heap.sort(key= <span class="keyword">lambda</span> x:x[<span class="number">0</span>],reverse=<span class="keyword">True</span>)</span><br><span class="line">            <span class="comment"># 处理同分情况</span></span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; k:</span><br><span class="line">                j = i+<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> heap[j][<span class="number">0</span>] == heap[j<span class="number">-1</span>][<span class="number">0</span>]:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> j &gt; k:</span><br><span class="line">                    ans[i:j] = [<span class="number">3</span>] * (j-i)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans[i:j] = [<span class="number">1</span>] * (j-i)</span><br><span class="line">                i = j</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        <span class="comment"># 找-1修改</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> score[i][j] == <span class="number">-1</span>:</span><br><span class="line">                    score[i][j] = <span class="number">0</span></span><br><span class="line">                    res1 = herlper(score)</span><br><span class="line">                    score[i][j] = C</span><br><span class="line">                    res2 = herlper(score)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> res1[i] == res2[i] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">print</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> res1[i] != res2[i]:</span><br><span class="line">                <span class="keyword">print</span> <span class="number">3</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">print</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 思维提升 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>美团2018CodeM资格赛第3题</title>
      <link href="/2018/06/08/%E7%BE%8E%E5%9B%A22018CodeM%E8%B5%84%E6%A0%BC%E8%B5%9B%E7%AC%AC3%E9%A2%98/"/>
      <url>/2018/06/08/%E7%BE%8E%E5%9B%A22018CodeM%E8%B5%84%E6%A0%BC%E8%B5%9B%E7%AC%AC3%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="世界杯"><a href="#世界杯" class="headerlink" title="世界杯"></a>世界杯</h1><p>世界杯就要开始啦！真真正正的战斗从淘汰赛开始，现在我们给出球队之间的胜负概率，来预测每支球队夺冠的可能性。<br>在接下来的篇幅中，我们将简单介绍淘汰赛阶段的规则。<br>淘汰赛阶段的90分钟常规时间内（含补时阶段）进球多的球队取胜，如果参赛双方在90分钟内（含补时阶段）无法决出胜负，将进行上下半场各15分钟的加时赛。加时赛阶段，如果两队仍未分出胜负，则通过点球大战决出胜者。也就是说，每场比赛，有且仅有一个队能够晋级到下一轮。<br>淘汰赛共有16支球队参加（小组赛阶段共分8个小组，每组前两名晋级），对阵安排如下。<br><a id="more"></a><br>1/8决赛<br>A组第一对阵B组第二=胜者1<br>B组第一对阵A组第二=胜者2<br>C组第一对阵D组第二=胜者3<br>D组第一对阵C组第二=胜者4<br>E组第一对阵F组第二=胜者5<br>F组第一对阵E组第二=胜者6<br>G组第一对阵H组第二=胜者7<br>H组第一对阵G组第二=胜者8<br>获胜的8个队进入1/4决赛，即所谓“8强”<br>1/4决赛<br>胜者1对阵胜者3=胜者A<br>胜者2对阵胜者4=胜者B<br>胜者5对阵胜者7=胜者C<br>胜者6对阵胜者8=胜者D<br>1/4决赛的4个获胜队进入“4强”<br>半决赛<br>胜者A对阵胜者C<br>胜者B对阵胜者D<br>半决赛获胜两队进入决赛，失利的两队争夺三名<br>决赛获胜的队伍就是最后的冠军！</p><p>输入描述:</p><blockquote><p>球队会被以1..16进行标号，其分别表示：<br>1 A组第一；<br>2 B组第二；<br>3 C组第一；<br>4 D组第二；<br>5 E组第一；<br>6 F组第二；<br>7 G组第一；<br>8 H组第二；<br>9 B组第一；<br>10 A组第二；<br>11 D组第一；<br>12 C组第二；<br>13 F组第一；<br>14 E组第二；<br>15 H组第一；<br>16 G组第二。</p></blockquote><blockquote><p>数据共有16行，每行16个浮点数，第i行第j列的数Fi,j表示i和j进行比赛时i获胜（包括常规时间获胜、加时赛获胜以及点球大战获胜）的概率。<br>对于1 &lt;= i, j &lt;= 16 且 i != j, 满足0 &lt;= Fi,j &lt;= 1, Fi,j + Fj,i = 1；<br>对于1 &lt;= i &lt;= 16, 满足 Fi,i = 0。</p></blockquote><p>输出描述:</p><blockquote><p>输出一行16个浮点数，用空格隔开，分别表示每只球队获得世界杯的概率，结尾无空格。<br>绝对误差或相对误差在1e-5之内的解会被判为正确。</p></blockquote><p><strong>分析：</strong><br>本题从思维难度上来讲不高，但就是要仔细分析，认真写出哪几个队进行比赛，求概率乘积即可</p><p>12(胜者1)  34(胜者3)·····决出胜者A<br>···································进入决赛<br>56(胜者5)  78(胜者7)·····决出胜者C<br>··············································最终冠军<br>910(胜者2)  1112(胜者4)··决出胜者B<br>···································进入决赛<br>1314(胜者6) 1516(胜者8)··决出胜者D</p><p><strong>思路：</strong><br>分别用矩阵讲每轮的概率存储,例如first存储每个队进8强的概率,second存储4强的概率,依次类推。每次计算思路一样，是可以用函数写的，比如 helper(turn,list1,list2)两个list代表i，j遍历的数据，turn表示轮数，当计算third的时候就写second，那样写代码应该会好看很多，但是我心态已经不太好了，就这样把。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        p = [[<span class="number">0.0</span>]*<span class="number">16</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">16</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">            p[i] = map(float,raw_input().split())</span><br><span class="line">        <span class="comment"># 8强概率</span></span><br><span class="line">        first = [<span class="number">0.0</span>] * <span class="number">16</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>]:</span><br><span class="line">            first[i] = p[i][i+<span class="number">1</span>]</span><br><span class="line">            first[i+<span class="number">1</span>] = p[i+<span class="number">1</span>][i]</span><br><span class="line">        <span class="comment"># 4强概率</span></span><br><span class="line">        second = [<span class="number">0.0</span>] * <span class="number">16</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>]:</span><br><span class="line">            second[i] = first[i] * (first[i+<span class="number">2</span>]*p[i][i+<span class="number">2</span>] + first[i+<span class="number">3</span>]*p[i][i+<span class="number">3</span>])</span><br><span class="line">            second[i+<span class="number">1</span>] = first[i+<span class="number">1</span>] * (first[i+<span class="number">2</span>]*p[i+<span class="number">1</span>][i+<span class="number">2</span>] + first[i+<span class="number">3</span>]*p[i+<span class="number">1</span>][i+<span class="number">3</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">2</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">14</span>]:</span><br><span class="line">            second[i] = first[i] * (first[i<span class="number">-2</span>]*p[i][i<span class="number">-2</span>] + first[i<span class="number">-1</span>]*p[i][i<span class="number">-1</span>])</span><br><span class="line">            second[i+<span class="number">1</span>] = first[i+<span class="number">1</span>] * (first[i<span class="number">-2</span>]*p[i+<span class="number">1</span>][i<span class="number">-2</span>] + first[i<span class="number">-1</span>]*p[i+<span class="number">1</span>][i<span class="number">-1</span>])</span><br><span class="line">        <span class="comment"># 决赛概率,写到这里才发现应该可以用函数写，龟龟，心态都蹦了</span></span><br><span class="line">        third = [<span class="number">0.0</span>] * <span class="number">16</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]:</span><br><span class="line">            P = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]:</span><br><span class="line">                P  += second[j]*p[i][j]</span><br><span class="line">            third[i] = second[i] * P</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]:</span><br><span class="line">            P = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]:</span><br><span class="line">                P  += second[j]*p[i][j]</span><br><span class="line">            third[i] = second[i] * P</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>]:</span><br><span class="line">            P = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> [<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>]:</span><br><span class="line">                P  += second[j]*p[i][j]</span><br><span class="line">            third[i] = second[i] * P</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>]:</span><br><span class="line">            P = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> [<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>]:</span><br><span class="line">                P  += second[j]*p[i][j]</span><br><span class="line">            third[i] = second[i] * P</span><br><span class="line">        <span class="comment"># 夺冠</span></span><br><span class="line">        final = [<span class="number">0.0</span>] * <span class="number">16</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> [<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>]:</span><br><span class="line">                final[i] += third[j]*p[i][j]</span><br><span class="line">            final[i] *= third[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>]:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]:</span><br><span class="line">                final[i] += third[j]*p[i][j]</span><br><span class="line">            final[i] *= third[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">print</span> <span class="string">' '</span>.join(map(str,final))</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 思维提升 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>美团2018CodeM资格赛第2题</title>
      <link href="/2018/06/08/%E7%BE%8E%E5%9B%A22018CodeM%E8%B5%84%E6%A0%BC%E8%B5%9B%E7%AC%AC2%E9%A2%98/"/>
      <url>/2018/06/08/%E7%BE%8E%E5%9B%A22018CodeM%E8%B5%84%E6%A0%BC%E8%B5%9B%E7%AC%AC2%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="可乐"><a href="#可乐" class="headerlink" title="可乐"></a>可乐</h1><p>小美和小团最近沉迷可乐。可供TA们选择的可乐共有k种，比如可口可乐、零度可乐等等，每种可乐会带给小美和小团不同的快乐程度。<br>TA们一共要买n瓶可乐，每种可乐可以买无限多瓶，小美会随机挑选其中的m瓶喝，剩下的n-m瓶小团喝。<br>请问应该如何购买可乐，使得小美和小团得到的快乐程度的和的期望值最大？<br>现在请求出购买可乐的方案。<br><a id="more"></a><br>输入描述:</p><blockquote><p>第一行三个整数n，m，k分别表示要买的可乐数、小美喝的可乐数以及可供选择的可乐种数。<br>接下来k行，每行两个整数a，b分别表示某种可乐分别给予小美和小团的快乐程度。<br>对于所有数据，1 &lt;= n &lt;= 10,000, 0 &lt;= m &lt;= n, 1 &lt;= k &lt;= 10,000, -10,000 &lt;= a, b &lt;= 10,000<br>输出描述:<br>一行k个整数，第i个整数表示购买第i种可乐的数目。<br>如果有多解，请输出字典序最小的那个。<br>对于两个序列 a1, a2, …, ak, b1, b2, …, bk，a的字典序小于b，当且仅当存在一个位置i &lt;= k满足：<br>ai &lt; bi且对于所有的位置 j &lt; i，aj = bj；<br>示例1<br>输入<br>2 1 2<br>1 2<br>3 1<br>输出<br>0 2<br><strong>说明</strong><br>一共有三种购买方案：</p><pre><code>1. 买2瓶第一类可乐，小美和小团各喝一瓶，期望得到的快乐程度和为1+2=3；2. 买1瓶第一类可乐和1瓶第二类可乐，小美和小团各有二分之一的概率喝到第一类可乐，另有二分之一的概率喝到第二类可乐，期望得到的快乐程度和为1*0.5+3*0.5+2*0.5+1*0.5=3.5；3. 买2瓶第二类可乐，小美和小团各喝一瓶，期望得到的快乐程度和为3+1=4。</code></pre></blockquote><p><strong>分析：</strong><br>这道题要注意是<strong>算期望之和最大</strong>，对于某一瓶可乐，假若提供的快乐度分别为x,y，我们来计算这瓶可乐能提供的快乐度，首先对于小美，选择到可乐的概率为m/n，则度为m/n * x,小团则为(n-m)/n * y。即对于若干组x,y，求ax+by的最大值，其中a+b=1。<br>如果能想到这一步，应该就不难了，因为x,y都有确定的值，在这么多组中x,y总有一个使得ax+by最大，所以就只买这一个就可以了。</p><p><strong>思路：</strong><br>依次读取数据进行比较，注意要按照字典序最小输出,（00002 02000）则输出00002</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n,m,k = map(int,raw_input().split())</span><br><span class="line">        index,res = <span class="number">0</span>,-float(<span class="string">'inf'</span>)</span><br><span class="line">        a,b = float(m)/n,float(n-m)/n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            x,y = map(int,raw_input().split())</span><br><span class="line">            <span class="keyword">if</span> a*x + b*y &gt;= res: </span><br><span class="line">                index = i</span><br><span class="line">                res = a*x + b*y</span><br><span class="line">        ans = [<span class="number">0</span>] * k</span><br><span class="line">        ans[index] = n</span><br><span class="line">        <span class="keyword">print</span> <span class="string">' '</span>.join(map(str,ans))</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 思维提升 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>美团2018CodeM资格赛第1题</title>
      <link href="/2018/06/08/%E7%BE%8E%E5%9B%A22018CodeM%E8%B5%84%E6%A0%BC%E8%B5%9B%E7%AC%AC1%E9%A2%98/"/>
      <url>/2018/06/08/%E7%BE%8E%E5%9B%A22018CodeM%E8%B5%84%E6%A0%BC%E8%B5%9B%E7%AC%AC1%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="下单"><a href="#下单" class="headerlink" title="下单"></a>下单</h1><p>美团在吃喝玩乐等很多方面都给大家提供了便利。最近又增加了一项新业务：小象生鲜。这是新零售超市，你既可以在线下超市门店选购生鲜食品，也可以在手机App上下单，最快30分钟就配送到家。<br>新店开张免不了大优惠。我们要在小象生鲜超市里采购n个物品，每个物品价格为ai，有一些物品可以选择八折优惠（称为特价优惠）。<br>有m种满减优惠方式，满减优惠方式只有在所有物品都不选择特价优惠时才能使用，且最多只可以选择最多一款。<br>每种满减优惠描述为(bi,ci)，即满bi减ci（当消费&gt;=bi时优惠ci）。<br>求要买齐这n个物品（必须一单买齐），至少需要多少钱（保留两位小数）。<br><a id="more"></a><br><strong>输入描述:</strong></p><blockquote><p>第一行，两个整数n,m。<br>接下来n行，每行一个正整数ai，以及一个0/1表示是否可以选择特价优惠（1表示可以）。<br>接下来m行，每行两个正整数bi,ci，描述一款满减优惠。</p></blockquote><blockquote><p>1 &lt;= n,m &lt;=10<br>1 &lt;= ai &lt;= 100<br>1 &lt;= ci &lt; bi &lt;= 1000</p></blockquote><p><strong>输出描述:</strong></p><blockquote><p>一行一个实数，表示至少需要消耗的钱数（保留恰好两位小数）。<br>示例1<br>输入<br>2 1<br>6 1<br>10 1<br>12 2<br>输出<br>12.80<br>示例2<br>输入<br>2 2<br>6 1<br>10 1<br>5 1<br>16 6<br>输出<br>10.00</p></blockquote><p><strong>分析：只能说幸好把，这第一题比较简单，否则一道都做不出来是真的尴尬，要么全价买然后享受满减优惠，要么直接特价买，最后比较大小即可，取值范围都宽松，怎么写都行</strong></p><p><strong>思路：用一个变量totalcost记录全价,decost记录特价（8折）,然后totalcost和满减政策依次比较取最优</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        n,m = map(int,raw_input().split())</span><br><span class="line">        totalcost = <span class="number">0</span></span><br><span class="line">        decost = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            val,flag = map(int,raw_input().split())</span><br><span class="line">            totalcost += val</span><br><span class="line">            <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">                decost += val * <span class="number">0.8</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                decost += val</span><br><span class="line">        res = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            b,c = map(int,raw_input().split())</span><br><span class="line">            <span class="keyword">if</span> totalcost &gt;= b:</span><br><span class="line">                res = min(res,totalcost-c)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'%.2f'</span> % min(decost,res)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 思维提升 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 453 Minimum Moves to Equal Array Elements</title>
      <link href="/2018/06/05/Leetcode-453-Minimum-Moves-to-Equal-Array-Elements/"/>
      <url>/2018/06/05/Leetcode-453-Minimum-Moves-to-Equal-Array-Elements/</url>
      <content type="html"><![CDATA[<p>Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1.</p><blockquote><p>Example:<br>Input:<br>[1,2,3]<br>Output:<br>3<br>Explanation:<br>Only three moves are needed (remember each move increments two elements):<br>[1,2,3]  =&gt;  [2,3,3]  =&gt;  [3,4,3]  =&gt;  [4,4,4]</p></blockquote><a id="more"></a><p><strong>分析：每次对n-1个数同时提升1，问提升多少次才能使所有数相同，做这种题就一定要动笔写下来</strong></p><p>思路：我们首先来对一个简单点的任意有序数组进行分析，如[a,b,c]，如何使它最后全变成相等呢，首先要明白最后相等的那个数是一定不可能小于c的，所以我们不妨先将a,变成c，即提升c-a次，此时数组为 [c,b+c-a,c],那么显然此时只要将0，2两个位置同时提升b-a即可，故最后答案为b+c-2a</p><p>如果是4个数呢？<br>[a,b,c,d]                         先提升d-a，<br>[d,b+d-a,c+d-a,d]                提升b-a<br>[d+b-a,b+d-a,c+b+d-2a,d+b-a]    提升c-a即可<br>故最后答案为 b+c+d-3a = a+b+c+d - 4a<br>综合这些规律我们可以发现答案就为 sum(nums) - min(nums) * len(nums)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minMoves</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> sum(nums) - min(nums)*len(nums)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">84</span> / <span class="number">84</span> test cases passed.</span><br><span class="line">difficulty: easy</span><br><span class="line">Runtime: <span class="number">68</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> math </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 462 Minumum Moves to Equal Array Elements II</title>
      <link href="/2018/06/05/Leetcode-462-Minumum-Moves-to-Equal-Array-Elements-II/"/>
      <url>/2018/06/05/Leetcode-462-Minumum-Moves-to-Equal-Array-Elements-II/</url>
      <content type="html"><![CDATA[<p>Given a non-empty integer array, find the minimum number of moves required to make all array elements equal, where a move is incrementing a selected element by 1 or decrementing a selected element by 1.<br>You may assume the array’s length is at most 10,000.</p><blockquote><p>Example:<br>Input:<br>[1,2,3]<br>Output:<br>2<br>Explanation:<br>Only two moves are needed (remember each move increments or decrements one element):<br>[1,2,3]  =&gt;  [2,2,3]  =&gt;  [2,2,2]</p></blockquote><a id="more"></a><p><strong>分析：也就是将所有数变成同一个数的花费，数组长度不超过10000，说明n^2的方法不行</strong></p><p>思路：我们先作几个简答的分析，比如一个有序数组，根据长度不同我们来依次分析<br> 1.长度为3，[a,b,c]，那么显然都往b靠花费最小（这个很容易证）<br>     cost = c-b + b-a = c-a<br> 2.长度为4，[a,b,c,d],先分析往b靠好还是往c靠好<br>     cost_b = d-b + c-b + b-a = d+c - (a+b)<br>     cost_c = d-c + c-b + c-a = d+c - (a+b)<br> 3.长度为5，[a,b,c,d,e]，显然是往c靠<br>     cost = e-c + d-c + c-b + c-a = d+e - (a+b)<br> 依次类推，我们发现花费就应该是数组的后半段减去数组的前半段，分奇偶判断一下即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minMoves2</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        index = len(nums)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> sum(nums[index+<span class="number">1</span>:]) - sum(nums[:index])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> sum(nums[index:]) - sum(nums[:index])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">29</span> / <span class="number">29</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">61</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> math </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 461 Hamming Distance</title>
      <link href="/2018/06/05/Leetcode-461-Hamming-Distance/"/>
      <url>/2018/06/05/Leetcode-461-Hamming-Distance/</url>
      <content type="html"><![CDATA[<p><img src="/images/leetcode_461.png" alt=""><br><a id="more"></a><br><strong>分析：或许这就是弱智题吧</strong></p><p><strong>思路：既然要找位不同的地方，自然就会想到异或操作，异或的结果二进制中1的个数便是答案</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingDistance</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :type y: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> bin(x^y).count(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">149</span> / <span class="number">149</span> test cases passed.</span><br><span class="line">difficulty: easy</span><br><span class="line">Runtime: <span class="number">41</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> bit </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 839 Similar String Groups</title>
      <link href="/2018/06/05/Leetcode-839-Similar-String-Groups/"/>
      <url>/2018/06/05/Leetcode-839-Similar-String-Groups/</url>
      <content type="html"><![CDATA[<p><img src="/images/leetcode_839.png" alt=""><br><a id="more"></a><br><strong>分析：在A中所有字符串都是由相同的字符组成的，但顺序不一样，如果两个字符串只有两个字符位置不同，那么我们把这两个字符串归为一组，求共有多少组。<br>注意：len(A)*len(A[i]) &lt; 20000,保证了n^2*m或者m^2*n的复杂度是可行的</strong></p><p><strong>思路：这是一道典型的union find题，是在prim算法还是在kruskal算法中这个思想被用到了。这里我介绍两种方法，一种是union find，一种是dfs</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSimilarGroups</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 判断两个字符串是否是一个组</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isSimilar</span><span class="params">(s1,s2)</span>:</span></span><br><span class="line">            cnt = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s1)):</span><br><span class="line">                <span class="keyword">if</span> s1[i] != s2[i]:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> cnt &gt; <span class="number">2</span>: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 标准的union find思路，也就是将所有在一个组内字符串用同一个字符串记录</span></span><br><span class="line">        <span class="comment"># 如 arts:arts, rats: arts, tars: arts, star: star</span></span><br><span class="line">        d = &#123;u:u <span class="keyword">for</span> u <span class="keyword">in</span> A&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(u)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> u != d[u]:</span><br><span class="line">                d[u] = find(d[u])</span><br><span class="line">            <span class="keyword">return</span> d[u]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#设初始组数为n，每找到一个该在同一组的总组数就减1</span></span><br><span class="line">        self.n = len(A)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(x,y)</span>:</span></span><br><span class="line">            x,y = find(x),find(y)</span><br><span class="line">            <span class="keyword">if</span> x != y:</span><br><span class="line">                d[y] = x</span><br><span class="line">                self.n -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> range(x+<span class="number">1</span>,len(A)):</span><br><span class="line">                <span class="keyword">if</span> isSimilar(A[x],A[y]): </span><br><span class="line">                    union(A[x],A[y])</span><br><span class="line">        <span class="keyword">return</span> self.n</span><br><span class="line"></span><br><span class="line">O(m*n^<span class="number">2</span>) time 其中n为A的长度，m为A[i]的长度</span><br></pre></td></tr></table></figure><p><strong>再介绍一种dfs方法，我们把每个字符串看做一个节点，如果两个字符串是同一个组则将它们相连接，最后构成一个图，在这个图中用dfs方法找有多少个连通分量</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSimilarGroups</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        Graph = collections.defaultdict(list)</span><br><span class="line">        <span class="comment"># 判断两个字符串是否是在一个组</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isSimilar</span><span class="params">(x,y)</span>:</span></span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(x)):</span><br><span class="line">                <span class="keyword">if</span> x[i] != y[i]:</span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> res &gt; <span class="number">2</span>: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">return</span> res == <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构建图，O(m*n^2) time</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(A)):</span><br><span class="line">                <span class="keyword">if</span> isSimilar(A[i],A[j]):</span><br><span class="line">                    Graph[i].append(j)</span><br><span class="line">                    Graph[j].append(i)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 用一个数组判断节点是否已被访问</span></span><br><span class="line">        visited = [<span class="number">0</span>] * len(A)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(u)</span>:</span></span><br><span class="line">            visited[u] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> Graph[u]:</span><br><span class="line">                <span class="keyword">if</span> visited[v]: <span class="keyword">continue</span></span><br><span class="line">                dfs(v)</span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            <span class="keyword">if</span> visited[i]: <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 一次dfs得到一个连通分量</span></span><br><span class="line">            dfs(i)</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>这道题还挺可惜的，这两种方法用python写都tle了，但是用java,c++都完全ok，就学下思路吧~</p>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dfs </tag>
            
            <tag> union find </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 846 Hand of Straights</title>
      <link href="/2018/06/04/Leetcode-846-Hand-of-Straights/"/>
      <url>/2018/06/04/Leetcode-846-Hand-of-Straights/</url>
      <content type="html"><![CDATA[<p>Alice has a hand of cards, given as an array of integers.<br>Now she wants to rearrange the cards into groups so that each group is size W, and consists of W consecutive cards.<br>Return true if and only if she can.</p><blockquote><p>Example 1:<br>Input: hand = [1,2,3,6,2,3,4,7,8], W = 3<br>Output: true<br>Explanation: Alice’s hand can be rearranged as [1,2,3],[2,3,4],[6,7,8].</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: hand = [1,2,3,4,5], W = 4<br>Output: false<br>Explanation: Alice’s hand can’t be rearranged into groups of 4.</p></blockquote><p>Note:<br>    1 &lt;= hand.length &lt;= 10000<br>    0 &lt;= hand[i] &lt;= 10^9<br>    1 &lt;= W &lt;= hand.length</p><p><strong>分析：将一组数据分为若干组，每组大小都是W，并且是W个连续数(我一开始看错题目了，以为是分成W组，并每组都是W大小，搞得提交错了好几次)</strong></p><p><strong>思路：先判断能不能均分，不能直接False，然后用字典将数组存起来，每次用最小的数开始分析，判断连续W个数是不是都存在，直至字典为空</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNStraightHand</span><span class="params">(self, hand, W)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type hand: List[int]</span></span><br><span class="line"><span class="string">        :type W: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 判断是否能均分</span></span><br><span class="line">        n = len(hand)</span><br><span class="line">        <span class="keyword">if</span> n % W != <span class="number">0</span>: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        d = collections.Counter(hand)</span><br><span class="line">        <span class="keyword">while</span> d:</span><br><span class="line">            m = min(d.keys())</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(W):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> d[m+i]: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                d[m+i] -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 如果数字用光了则删除key值</span></span><br><span class="line">                <span class="keyword">if</span> d[m+i] == <span class="number">0</span>: <span class="keyword">del</span> d[m+i]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="number">65</span> / <span class="number">65</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">1156</span> ms</span><br></pre></td></tr></table></figure><p>因为每次都要取最小值，其实这个复杂度达到了n^2/W,也是测试数据给面子吧，讲道理这个复杂度应该是不行的<br>当然要修改很简单，我们直接对d.keys()从小到大遍历，如果d[i]&gt;0我们才进行操作，否则跳过</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isNStraightHand</span><span class="params">(hand,W)</span>:</span></span><br><span class="line">n = len(hand)</span><br><span class="line"><span class="keyword">if</span> n % W != <span class="number">0</span>: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">d = collections.Counter(hand)</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> sorted(d.keys()):</span><br><span class="line"><span class="keyword">if</span> d[e] &gt; <span class="number">0</span>:</span><br><span class="line"><span class="comment"># 这里倒序遍历是因为要保证d[e]的值最后才变</span></span><br><span class="line"><span class="keyword">for</span> step <span class="keyword">in</span> range(W)[::<span class="number">-1</span>]:</span><br><span class="line">d[e+step] -= d[e]</span><br><span class="line"><span class="keyword">if</span> d[e+step] &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="number">65</span> / <span class="number">65</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">194</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 845 Longest Mountain in Array</title>
      <link href="/2018/06/04/Leetcode-845-Longest-Mountain-in-Array/"/>
      <url>/2018/06/04/Leetcode-845-Longest-Mountain-in-Array/</url>
      <content type="html"><![CDATA[<p>Let’s call any contiguous subarray B (of A) a mountain if the following properties hold:<br>    B.length &gt;= 3<br>    There exists some 0 &lt; i &lt; B.length - 1 such that B[0] &lt; B[1] &lt; … B[i-1] &lt; B[i] &gt; B[i+1] &gt; … &gt; B[B.length - 1]</p><p>(Note that B could be any subarray of A, including the entire array A.)<br>Given an array A of integers, return the length of the longest mountain.<br>Return 0 if there is no mountain.</p><blockquote><p>Example 1:<br>Input: [2,1,4,7,3,2,5]<br>Output: 5<br>Explanation: The largest mountain is [1,4,7,3,2] which has length 5.</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: [2,2,2]<br>Output: 0<br>Explanation: There is no mountain.</p></blockquote><p>Note:<br>    0 &lt;= A.length &lt;= 10000<br>    0 &lt;= A[i] &lt;= 10000</p><p><strong>分析：在一个数组中找最长的先严格上升后严格下降的连续序列，注意A.length达到10000，n^2方法显然不行</strong></p><p><strong>思路：直接遍历一遍，找到一个上升点然后开始遍历，处理一些小情况即可</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestMountain</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># O(n) time, O(1) space</span></span><br><span class="line">        i,n = <span class="number">0</span>,len(A)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n<span class="number">-1</span>:</span><br><span class="line">        <span class="comment">#找到一个上升点</span></span><br><span class="line">            <span class="keyword">if</span> A[i] &lt; A[i+<span class="number">1</span>]:</span><br><span class="line">            <span class="comment"># 先找上升序列</span></span><br><span class="line">                j = i+<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> j &lt; n <span class="keyword">and</span> A[j] &gt; A[j<span class="number">-1</span>]: j += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 如若遍历到数组末尾直接返回结果</span></span><br><span class="line">                <span class="keyword">if</span> j == n: <span class="keyword">return</span> res</span><br><span class="line">                <span class="comment"># 这个判断语句处理[1,2,2,0]这种情况</span></span><br><span class="line">                <span class="keyword">if</span> A[j] != A[j<span class="number">-1</span>]: </span><br><span class="line">                    <span class="keyword">while</span> j &lt; n <span class="keyword">and</span> A[j] &lt; A[j<span class="number">-1</span>]: j += <span class="number">1</span></span><br><span class="line">                    res = max(res,j-i)</span><br><span class="line">                    i = j<span class="number">-2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    i = j<span class="number">-1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">O(n) time, O(<span class="number">1</span>) space</span><br><span class="line"><span class="number">72</span> / <span class="number">72</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">73</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 844 Backspace String Compare</title>
      <link href="/2018/06/04/Leetcode-844-Backspace-String-Compare/"/>
      <url>/2018/06/04/Leetcode-844-Backspace-String-Compare/</url>
      <content type="html"><![CDATA[<p>Given two strings S and T, return if they are equal when both are typed into empty text editors. # means a backspace character.</p><blockquote><p>Example 1:<br>Input: S = “ab#c”, T = “ad#c”<br>Output: true<br>Explanation: Both S and T become “ac”.</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: S = “ab##”, T = “c#d#”<br>Output: true<br>Explanation: Both S and T become “”.</p></blockquote><blockquote><p>Example 3:<br>Input: S = “a##c”, T = “#a#c”<br>Output: true<br>Explanation: Both S and T become “c”.</p></blockquote><blockquote><p>Example 4:<br>Input: S = “a#c”, T = “b”<br>Output: false<br>Explanation: S becomes “c” while T becomes “b”.</p></blockquote><p>Note:<br>    1 &lt;= S.length &lt;= 200<br>    1 &lt;= T.length &lt;= 200<br>    S and T only contain lowercase letters and ‘#’ characters.</p><p><strong>分析：无非就是一个带取消键情况的判断输入是否相等的简单题目</strong></p><p><strong>思路：说实话我第一时间还没反应过来这道题应该用栈这么显而易见的思想，果然还是对这些数据结构太不敏感了，还远远不行啊</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backspaceCompare</span><span class="params">(self, S, T)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :type T: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(s)</span>:</span></span><br><span class="line">            stack = []</span><br><span class="line">            <span class="keyword">for</span> e <span class="keyword">in</span> s:</span><br><span class="line">                <span class="keyword">if</span> e == <span class="string">'#'</span>:</span><br><span class="line">                    <span class="keyword">if</span> stack:</span><br><span class="line">                        stack.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    stack.append(e)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span>.join(stack)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper(S) == helper(T)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">104</span> / <span class="number">104</span> test cases passed.</span><br><span class="line">difficulty: easy</span><br><span class="line">Runtime: <span class="number">38</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> string </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 841 Keys and Rooms</title>
      <link href="/2018/05/28/Leetcode-841-Keys-and-Rooms/"/>
      <url>/2018/05/28/Leetcode-841-Keys-and-Rooms/</url>
      <content type="html"><![CDATA[<p>There are N rooms and you start in room 0.  Each room has a distinct number in 0, 1, 2, …, N-1, and each room may have some keys to access the next room. </p><p>Formally, each room i has a list of keys rooms[i], and each key rooms[i][j] is an integer in [0, 1, …, N-1] where N = rooms.length.  A key rooms[i][j] = v opens the room with number v.</p><p>Initially, all the rooms start locked (except for room 0).<br>You can walk back and forth between rooms freely.<br>Return true if and only if you can enter every room.<br><a id="more"></a></p><blockquote><p>Example 1:<br>Input: [[1],[2],[3],[]]<br>Output: true<br>Explanation:<br>We start in room 0, and pick up key 1.<br>We then go to room 1, and pick up key 2.<br>We then go to room 2, and pick up key 3.<br>We then go to room 3.  Since we were able to go to every room, we return true.</p></blockquote><blockquote><p>Example 2:<br>Input: [[1,3],[3,0,1],[2],[0]]<br>Output: false<br>Explanation: We can’t enter the room with number 2.</p></blockquote><p><strong>Note:</strong></p><pre><code>1. 1 &lt;= rooms.length &lt;= 10002. 0 &lt;= rooms[i].length &lt;= 10003. The number of keys in all rooms combined is at most 3000.</code></pre><p><strong>分析：初始在房间0，每个房间有钥匙，钥匙打开对应的门，可以在打开的门之间任意走动，问能不能打开所有的门，房间数不超过1000，每个房间内钥匙不超过1000</strong></p><p><strong>思路：显然是dfs，用一个visited集合来记录走过了哪些房间，最后判断visied的长度是不是等于房间的长度即可,我觉得这道题不配是medium，应该是easy</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">canVisitAllRoom</span><span class="params">(rooms)</span>:</span></span><br><span class="line">n = len(rooms)</span><br><span class="line">visited = set()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(u)</span>:</span></span><br><span class="line"><span class="keyword">if</span> u <span class="keyword">in</span> visited: <span class="keyword">return</span></span><br><span class="line">visited.add(u)</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> rooms[u]:</span><br><span class="line">dfs(v)</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> len(visited) == n</span><br><span class="line"></span><br><span class="line"><span class="number">66</span> / <span class="number">66</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">39</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 840 Magic Squares In Grid</title>
      <link href="/2018/05/28/Leetcode-840-Magic-Squares-In-Grid/"/>
      <url>/2018/05/28/Leetcode-840-Magic-Squares-In-Grid/</url>
      <content type="html"><![CDATA[<p>A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum.</p><p>Given an grid of integers, how many 3 x 3 “magic square” subgrids are there?  (Each subgrid is contiguous).<br><a id="more"></a></p><blockquote><p><strong>Example 1:</strong><br><strong>Input</strong>:<br>[[4,3,8,4],<br>[9,5,1,9],<br> 2,7,6,2]]<br><strong>Output:</strong> 1<br><strong>Explanation:</strong><br>The following subgrid is a 3 x 3 magic square:<br>438<br>951<br>276<br>while this one is not:<br>384<br>519<br>762<br>In total, there is only one magic square inside the given grid.</p></blockquote><p>Note:<br>    1 &lt;= grid.length &lt;= 10<br>    1 &lt;= grid[0].length &lt;= 10<br>    0 &lt;= grid[i][j] &lt;= 15</p><p><strong>分析：题目定义了一个概念，3x3的矩阵，元素从1到9，横纵对角线之和相等，把这个称为”magic square”，给定一个二维列表，找有多少个magic square，数据长度不超过10 x 10，说明这道题随便写都不会超时</strong></p><p><strong>思路：从1到9取值，那么最中间的数必是5，至于为什么，想不通的我建议你放弃，只要从1，1到n-1,n-1遍历，如果满足值为5就进行判断</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numMagicSquaresInside</span><span class="params">(grid)</span>:</span></span><br><span class="line">m,n = len(grid),len(grid[<span class="number">0</span>])</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isMagic</span><span class="params">(i,j)</span>:</span></span><br><span class="line"><span class="keyword">for</span> x,y <span class="keyword">in</span> [(<span class="number">-1</span>,<span class="number">-1</span>),(<span class="number">-1</span>,<span class="number">0</span>),(<span class="number">-1</span>,<span class="number">1</span>),(<span class="number">0</span>,<span class="number">-1</span>),(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">1</span>,<span class="number">-1</span>),(<span class="number">1</span>,<span class="number">1</span>)]:</span><br><span class="line"><span class="keyword">if</span> grid[i+x][j+y] &gt; <span class="number">9</span> <span class="keyword">or</span> grid[i+x][j+y] &lt; <span class="number">1</span>: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"><span class="keyword">return</span> grid[i<span class="number">-1</span>][j<span class="number">-1</span>]+grid[i+<span class="number">1</span>][j+<span class="number">1</span>] == grid[i+<span class="number">1</span>][j<span class="number">-1</span>]+grid[i<span class="number">-1</span>][j+<span class="number">1</span>] == grid[i][j<span class="number">-1</span>]+grid[i][j+<span class="number">1</span>] == grid[i+<span class="number">1</span>][j]+grid[i<span class="number">-1</span>][j] </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m<span class="number">-1</span>):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n<span class="number">-1</span>):</span><br><span class="line"><span class="keyword">if</span> grid[i][j] == <span class="number">5</span> <span class="keyword">and</span> isMagic(i,j): res += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">87</span> / <span class="number">87</span> test cases passed.</span><br><span class="line">difficulty: easy</span><br><span class="line">Runtime: <span class="number">33</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 611 Valid Triangle Number</title>
      <link href="/2018/05/28/Leetcode-611-Valid-Triangle-Number/"/>
      <url>/2018/05/28/Leetcode-611-Valid-Triangle-Number/</url>
      <content type="html"><![CDATA[<h1 id="Valid-Triangle-Number"><a href="#Valid-Triangle-Number" class="headerlink" title="Valid Triangle Number"></a>Valid Triangle Number</h1><p>Given an array consists of non-negative integers, your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.</p><blockquote><p>Example 1:<br>Input: [2,2,3,4]<br>Output: 3<br>Explanation:<br>Valid combinations are:<br>2,3,4 (using the first 2)<br>2,3,4 (using the second 2)<br>2,2,3</p></blockquote><a id="more"></a><p><strong>Note:</strong><br>    The length of the given array won’t exceed 1000.<br>    The integers in the given array are in the range of [0, 1000].</p><p><strong>分析：这道题就是在一个数组内找有多少个三元组满足三个值能构成一个三角形，（大于两边之差，小于两边之和）。 注意，数据长度不超过1000，n^2的方法可行</strong></p><p><strong>思路：先将数组排序，固定前两个值，遍历第三个值，但是不用重复，比如4，5，6，7，8，9，12；第一次固定4，5，第三个值遍历到9结束，然后5变成6，从9遍历到12，中间一定满足故不用重新遍历</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">triangleNumber</span><span class="params">(nums)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">:type nums: List[int]</span></span><br><span class="line"><span class="string">:rtype: int</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">n = len(nums)</span><br><span class="line">nums.sort()</span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>):</span><br><span class="line">k = i+<span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,n<span class="number">-1</span>):</span><br><span class="line"><span class="keyword">if</span> k == j: k += <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> k &lt; n <span class="keyword">and</span> nums[k] &lt; nums[i] + nums[j]: </span><br><span class="line">k += <span class="number">1</span></span><br><span class="line">res += k - (j+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"220 / 220 test cases passed.</span></span><br><span class="line"><span class="string">difficulty: medium</span></span><br><span class="line"><span class="string">Runtime: 534 ms"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 802 Find Eventual Safe States</title>
      <link href="/2018/05/22/Leetcode-802-Find-Eventual-Safe-States/"/>
      <url>/2018/05/22/Leetcode-802-Find-Eventual-Safe-States/</url>
      <content type="html"><![CDATA[<p><img src="/images/leetcode_802.png" alt="description"><br><a id="more"></a><br><strong>分析：这道题是要在一个图里找不在环路中的节点，显然，dfs遍历即可，不过这里用拓扑排序方法也可以做，因为dfs这个方法我掌握得还不太熟练，老出各种小错误，等我钻研更深之后再补上dfs方法</strong></p><p><strong>思路：记录下每个节点的出度，如果出度为0那必然是环路外的节点，然后将该点以及指向该点的边删除，继续寻找出度为0的点</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eventualSafeNodes</span><span class="params">(self, graph)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type graph: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> graph: <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        n = len(graph)</span><br><span class="line">        <span class="comment"># 用字段存储每个节点的父节点</span></span><br><span class="line">        d = &#123;u:[] <span class="keyword">for</span> u <span class="keyword">in</span> range(n)&#125;</span><br><span class="line">        degree = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> u <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> graph[u]:</span><br><span class="line">                d[v].append(u)</span><br><span class="line">            degree[u] = len(graph[u])</span><br><span class="line"></span><br><span class="line">        Q = [u <span class="keyword">for</span> u <span class="keyword">in</span> range(n) <span class="keyword">if</span> degree[u]==<span class="number">0</span>]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> Q:</span><br><span class="line">            node = Q.pop()</span><br><span class="line">            res.append(node)</span><br><span class="line">            <span class="keyword">for</span> nodes <span class="keyword">in</span> d[node]:</span><br><span class="line">                degree[nodes] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> degree[nodes] == <span class="number">0</span>:</span><br><span class="line">                    Q.append(nodes)</span><br><span class="line">        <span class="keyword">return</span> sorted(res)</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dfs </tag>
            
            <tag> topsort </tag>
            
            <tag> graph </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 838 Push Dominoes</title>
      <link href="/2018/05/22/Leetcode-838-Push-Dominoes/"/>
      <url>/2018/05/22/Leetcode-838-Push-Dominoes/</url>
      <content type="html"><![CDATA[<p><img src="/images/leetcode_838_1.png" alt="图1"><br><a id="more"></a><br><img src="/images/leetcode_838_2.png" alt="图2"></p><p>分析：就是一个超简单的推木板游戏，我是搞不懂为什么discuss里面那么多人还tle呢，直接遍历一遍就可以出结果，one pass solution,O(1) space, 要不是英文不太好就去发攻略了罒ω罒</p><p>思路：用res存储最后的结果，遍历整个字符串，’.’直接跳过，当遍历到’L’时，看上一个出现的是’L’还是’R’,如果是’L’，全往左边倒，如果是’R’，计算距离一半R一半L；遍历到’R’同理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pushDominoes</span><span class="params">(self, dominoes)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type dominoes: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 上一个出现的关键点用last表示，初始为None，处理左边界情况</span></span><br><span class="line">        last = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(dominoes):</span><br><span class="line">            j = i</span><br><span class="line">            <span class="comment"># 遍历到'.'就不管，一直到找到一个'R或L'为止</span></span><br><span class="line">            <span class="keyword">while</span> j+<span class="number">1</span> &lt; len(dominoes) <span class="keyword">and</span> dominoes[j] == <span class="string">'.'</span>: j += <span class="number">1</span> </span><br><span class="line">            <span class="comment"># 找到L的情况</span></span><br><span class="line">            <span class="keyword">if</span> dominoes[j] == <span class="string">'L'</span>:</span><br><span class="line">                <span class="keyword">if</span> last == <span class="string">'R'</span>:</span><br><span class="line">                    res += (j-i)/<span class="number">2</span> * <span class="string">'R'</span> + (j-i)%<span class="number">2</span> * <span class="string">'.'</span> + (j-i)/<span class="number">2</span> * <span class="string">'L'</span> + <span class="string">'L'</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res += <span class="string">'L'</span> * (j-i+<span class="number">1</span>)</span><br><span class="line">                last = <span class="string">'L'</span></span><br><span class="line">            <span class="comment"># 找到R的情况</span></span><br><span class="line">            <span class="keyword">elif</span> dominoes[j] == <span class="string">'R'</span>:</span><br><span class="line">                <span class="keyword">if</span> last == <span class="string">'R'</span>:</span><br><span class="line">                    res += (j-i+<span class="number">1</span>) * <span class="string">'R'</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res += (j-i) * <span class="string">'.'</span> + <span class="string">'R'</span></span><br><span class="line">                last = <span class="string">'R'</span></span><br><span class="line">            i = j + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 出来之后，处理右边界情况</span></span><br><span class="line">        <span class="keyword">if</span> last == <span class="string">'R'</span>:</span><br><span class="line">            res += <span class="string">'R'</span> * (len(dominoes)-len(res))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res += <span class="string">'.'</span> * (len(dominoes)-len(res))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">36</span> / <span class="number">36</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">244</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 836 Rectangle Overlap</title>
      <link href="/2018/05/22/Leetcode-836-Rectangle-Overlap/"/>
      <url>/2018/05/22/Leetcode-836-Rectangle-Overlap/</url>
      <content type="html"><![CDATA[<p>A rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) are the coordinates of its bottom-left corner, and (x2, y2) are the coordinates of its top-right corner.</p><p>Two rectangles overlap if the area of their intersection is positive.  To be clear, two rectangles that only touch at the corner or edges do not overlap.</p><p>Given two rectangles, return whether they overlap.<br><a id="more"></a></p><blockquote><p>Example 1:<br>Input: rec1 = [0,0,2,2], rec2 = [1,1,3,3]<br>Output: true</p></blockquote><blockquote><p>Example 2:<br>Input: rec1 = [0,0,1,1], rec2 = [1,0,2,1]<br>Output: false</p></blockquote><p><strong>Notes:</strong><br>    1.Both rectangles rec1 and rec2 are lists of 4 integers.<br>    2.All coordinates in rectangles will be between -10^9 and 10^9.</p><p><strong>分析：常见的矩阵题型，由左下和右上两个点确定一个矩形，判断两个矩形是否有重叠部分，这和之前有一道题非常的相似，那道题是直接求重叠面积</strong></p><p><strong>思路：记住下面这个固定公式，很有用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isRectangleOverlap</span><span class="params">(rec1, rec2)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type rec1: List[int]</span></span><br><span class="line"><span class="string">    :type rec2: List[int]</span></span><br><span class="line"><span class="string">    :rtype: bool</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    a,b,c,d = rec1</span><br><span class="line">    e,f,g,h = rec2</span><br><span class="line">    <span class="keyword">return</span> max(<span class="number">0</span>,min(c,g)-max(e,a)) * max(<span class="number">0</span>,min(d,h)-max(f,b)) != <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">43</span> / <span class="number">43</span> test cases passed.</span><br><span class="line">difficulty: easy</span><br><span class="line">Runtime: <span class="number">31</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 837 New 21 Game</title>
      <link href="/2018/05/22/Leetcode-837-New-21-Game/"/>
      <url>/2018/05/22/Leetcode-837-New-21-Game/</url>
      <content type="html"><![CDATA[<p>Alice plays the following game, loosely based on the card game “21”.</p><p>Alice starts with 0 points, and draws numbers while she has less than K points.  During each draw, she gains an integer number of points randomly from the range [1, W], where W is an integer.  Each draw is independent and the outcomes have equal probabilities.</p><p>Alice stops drawing numbers when she gets K or more points.  What is the probability that she has N or less points?</p><blockquote><p>Example 1:<br>Input: N = 10, K = 1, W = 10<br>Output: 1.00000<br>Explanation:  Alice gets a single card, then stops.</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: N = 6, K = 1, W = 10<br>Output: 0.60000<br>Explanation:  Alice gets a single card, then stops.<br>In 6 out of W = 10 possibilities, she is at or below N = 6 points.</p></blockquote><blockquote><p>Example 3:<br>Input: N = 21, K = 17, W = 10<br>Output: 0.73278</p></blockquote><p><strong>Note:</strong><br>    1.0 &lt;= K &lt;= N &lt;= 10000<br>    2.1 &lt;= W &lt;= 10000<br>    3.Answers will be accepted as correct if they are within 10^-5 of the correct answer.<br>    4.The judging time limit has been reduced for this question.</p><p>分析：这道题是在求概率，在已有点数不超过K的情况下从1至w中选数，之后和不超过N,注意K,N,W可以取到10000,所以N^2是肯定不行的，并且递归也会超出最大深度(即使使用记忆化也不行)。</p><p>思路：使用动态规划，dp[i]表示点数和为i的概率，那么最后结果应该是dp[k]+dp[k+1]+…+dp[n]<br>其中，dp[i]又应该为前w个的dp的平均值<br>例如W=10，那么dp[20] = 1/10 * (dp[10]+dp[11]+…+dp[19])</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new21Game</span><span class="params">(N, K, W)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> K == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    dp = [<span class="number">1.0</span>] + [<span class="number">0.0</span>] * N</span><br><span class="line">    <span class="comment"># 用Wsum 记录前w个dp之和</span></span><br><span class="line">    Wsum = <span class="number">1.0000</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N + <span class="number">1</span>):</span><br><span class="line">        dp[i] = Wsum / W</span><br><span class="line">        <span class="keyword">if</span> i &lt; K: Wsum += dp[i]</span><br><span class="line">        <span class="comment"># 假设K = 15，那么上面的例子d[20] = 1/10 * (dp[10]+...+dp[14]),因为拿到15之后就不能拿了，所以不存在从15拿5拿到20的情况</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= i - W &lt; K: Wsum -= dp[i - W]</span><br><span class="line">    <span class="keyword">return</span> sum(dp[K:])</span><br><span class="line"></span><br><span class="line"><span class="number">146</span> / <span class="number">146</span> test cases passed.</span><br><span class="line">difficulty: medium</span><br><span class="line">Runtime: <span class="number">122</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 459 Repeated Substring Pattern</title>
      <link href="/2018/05/19/Leetcode-459-Repeated-Substring-Pattern/"/>
      <url>/2018/05/19/Leetcode-459-Repeated-Substring-Pattern/</url>
      <content type="html"><![CDATA[<p>Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.</p><blockquote><p>Example 1:<br>Input: “abab”<br>Output: True<br>Explanation: It’s the substring “ab” twice.&gt;</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: “aba”<br>Output: False&gt;</p></blockquote><blockquote><p>Example 3:<br>Input: “abcabcabcabc”<br>Output: True<br>Explanation: It’s the substring “abc” four times. (And the substring “abcabc” twice.)</p></blockquote><p><strong>分析：这道题是判断一个字符串是不是某个字符串重复若干次的问题</strong></p><p><strong>思路：写在这里就是想秀一下我的一行代码，嗨呀，是真滴骚！</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repeatSubstringPattern</span><span class="params">(s)</span>:</span></span><br><span class="line"><span class="keyword">return</span> any(s[:i]*(len(s)//i)==s <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(s)) <span class="keyword">if</span> s[i] == s[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="number">107</span> / <span class="number">107</span> test cases passed.</span><br><span class="line">difficulty: easy</span><br><span class="line">Runtime: <span class="number">330</span> ms</span><br></pre></td></tr></table></figure><p>感叹：我还是急了，这道题要是仔细想一下肯定不会这样的,这个解法还是有点东西的，用反证法很容易证<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repeatSubstringPattern</span><span class="params">(s)</span>:</span></span><br><span class="line"><span class="keyword">return</span> s <span class="keyword">in</span> (s+s)[<span class="number">1</span>:<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 821 Shortest Distance to a Character</title>
      <link href="/2018/05/11/Leetcode-821-Shortest-Distance-to-a-Character/"/>
      <url>/2018/05/11/Leetcode-821-Shortest-Distance-to-a-Character/</url>
      <content type="html"><![CDATA[<p>Given a string S and a character C, return an array of integers representing the shortest distance from the character C in the string.</p><blockquote><p><strong>Example 1:</strong><br>Input: S = “loveleetcode”, C = ‘e’<br>Output: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]</p></blockquote><a id="more"></a><p><strong>Note:</strong><br>    S string length is in [1, 10000].<br>    C is a single character, and guaranteed to be in string S.<br>    All letters in S and C are lowercase.</p><p><strong>分析：找S中所有元素距离给定C的最小距离，注意数据长度10000，说明n^2不行</strong></p><p><strong>思路：先将S中所有的C的位置找出来，然后以这些位置两两为一段，对这一段中的元素判断离那边端点更近就OK，-1处和len(s)处默认有一个，这两个边界问题注意处理</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shortestToChar</span><span class="params">(S, C)</span>:</span></span><br><span class="line">    res = [<span class="number">-1</span>] * len(S)</span><br><span class="line">    <span class="comment"># 找到所有的C的位置</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(S)):</span><br><span class="line">        <span class="keyword">if</span> S[i] == C: res[i] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 左边界定为-1</span></span><br><span class="line">    i = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(S):</span><br><span class="line">        j = i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; len(S) <span class="keyword">and</span> res[j] != <span class="number">0</span>: j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> xrange(i+<span class="number">1</span>,j):</span><br><span class="line">        <span class="comment"># 如果在左边界</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">-1</span>:</span><br><span class="line">                res[k] = j-k</span><br><span class="line">            <span class="comment"># 如果到达右边界</span></span><br><span class="line">            <span class="keyword">elif</span> j == len(S):</span><br><span class="line">                res[k] = k-i</span><br><span class="line">            <span class="comment"># 在中间</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[k] = min(j-k,k-i)</span><br><span class="line">        i = j</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 822 Card Flipping Game</title>
      <link href="/2018/05/11/Leetcode-822-Card-Flipping-Game/"/>
      <url>/2018/05/11/Leetcode-822-Card-Flipping-Game/</url>
      <content type="html"><![CDATA[<p>On a table are N cards, with a positive integer printed on the front and back of each card (possibly different).</p><p>We flip any number of cards, and after we choose one card. </p><p>If the number X on the back of the chosen card is not on the front of any card, then this number X is good.</p><p>What is the smallest number that is good?  If no number is good, output 0.<br><a id="more"></a><br>Here, fronts[i] and backs[i] represent the number on the front and back of card i. </p><p>A flip swaps the front and back numbers, so the value on the front is now on the back and vice versa.</p><p><strong>Example:</strong><br>Input: fronts = [1,2,4,4,7], backs = [1,3,4,1,3]<br>Output: 2<br>Explanation: If we flip the second card, the fronts are [1,3,4,4,7] and the backs are [1,2,4,1,3].<br>We choose the second card, which has number 2 on the back, and it isn’t on the front of any card, so 2 is good.</p><p><strong>Note:</strong><br>    1 &lt;= fronts.length == backs.length &lt;= 1000.<br>    1 &lt;= fronts[i] &lt;= 2000.<br>    1 &lt;= backs[i] &lt;= 2000.</p><p><strong>分析：如果我们从fronts 和 backs中最小的数开始考虑，在example中就是1,那么1对应着两张卡，分别是 1，1 和 1，4，对于1，1我们无论如何翻转1都会在正面出现，所以1不可能是good number；对于2来说，2对应着2，3一张卡，那么只要将3朝上，fronts中就没了2,(关键就是只要一个数不是同时出现在一张卡的正反两面，我们通过一定的翻转就一定可以使这个数成为good number)，因为我们是从小到大遍历，所以此时2就是最后答案。注意数据长度不超过1000，数据值不超过2000，说明n^2的方案是可行的</strong></p><p><strong>思路：我们将fronts和backs里面出现的数对应的另一面的数字记录下来，比如对于1这个数字，记录他对应着1，4着两个数，然后从小到大遍历，第一个没出现相同对应数字的数就是答案</strong></p><p><strong>总结：这道题稍微想一下并不难，但是在leetcode上踩的人有丶多，说明大家对单纯的逻辑题的解法还是不太熟。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flipgame</span><span class="params">(fronts, backs)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> collections</span><br><span class="line">    n = len(fronts)</span><br><span class="line">    d = collections.defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">        d[fronts[i]].append(backs[i])</span><br><span class="line">        d[backs[i]].append(fronts[i])</span><br><span class="line"></span><br><span class="line">    rec = fronts + backs</span><br><span class="line">    rec.sort()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> rec:</span><br><span class="line">        <span class="keyword">if</span> e <span class="keyword">not</span> <span class="keyword">in</span> d[e]:</span><br><span class="line">            <span class="keyword">return</span> e</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">time: O(n)</span><br><span class="line">space: O(n)</span><br><span class="line">difficulty: medium</span><br><span class="line"><span class="number">169</span> / <span class="number">169</span> test cases passed</span><br><span class="line">runtime: <span class="number">85</span> ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 823 Binary Trees With Factors</title>
      <link href="/2018/05/11/Leetcode-823-Binary-Trees-With-Factors/"/>
      <url>/2018/05/11/Leetcode-823-Binary-Trees-With-Factors/</url>
      <content type="html"><![CDATA[<p>Given an array of unique integers, each integer is strictly greater than 1.</p><p>We make a binary tree using these integers and each number may be used for any number of times.</p><p>Each non-leaf node’s value should be equal to the product of the values of it’s children.</p><p>How many binary trees can we make?  Return the answer modulo 10 ** 9 + 7.<br><a id="more"></a><br><strong>Example 1:</strong><br>Input: A = [2, 4]<br>Output: 3<br>Explanation: We can make these trees: [2], [4], [4, 2, 2]</p><p><strong>Example 2:</strong><br>Input: A = [2, 4, 5, 10]<br>Output: 7<br>Explanation: We can make these trees: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].</p><p><strong>Note:</strong><br>    1 &lt;= A.length &lt;= 1000.<br>    2 &lt;= A[i] &lt;= 10 ^ 9.</p><p><strong>分析：构建一个所有父节点的值等于其子节点的值的乘积的树，问有多少种构建方法，注意数据长度小于1000，说明n^2复杂度是可行的</strong></p><p><strong>思路：比如[2,5,10,20],对于20由2和10组成，10又可以由2和5组成，所以组成20的方法应该是组成2的方法数乘以组成10的方法数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numFactoredBinaryTrees</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> collections</span><br><span class="line">    A.sort()</span><br><span class="line">    d = collections.Counter(A)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(A)):</span><br><span class="line">    <span class="comment">#从比他小的数里遍历，找到因子然后进行判断！</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i):</span><br><span class="line">            <span class="keyword">if</span> A[i] % A[j] == <span class="number">0</span> <span class="keyword">and</span> A[i]/A[j] <span class="keyword">in</span> d:</span><br><span class="line">                d[A[i]] += d[A[j]] * d[A[i]/A[j]]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum(d.values()) % (<span class="number">10</span>**<span class="number">9</span>+<span class="number">7</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dp </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 824 Goat Latin</title>
      <link href="/2018/05/11/Leetcode-824-Goat-Latin/"/>
      <url>/2018/05/11/Leetcode-824-Goat-Latin/</url>
      <content type="html"><![CDATA[<p><img src="/images/leetcode_824_1.png" alt="图1"></p><p><img src="/images/leetcode_824_2.png" alt="图2"><br><a id="more"></a><br><strong>分析：这道题是真的弱智</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">toGoatLatin</span><span class="params">(S)</span>:</span></span><br><span class="line">    res = S.split()</span><br><span class="line">    <span class="keyword">for</span> i,s <span class="keyword">in</span> enumerate(res):</span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] <span class="keyword">in</span> <span class="string">'aeiouAEIOU'</span>:</span><br><span class="line">            res[i] = s + <span class="string">'ma'</span> + <span class="string">'a'</span>*(i+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res[i] = s[<span class="number">1</span>:]+s[<span class="number">0</span>] + <span class="string">'ma'</span> + <span class="string">'a'</span>*(i+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">' '</span>.join(res)</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode_825_Friends_Of_Appropriate_Ages</title>
      <link href="/2018/05/11/Leetcode-825-Friends-Of-Appropriate-Ages/"/>
      <url>/2018/05/11/Leetcode-825-Friends-Of-Appropriate-Ages/</url>
      <content type="html"><![CDATA[<p>Some people will make friend requests. The list of their ages is given and ages[i] is the age of the ith person. </p><p>Person A will NOT friend request person B (B != A) if any of the following conditions are true:</p><p>1.age[B] &lt;= 0.5 * age[A] + 7<br>2.age[B] &gt; age[A]<br>3.age[B] &gt; 100 &amp;&amp; age[A] &lt; 100<br>Otherwise, A will friend request B.</p><p>Note that if A requests B, B does not necessarily request A.  Also, people will not friend request themselves.</p><p>How many total friend requests are made?<br><a id="more"></a><br><strong>Example 1:</strong><br>Input: [16,16]<br>Output: 2<br>Explanation: 2 people friend request each other.</p><p><strong>Example 2:</strong><br>Input: [16,17,18]<br>Output: 2<br>Explanation: Friend requests are made 17 -&gt; 16, 18 -&gt; 17.</p><p><strong>Example 3:</strong><br>Input: [20,30,100,110,120]<br>Output: 3<br>Explanation: Friend requests are made 110 -&gt; 100, 120 -&gt; 110, 120 -&gt; 100.</p><p><strong>Notes:</strong><br>    1 &lt;= ages.length &lt;= 20000.<br>    1 &lt;= ages[i] &lt;= 120.</p><p><strong>分析：对于A这个人交朋友来说，根据条件2比他年级大的一概排除，比他年级小的要满足条件1，条件3没用，不知道这个出题的人在想什么，注意数据长度达到20000，所以复杂度n^2是不行的</strong></p><p><strong>思路：首先将ages数组从大到小排序，然后用两个指针遍历即可</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numFriendRequests</span><span class="params">(ages)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(ages) == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    ages.sort(reverse=<span class="keyword">True</span>)</span><br><span class="line">    i,j = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(ages):</span><br><span class="line">        <span class="keyword">while</span> j &lt; len(ages) <span class="keyword">and</span> ages[j] &gt; <span class="number">0.5</span>*ages[i] + <span class="number">7</span>:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果对于age[0]来说,age[1,2,3,4,5]他都可以交朋友</span></span><br><span class="line">        <span class="comment"># 那么对于age[1]来说,age[2,3,4,5]也是必可以的，所以只用遍历一遍就可以了</span></span><br><span class="line">        res += j - i - <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; len(ages) <span class="keyword">and</span> ages[i] &gt; <span class="number">14</span>:</span><br><span class="line">            <span class="keyword">if</span> ages[i] == ages[i<span class="number">-1</span>]: res += cnt + <span class="number">1</span>;cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= j: j = i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="string">"difficulty: medium</span></span><br><span class="line"><span class="string">83 / 83 test cases passed</span></span><br><span class="line"><span class="string">runtime: 305 ms"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode_826_Most_Profit_Assigning_Work</title>
      <link href="/2018/05/11/Leetcode-826-Most-Profit-Assigning-Work/"/>
      <url>/2018/05/11/Leetcode-826-Most-Profit-Assigning-Work/</url>
      <content type="html"><![CDATA[<p>We have jobs: difficulty[i] is the difficulty of the ith job, and profit[i] is the profit of the ith job. </p><p>Now we have some workers. worker[i] is the ability of the ith worker, which means that this worker can only complete a job with difficulty at most worker[i]. </p><p>Every worker can be assigned at most one job, but one job can be completed multiple times.</p><p>For example, if 3 people attempt the same job that pays $1, then the total profit will be $3.  If a worker cannot complete any job, his profit is $0.</p><p>What is the most profit we can make?<br><a id="more"></a></p><blockquote><p><strong>Example 1:</strong><br>Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]<br>Output: 100<br>Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get profit of [20,20,30,30] seperately.</p></blockquote><p><strong>Notes:</strong><br>    1 &lt;= difficulty.length = profit.length &lt;= 10000<br>    1 &lt;= worker.length &lt;= 10000<br>    difficulty[i], profit[i], worker[i]  are in range [1, 10^5]</p><p><strong>分析：每个人有一个能力值，只能做难度低于自身能力值的工作，每个工作有报酬，设计一个方法让报酬最大，注意数据长度为10000，数据值不超过100000，这说明复杂度n^2是不行的</strong></p><p><strong>思路：用动态规划思想，dp[i]表示能力值为i的工人最多能拿多少报酬，i最多不超过100000，所以空间不会超出，那么结果就是sum(dp[i] for i in worker)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfitAssignment</span><span class="params">(difficulty, profit, worker)</span>:</span></span><br><span class="line">    d = collections.defaultdict(int)</span><br><span class="line">    key = set(difficulty)</span><br><span class="line">    dp = [<span class="number">0</span>] * (max(worker)+<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 可能存在相同困难度的工作有不同的报酬，这里只将最高的报酬记录</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(difficulty)):</span><br><span class="line">        d[difficulty[i]] = max(d[difficulty[i]], profit[i])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(dp)):</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> key:</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-1</span>],d[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(worker)):</span><br><span class="line">        res += dp[worker[i]]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="string">"difficulty: medium</span></span><br><span class="line"><span class="string">57 / 57 test cases passed</span></span><br><span class="line"><span class="string">runtime: 559 ms"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dp </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode_827_Making_A_Large_Island</title>
      <link href="/2018/05/11/Leetcode-827-Making-A-Large-Island/"/>
      <url>/2018/05/11/Leetcode-827-Making-A-Large-Island/</url>
      <content type="html"><![CDATA[<p>In a 2D grid of 0s and 1s, we change at most one 0 to a 1.</p><p>After, what is the size of the largest island? (An island is a 4-directionally connected group of 1s).</p><blockquote><p>Example 1:<br>Input: [[1, 0], [0, 1]]<br>Output: 3<br>Explanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3.</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: [[1, 1], [1, 0]]<br>Output: 4<br>Explanation: Change the 0 to 1 and make the island bigger, only one island with area = 1.</p></blockquote><blockquote><p>Example 3:<br>Input: [[1,1],[1,1]]<br>Output: 4<br>Explanation: 4</p></blockquote><p>Notes:<br>    1 &lt;= grid.length = grid[0].length &lt;= 50.<br>    0 &lt;= grid[i][j] &lt;= 1.</p><p><strong>分析：这道题意思就是把连续的1认为是一块地,现在可以将某个0改成1，使连续的1最多，并求出对应的数量。<br>先看一下变量的取值，长宽都是50，则最多2500个元素，这告诉我们n^2复杂度是可以的</strong></p><p><strong>思路：我们给每块地进行编号，然后记录下这块地的大小，最后找0的时候将0周边不同地的面积相加最大的就是结果</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largestIsland</span><span class="params">(grid)</span>:</span></span><br><span class="line">    directions = ((<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">-1</span>,<span class="number">0</span>),(<span class="number">0</span>,<span class="number">-1</span>))</span><br><span class="line">    area = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">    index = <span class="number">2</span> <span class="comment"># grid中包含0，1，所以地的编号从2开始必不会重复</span></span><br><span class="line">    n = len(grid)</span><br><span class="line">    <span class="comment"># 用dfs计算一块地的面积，并修改grid</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i,j,index)</span>:</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        grid[i][j] = index</span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> directions:</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>&lt;=i+x&lt;n <span class="keyword">and</span> <span class="number">0</span>&lt;=j+y&lt;n:</span><br><span class="line">                <span class="keyword">if</span> grid[i+x][j+y] == <span class="number">1</span>:</span><br><span class="line">                    res += dfs(i+x,j+y,index)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用area数组记录对应地的面积</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                area.append(dfs(i,j,index))</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="number">0</span>:</span><br><span class="line">                s = set()</span><br><span class="line">                <span class="keyword">for</span> x,y <span class="keyword">in</span> directions:</span><br><span class="line">                    <span class="keyword">if</span> <span class="number">0</span>&lt;=i+x&lt;n <span class="keyword">and</span> <span class="number">0</span>&lt;=j+y&lt;n <span class="keyword">and</span> grid[i+x][j+y]&gt;<span class="number">1</span>:</span><br><span class="line">                        s.add(grid[i+x][j+y])</span><br><span class="line">                res = max(res,sum(area[i] <span class="keyword">for</span> i <span class="keyword">in</span> s)+<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 如果grid中全为1，上一个循环中的判断就进不去，res就为0，此时结果应该为grid的面积</span></span><br><span class="line">    <span class="keyword">return</span> res <span class="keyword">or</span> n**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="string">"difficulty:hard</span></span><br><span class="line"><span class="string">63/63 test cases passed</span></span><br><span class="line"><span class="string">runtime: 127ms"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 829 Consecutive Numbers Sum</title>
      <link href="/2018/05/10/Leetcode-829-Consecutive-Numbers-Sum/"/>
      <url>/2018/05/10/Leetcode-829-Consecutive-Numbers-Sum/</url>
      <content type="html"><![CDATA[<p>Given a positive integer N,how many ways can we write it as a sum of consecutive positive integers?</p><p><strong>Example 1:</strong></p><blockquote><p>Input: 5<br>Output: 2<br>Explanation: 5 = 5 = 2+3</p></blockquote><a id="more"></a><p><strong>Example 2:</strong></p><blockquote><p>Input: 9<br>Output: 3<br>Explanation: 9 = 9 = 4+5 = 2+3+4</p></blockquote><p><strong>Example 3:</strong></p><blockquote><p>Input: 15<br>Output: 4<br>Explanation: 15 = 15 = 7+8 = 4+5+6 = 1+2+3+4+5</p></blockquote><p>Note: 1&lt;=N&lt;=10^9</p><p>思路：这道题就是问一个数写成若干个连续正整数的和共有多少种形式？那么就非常简单了<br>如果能写成1个连续的整数，那么这个数能表示成a<br>如果能写成2个连续的整数，那么这个数能表示成a+(a+1)=2<em>a+1<br>如果能写成3个连续的整数，那么这个数能表示成a+(a+1)+(a+2)=3</em>a+3<br>如果能写成n个连续的整数，那么这个数能表示成n<em>a+n</em>(n-1)/2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consecutiveNumbersSum</span><span class="params">(N)</span>:</span></span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    n = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        divisor = N - (n<span class="number">-1</span>)*n/<span class="number">2</span></span><br><span class="line">        <span class="comment"># 因为a至少为1，所以一旦小于就可以直接返回结果</span></span><br><span class="line">        <span class="keyword">if</span> divisor &lt; n: <span class="keyword">return</span> res</span><br><span class="line">        res += divisor%n==<span class="number">0</span></span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="string">"difficulty: medium</span></span><br><span class="line"><span class="string">170 / 170 test cases passed.</span></span><br><span class="line"><span class="string">Runtime: 238 ms"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何搭建一个这样的博客？</title>
      <link href="/2018/05/10/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%B6%85%E9%AA%9A%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%9F/"/>
      <url>/2018/05/10/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%B6%85%E9%AA%9A%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>在一次突发奇想觉得该记录一下我做的各种事情后，便开始有了搭建一个博客的想法。</p><p>但是普通的CSDN或者其他的吧，就感觉挺没有逼格的，刚好记得有人说过可以用Github做博客，便疯狂百度如何用github搭建自己的博客，历经各种意外事件最后好歹也算搭建起来了⑧，搭建完确认无误之后第一件事那必是记录下搭建博客的整个过程。(不过刚好赶上报告的deadline，写报告加开会拖了好久)<br><a id="more"></a><br>前言，<strong>我不建议完全不懂代码的人用github搭建博客</strong>，虽说过程不是很复杂，但是对于没接触过代码的人可能看着攻略也弄不好，并且就算搭建成功了之后写博客的时候还要用到Markdown语法，还有点小麻烦。</p><h2 id="github配置"><a href="#github配置" class="headerlink" title="github配置"></a>github配置</h2><p>首先，你需要一个github账号，注册的过程不用我多说了吧！<br>注册完毕之后进入主界面，点击右上角+号里的New repository,要注意的一点是你的repository name必须和Owner下的名字是一致的，否则之后会出现很多问题，如图1所示：</p><p><img src="/images/如何搭建博客_1.png" alt="图1"></p><p>点击创建后切换到settings界面进行设置，如图2所示：</p><p><img src="/images/如何搭建博客_2.png" alt="图二"></p><p>在settings界面，你可以在github pages这一栏中看到你的博客部署的网址，如图三所示，你也可以点击 choose a theme给自己的博客选择一个主题。在最底部的danger zone中可以删除整个repository！！！</p><p><img src="/images/如何搭建博客_3.png" alt="图三"></p><p>OK！你现在已经可以点进去这个网址看一下了，虽然里面什么都没有就是了。不过这便有了基础，任何人都可以通过这个网址来访问你的博客，如果你嫌这个网址很丑，你也可以去购买一个你喜欢的域名，然后可以通过一定的设置绑定那个域名。(必须提一句买域名并不贵，不过我目前博客里还没什么东西，等内容多一点之后我必买一个！等买了之后再补上绑定域名的方法)</p><h2 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h2><p>接下来需要下载两个软件: node.js 和 git，下载链接在下面百度云中。<br>两个软件都是标准的windows软件安装模式，中间配置建议全部默认！<br>安装完成后打开cmd命令行，输入如下命令，出现某个版本号即为安装成功,如图四所示：<br>链接：<a href="https://pan.baidu.com/s/1D5amENHdqaB8Qmk88I2_sw" target="_blank" rel="noopener">https://pan.baidu.com/s/1D5amENHdqaB8Qmk88I2_sw</a><br>密码：s6t9<br><img src="/images/如何搭建博客_4.png" alt="图四"><br>在电脑任何位置单机鼠标右键出现下图所示：<br><img src="/images/如何搭建博客_5.png" alt="图五"></p><hr><p>好，目前前期配置基本结束，可以开始进行搭建博客了。<br>在你的电脑的某个合适位置创建一个文件夹，例如命名为blog，然后通过命令行进入blog文件夹<br><img src="/images/如何搭建博客_6.png" alt="图六"><br><img src="/images/如何搭建博客_7.png" alt="图七"></p><ol><li>输入npm install hexo -g，开始安装hexo，如何提示没有npm命令说明之前的node.js没有安装好（因为我已经装好了所以没法再装一遍提供截图…）</li><li>然后输入 hexo -v 检查hexo是否安装成功<br><img src="/images/如何搭建博客_8.png" alt="图8"></li><li>输入hexo init，这一步需要一点等待时间，成功标志为最后显示start blogging with Hexo</li><li>依次输入npm install, hexo g, hexo s，即可开启本地服务器，开始使用blog<br><img src="/images/如何搭建博客_9.png" alt=""><br><code>这里实在没办法给全部截图，都是最初时期的配置，等你们配好了你们就会理解这里真的很难给...</code></li><li>输入上面图中给出的地址，即可进入博客的本地界面，若界面一直无法跳转，先使用ctrl+c终止，然后输入 hexo server -p 5000，不过一般不会出现这个情况。</li></ol><h2 id="github和本地联动"><a href="#github和本地联动" class="headerlink" title="github和本地联动"></a>github和本地联动</h2><p>OK，上面过程将本地博客配置完成，那么如何将本地博客与github连接起来呢，这时候就要用到之前安装的git，我们先进入之前存放blog文件夹的地方，右键空白处然后点击git bash here<br><img src="/images/如何搭建博客_10.png" alt=""></p><ol><li>输入 git config –global user.name “填你自己的名字”<br><img src="/images/如何搭建博客_11.png" alt=""></li><li>输入git config –global user.email “填你自己的邮箱”<br><img src="/images/如何搭建博客_12.png" alt=""></li><li>输入 cd ~/.ssh，检查是否有.ssh文件夹，没有是最好的，但如果有也没关系（不一定出问题，先按照下面的步骤走）。</li><li>输入 ssh-keygen -t- rsa -C “your email”，这里email和上面的保持一致，有三个配置需要你输入，但是建议全部为空就完事了（敲三个回车），最后生成了两个文件，id_rsa和id_rsa.pub，存储路径为：C:/Users/Administrator/.ssh</li><li>输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent<br>进入github网页中，添加ssh，先进入setting，再进入ssh and gpg keys<br><img src="/images/如何搭建博客_13.png" alt=""><br><img src="/images/如何搭建博客_14.png" alt=""><br>新建一个ssh key，起个名字，然后将之前生成的id_rsa.pub文件的内容复制进来（用记事本打开）</li><li>输入ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>，测试ssh是否成功，中间可能出现几个配置选择不过不重要，如果最后看到hi your name，就说明配置成功！<br><code>现在回看第三步，如果出问题了怎么办呢，那得把之前已经存在的ssh文件夹删掉，然后在按照这个过程走一遍</code></li></ol><hr><p>到这里可以说基本配置完成了，最后一步，进入blog文件夹，打开_config.yml文件<code>(这个文件很重要，基本修改配置都是在这，一般称为站点配置文件，而不同的主题的下面也自带有这个文件，一般称为主题配置文件)</code>，在最后补上一些记录，其中repository值是你自己的ssh值，在github中可以查看<br><img src="/images/如何搭建博客_15.png" alt=""><br><img src="/images/如何搭建博客_16.png" alt=""><br>最后在命令行中输入npm install hexo-deployer-git –save<br><img src="/images/如何搭建博客_17.png" alt=""><br>OK，全部搞定，可以开始写博客了，你所有的博客以.md文件形式存储在/source/_posts文件夹下<br>如果你需要新建一篇博客，在命令行中输入 hexo new “blog name”，然后在md文件中编辑即可</p><p>编辑完成后可直接在本地博客中查看效果，输入hexo s,进入本地博客地址观察效果</p><p>输入hexo d -g可真正上传到你的博客地址中，就是最初那个里面什么都没有的xxxx.github.io</p><p>更多操作你都可以在其自带的hello-world.md文件中看到！</p><p>当然你可能会觉得hexo这个界面是真的丑，你可以去自己选比较好看的主题，我是用的next主题，也是比较流行的一种主题。你可以在这个网址上选择不同的主题：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></p><p>这里再推荐一个教程：<a href="https://www.jianshu.com/p/bcdbe7347c8d" target="_blank" rel="noopener">https://www.jianshu.com/p/bcdbe7347c8d</a><br>可以从这个网址里看一看几个比较优秀的主题，然后看是怎么配置的<br>PS: 我超喜欢maupassant这个主题，可惜瑞了，懒得重新配了</p>]]></content>
      
      
        <tags>
            
            <tag> 技术心得 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 831 Masking Personal Information</title>
      <link href="/2018/05/07/Leetcode-831-Masking-Personal-Information/"/>
      <url>/2018/05/07/Leetcode-831-Masking-Personal-Information/</url>
      <content type="html"><![CDATA[<p><img src="/images/leetcode_831_1.png" alt="这是题目描述"><br><a id="more"></a><br><img src="/images/leetcode_831_2.png" alt="这是示例"></p><p>思路:<br>先判断到底是email还是phonenumber，根据情况依次判断<br>email只取@符号前面的字符串的首末两个字符，其余不变(当然要先把所有的变成小写)<br>phone就判断数字有多少个，超过10就多一个+号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maskPII</span><span class="params">(S)</span>:</span></span><br><span class="line"><span class="comment"># 定义一个flag,为1的时候代表是email,为0的时候代表是phonenumber</span></span><br><span class="line"><span class="comment"># 初始化为1，即默认是email，通过开头是否是数字或符号来判断是否改变</span></span><br><span class="line">flag = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> S[<span class="number">0</span>] <span class="keyword">in</span> <span class="string">'()0123456789+-'</span>: flag = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">const_str = <span class="string">'***-***-'</span></span><br><span class="line"><span class="keyword">if</span> flag == <span class="number">0</span>: <span class="comment"># means S is phonenumber</span></span><br><span class="line">cnt = <span class="number">0</span>   <span class="comment"># 记录S中数字的长度</span></span><br><span class="line">rec = <span class="string">''</span>  <span class="comment">#记录S中最后四位数字</span></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> range(len(S)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line"><span class="keyword">if</span> S[e] <span class="keyword">in</span> <span class="string">'1234567890'</span>: </span><br><span class="line">cnt += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> cnt &lt;= <span class="number">4</span>: rec += S[e]</span><br><span class="line"><span class="keyword">if</span> cnt == <span class="number">10</span>: <span class="keyword">return</span> const_str + rec[::<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">else</span>: <span class="keyword">return</span> <span class="string">'+'</span> + <span class="string">'*'</span>*(cnt<span class="number">-10</span>) + <span class="string">'-'</span> + const_str + rec[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> flag == <span class="number">1</span>: <span class="comment"># means S is email address</span></span><br><span class="line">S = S.lower()</span><br><span class="line">l,r = S.split(<span class="string">'@'</span>)</span><br><span class="line"><span class="keyword">return</span> l[<span class="number">0</span>] + <span class="string">'*****'</span> + l[<span class="number">-1</span>] + <span class="string">'@'</span> + r</span><br><span class="line"></span><br><span class="line"><span class="string">"difficulty: midium</span></span><br><span class="line"><span class="string">66 / 66 test cases passed.</span></span><br><span class="line"><span class="string">Runtime: 39 ms"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 830 Positions of Large Groups</title>
      <link href="/2018/05/06/Leetcode-830-Positions-of-Large-Groups/"/>
      <url>/2018/05/06/Leetcode-830-Positions-of-Large-Groups/</url>
      <content type="html"><![CDATA[<p>In a string S of lowercase letters, these letters form consecutive groups of the same character.</p><p>For example, a string like S = “abbxxxxzyy” has the groups “a”, “bb”, “xxxx”, “z” and “yy”.</p><p>Call a group large if it has 3 or more characters.  We would like the starting and ending positions of every large group.</p><p>The final answer should be in lexicographic order.</p><blockquote><p>Example 1:<br>Input: “abbxxxxzzy”<br>Output: [[3,6]]<br>Explanation: “xxxx” is the single large group with starting  3 and ending positions 6.</p></blockquote><a id="more"></a><blockquote><p>Example 2:<br>Input: “abc”<br>Output: []<br>Explanation: We have “a”,”b” and “c” but no large group.</p></blockquote><blockquote><p>Example 3:<br>Input: “abcdddeeeeaabbbcd”<br>Output: [[3,5],[6,9],[12,14]]</p></blockquote><p>Note:  1 &lt;= S.length &lt;= 1000</p><p>思路：<br>一道简单的字符串处理问题。每次判断是否有连续三个以上的字符相同，相同则将下标加入res。注意处理边界问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largeGroupPositions</span><span class="params">(S)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type S: str</span></span><br><span class="line"><span class="string">    :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    i,j = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> i &lt; len(S):</span><br><span class="line">        j = i+<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; len(S) <span class="keyword">and</span> S[j] == S[i]: j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> j-i &gt;= <span class="number">3</span>: res.append([i,j<span class="number">-1</span>])</span><br><span class="line">        i = j</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="string">"difficulty: easy</span></span><br><span class="line"><span class="string">202 / 202 test cases passed.</span></span><br><span class="line"><span class="string">Runtime: 114 ms"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Leetcode problems </tag>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
